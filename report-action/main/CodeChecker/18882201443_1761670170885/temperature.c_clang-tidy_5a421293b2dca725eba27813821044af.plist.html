<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(report.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  renderMainWarning : function (currentEvents) {
    if (this._currentReport.fileId != this._filepath.innerHTML)
      return false;

    if (currentEvents.length == 0) {
      return true;
    }

    var lastEvent = currentEvents[currentEvents.length - 1];
    if (lastEvent.message != this._currentReport.message ||
      lastEvent.line != this._currentReport.line) {
      return true;
    }

    return false;
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';
      if (that.renderMainWarning(currentEvents)) {
        type = 'info';
      }

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
    // If there are no events, or the last event does not match
    // the main warning message we print the warning message as a separate
    // error node.
    var lastEvent = currentEvents.length > 0 ? currentEvents[currentEvents.length - 1] : null;
    if (this.renderMainWarning(currentEvents)) {
      var element = document.createElement('div');
      var left = lastEvent ? that._codeMirror.defaultCharWidth() * lastEvent.column + 'px' : '0px';
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + "error");
      var error_tag = document.createElement('span');
      error_tag.setAttribute('class', 'checker-enum error');
      error_tag.innerHTML = "E";
      element.appendChild(error_tag);
      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(this._currentReport.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');
      element.appendChild(msg);
      that._lineWidgets.push(that._codeMirror.addLineWidget(
        this._currentReport.line - 1, element));
    }
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c": {"id": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "filePath": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "content": "/*\n * Copyright (c) 2025 Alexandre Bailon\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#define DT_DRV_COMPAT nabucasa_esphome_sensor_temperature\n\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/sensor.h&gt;\n\n#include &lt;esphome/components/api.h&gt;\n#include &lt;esphome/components/sensor.h&gt;\n\n#include &lt;zephyr/logging/log.h&gt;\nLOG_MODULE_DECLARE(ESPHome, CONFIG_ESPHOME_LOG_LEVEL);\n\nstruct esphome_temperature_sensor_config {\n\tconst struct device *sensor;\n};\n\nint device_read_temperature(const struct device *dev, float *state)\n{\n\tconst struct esphome_temperature_sensor_config *config = dev-&gt;config;\n\tstruct sensor_value sensor_val;\n\tint ret;\n\n\tret = sensor_sample_fetch(config-&gt;sensor);\n\tif (ret) {\n\t\tLOG_ERR(&quot;Failed to fetch sensor sample [%d]&quot;, ret);\n\t\treturn ret;\n\t}\n\n\tret = sensor_channel_get(config-&gt;sensor, SENSOR_CHAN_AMBIENT_TEMP, &amp;sensor_val);\n\tif (ret) {\n\t\tLOG_ERR(&quot;Failed to get sensor channel [%d]&quot;, ret);\n\t\treturn ret;\n\t}\n\n\t*state = sensor_value_to_float(&amp;sensor_val);\n\n\treturn ret;\n}\n\nvoid sensor_temperature_handler(const struct device *dev, const struct sensor_trigger *trigger)\n{\n\tstruct esphome_sensor_data *data = CONTAINER_OF(trigger, struct esphome_sensor_data, trig);\n\n\tARG_UNUSED(dev);\n\n\tdata-&gt;data_rdy = 1;\n}\n\nint device_init_temperature(const struct device *dev)\n{\n\tconst struct esphome_temperature_sensor_config *config = dev-&gt;config;\n\tstruct esphome_sensor_data *data = dev-&gt;data;\n\n\tif (!device_is_ready(config-&gt;sensor)) {\n\t\treturn -ENODEV;\n\t}\n\n\t/* TODO: use the delta trigger with configurable threshold */\n\tdata-&gt;trig.type = SENSOR_TRIG_DATA_READY;\n\tdata-&gt;trig.chan = SENSOR_CHAN_AMBIENT_TEMP;\n\tsensor_trigger_set(config-&gt;sensor, &amp;data-&gt;trig, sensor_temperature_handler);\n\n\treturn 0;\n}\n\nstruct esphome_sensor_api esphome_temperature_sensor = {\n\t.init = device_init_temperature,\n\t.read = device_read_temperature,\n};\n\n#define DEFINE_ESPHOME_SENSOR_TEMPERATURE(_num)                                                    \\\n                                                                                                   \\\n\tstruct esphome_temperature_sensor_config esphome_temperature_sensor_config##_num = {       \\\n\t\t.sensor = DEVICE_DT_GET(DT_PHANDLE_BY_IDX(DT_DRV_INST(_num), sensor, 0)),          \\\n\t};                                                                                         \\\n\tstatic struct esphome_sensor_data esphome_sensor_data_##_num;                              \\\n                                                                                                   \\\n\tDEVICE_DT_INST_DEFINE(_num, esphome_sensor_init, NULL, &amp;esphome_sensor_data_##_num,        \\\n\t\t\t      &amp;esphome_temperature_sensor_config##_num, POST_KERNEL,               \\\n\t\t\t      CONFIG_ESPHOME_INIT_PRIORITY, &amp;esphome_temperature_sensor);          \\\n\tDEFINE_ESPHOME_SENSOR_ENTITY(_num, esphome_temp_sensor_##_num);\n\nDT_INST_FOREACH_STATUS_OKAY(DEFINE_ESPHOME_SENSOR_TEMPERATURE);\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log.h", "content": "/*\n * Copyright (c) 2018 Nordic Semiconductor ASA\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_LOGGING_LOG_H_\n#define ZEPHYR_INCLUDE_LOGGING_LOG_H_\n\n#include &lt;zephyr/logging/log_instance.h&gt;\n#include &lt;zephyr/logging/log_core.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n\n#if CONFIG_USERSPACE &amp;&amp; CONFIG_LOG_ALWAYS_RUNTIME\n#include &lt;zephyr/app_memory/app_memdomain.h&gt;\n#endif\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @brief Logging\n * @defgroup logging Logging\n * @since 1.13\n * @version 1.0.0\n * @ingroup os_services\n * @{\n * @}\n */\n\n/**\n * @brief Logger API\n * @defgroup log_api Logging API\n * @ingroup logger\n * @{\n */\n\n/**\n * @brief Writes an ERROR level message to the log.\n *\n * @details It&#x27;s meant to report severe errors, such as those from which it&#x27;s\n * not possible to recover.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_ERR(...)    Z_LOG(LOG_LEVEL_ERR, __VA_ARGS__)\n\n/**\n * @brief Writes a WARNING level message to the log.\n *\n * @details It&#x27;s meant to register messages related to unusual situations that\n * are not necessarily errors.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_WRN(...)   Z_LOG(LOG_LEVEL_WRN, __VA_ARGS__)\n\n/**\n * @brief Writes an INFO level message to the log.\n *\n * @details It&#x27;s meant to write generic user oriented messages.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_INF(...)   Z_LOG(LOG_LEVEL_INF, __VA_ARGS__)\n\n/**\n * @brief Writes a DEBUG level message to the log.\n *\n * @details It&#x27;s meant to write developer oriented information.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_DBG(...)    Z_LOG(LOG_LEVEL_DBG, __VA_ARGS__)\n\n/**\n * @brief Writes a WARNING level message to the log on the first execution only.\n *\n * @details It&#x27;s meant for situations that warrant investigation but could clutter\n * the logs if output on every execution.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_WRN_ONCE(...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstatic uint8_t __warned;\t\t\t\\\n\t\tif (unlikely(__warned == 0)) {\t\t\t\\\n\t\t\tZ_LOG(LOG_LEVEL_WRN, __VA_ARGS__);\t\\\n\t\t\t__warned = 1;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n/**\n * @brief Unconditionally print raw log message.\n *\n * The result is same as if printk was used but it goes through logging\n * infrastructure thus utilizes logging mode, e.g. deferred mode.\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_PRINTK(...) Z_LOG_PRINTK(0, __VA_ARGS__)\n\n/**\n * @brief Unconditionally print raw log message.\n *\n * Provided string is printed as is without appending any characters (e.g., color or newline).\n *\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_RAW(...) Z_LOG_PRINTK(1, __VA_ARGS__)\n\n/**\n * @brief Writes an ERROR level message associated with the instance to the log.\n *\n * Message is associated with specific instance of the module which has\n * independent filtering settings (if runtime filtering is enabled) and\n * message prefix (\\&lt;module_name\\&gt;.\\&lt;instance_name\\&gt;). It&#x27;s meant to report\n * severe errors, such as those from which it&#x27;s not possible to recover.\n *\n * @param _log_inst Pointer to the log structure associated with the instance.\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_INST_ERR(_log_inst, ...) \\\n\tZ_LOG_INSTANCE(LOG_LEVEL_ERR, _log_inst, __VA_ARGS__)\n\n/**\n * @brief Writes a WARNING level message associated with the instance to the\n *        log.\n *\n * Message is associated with specific instance of the module which has\n * independent filtering settings (if runtime filtering is enabled) and\n * message prefix (\\&lt;module_name\\&gt;.\\&lt;instance_name\\&gt;). It&#x27;s meant to register\n * messages related to unusual situations that are not necessarily errors.\n *\n * @param _log_inst Pointer to the log structure associated with the instance.\n * @param ...       A string optionally containing printk valid conversion\n *                  specifier, followed by as many values as specifiers.\n */\n#define LOG_INST_WRN(_log_inst, ...) \\\n\tZ_LOG_INSTANCE(LOG_LEVEL_WRN, _log_inst, __VA_ARGS__)\n\n/**\n * @brief Writes an INFO level message associated with the instance to the log.\n *\n * Message is associated with specific instance of the module which has\n * independent filtering settings (if runtime filtering is enabled) and\n * message prefix (\\&lt;module_name\\&gt;.\\&lt;instance_name\\&gt;). It&#x27;s meant to write\n * generic user oriented messages.\n *\n * @param _log_inst Pointer to the log structure associated with the instance.\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_INST_INF(_log_inst, ...) \\\n\tZ_LOG_INSTANCE(LOG_LEVEL_INF, _log_inst, __VA_ARGS__)\n\n/**\n * @brief Writes a DEBUG level message associated with the instance to the log.\n *\n * Message is associated with specific instance of the module which has\n * independent filtering settings (if runtime filtering is enabled) and\n * message prefix (\\&lt;module_name\\&gt;.\\&lt;instance_name\\&gt;). It&#x27;s meant to write\n * developer oriented information.\n *\n * @param _log_inst Pointer to the log structure associated with the instance.\n * @param ... A string optionally containing printk valid conversion specifier,\n * followed by as many values as specifiers.\n */\n#define LOG_INST_DBG(_log_inst, ...) \\\n\tZ_LOG_INSTANCE(LOG_LEVEL_DBG, _log_inst, __VA_ARGS__)\n\n/**\n * @brief Writes an ERROR level hexdump message to the log.\n *\n * @details It&#x27;s meant to report severe errors, such as those from which it&#x27;s\n * not possible to recover.\n *\n * @param _data   Pointer to the data to be logged.\n * @param _length Length of data (in bytes).\n * @param _str    Persistent, raw string.\n */\n#define LOG_HEXDUMP_ERR(_data, _length, _str) \\\n\tZ_LOG_HEXDUMP(LOG_LEVEL_ERR, _data, _length, (_str))\n\n/**\n * @brief Writes a WARNING level message to the log.\n *\n * @details It&#x27;s meant to register messages related to unusual situations that\n * are not necessarily errors.\n *\n * @param _data   Pointer to the data to be logged.\n * @param _length Length of data (in bytes).\n * @param _str    Persistent, raw string.\n */\n#define LOG_HEXDUMP_WRN(_data, _length, _str) \\\n\tZ_LOG_HEXDUMP(LOG_LEVEL_WRN, _data, _length, (_str))\n\n/**\n * @brief Writes an INFO level message to the log.\n *\n * @details It&#x27;s meant to write generic user oriented messages.\n *\n * @param _data   Pointer to the data to be logged.\n * @param _length Length of data (in bytes).\n * @param _str    Persistent, raw string.\n */\n#define LOG_HEXDUMP_INF(_data, _length, _str) \\\n\tZ_LOG_HEXDUMP(LOG_LEVEL_INF, _data, _length, (_str))\n\n/**\n * @brief Writes a DEBUG level message to the log.\n *\n * @details It&#x27;s meant to write developer oriented information.\n *\n * @param _data   Pointer to the data to be logged.\n * @param _length Length of data (in bytes).\n * @param _str    Persistent, raw string.\n */\n#define LOG_HEXDUMP_DBG(_data, _length, _str) \\\n\tZ_LOG_HEXDUMP(LOG_LEVEL_DBG, _data, _length, (_str))\n\n/**\n * @brief Writes an ERROR hexdump message associated with the instance to the\n *        log.\n *\n * Message is associated with specific instance of the module which has\n * independent filtering settings (if runtime filtering is enabled) and\n * message prefix (\\&lt;module_name\\&gt;.\\&lt;instance_name\\&gt;). It&#x27;s meant to report\n * severe errors, such as those from which it&#x27;s not possible to recover.\n *\n * @param _log_inst   Pointer to the log structure associated with the instance.\n * @param _data       Pointer to the data to be logged.\n * @param _length     Length of data (in bytes).\n * @param _str        Persistent, raw string.\n */\n#define LOG_INST_HEXDUMP_ERR(_log_inst, _data, _length, _str) \\\n\tZ_LOG_HEXDUMP_INSTANCE(LOG_LEVEL_ERR, _log_inst, _data, _length, _str)\n\n/**\n * @brief Writes a WARNING level hexdump message associated with the instance to\n *        the log.\n *\n * @details It&#x27;s meant to register messages related to unusual situations that\n * are not necessarily errors.\n *\n * @param _log_inst   Pointer to the log structure associated with the instance.\n * @param _data       Pointer to the data to be logged.\n * @param _length     Length of data (in bytes).\n * @param _str        Persistent, raw string.\n */\n#define LOG_INST_HEXDUMP_WRN(_log_inst, _data, _length, _str) \\\n\tZ_LOG_HEXDUMP_INSTANCE(LOG_LEVEL_WRN, _log_inst, _data, _length, _str)\n\n/**\n * @brief Writes an INFO level hexdump message associated with the instance to\n *        the log.\n *\n * @details It&#x27;s meant to write generic user oriented messages.\n *\n * @param _log_inst   Pointer to the log structure associated with the instance.\n * @param _data       Pointer to the data to be logged.\n * @param _length     Length of data (in bytes).\n * @param _str        Persistent, raw string.\n */\n#define LOG_INST_HEXDUMP_INF(_log_inst, _data, _length, _str) \\\n\tZ_LOG_HEXDUMP_INSTANCE(LOG_LEVEL_INF, _log_inst, _data, _length, _str)\n\n/**\n * @brief Writes a DEBUG level hexdump message associated with the instance to\n *        the log.\n *\n * @details It&#x27;s meant to write developer oriented information.\n *\n * @param _log_inst   Pointer to the log structure associated with the instance.\n * @param _data       Pointer to the data to be logged.\n * @param _length     Length of data (in bytes).\n * @param _str        Persistent, raw string.\n */\n#define LOG_INST_HEXDUMP_DBG(_log_inst, _data, _length, _str)\t\\\n\tZ_LOG_HEXDUMP_INSTANCE(LOG_LEVEL_DBG, _log_inst, _data, _length, _str)\n\n/**\n * @brief Writes an formatted string to the log.\n *\n * @details Conditionally compiled (see CONFIG_LOG_PRINTK). Function provides\n * printk functionality.\n *\n * It is less efficient compared to standard logging because static packaging\n * cannot be used.\n *\n * @param fmt Formatted string to output.\n * @param ap  Variable parameters.\n */\nvoid z_log_vprintk(const char *fmt, va_list ap);\n\n#ifdef __cplusplus\n}\n#define LOG_IN_CPLUSPLUS 1\n#endif\n/* Macro expects that optionally on second argument local log level is provided.\n * If provided it is returned, otherwise default log level is returned or\n * LOG_LEVEL, if it was locally defined.\n */\n#if !defined(CONFIG_LOG)\n#define _LOG_LEVEL_RESOLVE(...) LOG_LEVEL_NONE\n#else\n#define _LOG_LEVEL_RESOLVE(...) \\\n\tZ_LOG_EVAL(COND_CODE_0(LOG_LEVEL, (1), (LOG_LEVEL)), \\\n\t\t  (GET_ARG_N(2, __VA_ARGS__, LOG_LEVEL)), \\\n\t\t  (GET_ARG_N(2, __VA_ARGS__, CONFIG_LOG_DEFAULT_LEVEL)))\n#endif\n\n/* Return first argument */\n#define _LOG_ARG1(arg1, ...) arg1\n\n#define _LOG_MODULE_CONST_DATA_CREATE(_name, _level)\t\t\t\t\t\t\\\n\tIF_ENABLED(CONFIG_LOG_FMT_SECTION, (\t\t\t\t\t\t\t\\\n\t\tstatic const char UTIL_CAT(_name, _str)[]\t\t\t\t\t\\\n\t\t     __in_section(_log_strings, static, _CONCAT(_name, _)) __used __noasan =\t\\\n\t\t     STRINGIFY(_name);))\t\t\t\t\t\t\t\\\n\tIF_ENABLED(LOG_IN_CPLUSPLUS, (extern))\t\t\t\t\t\t\t\\\n\tconst STRUCT_SECTION_ITERABLE_ALTERNATE(log_const,\t\t\t\t\t\\\n\t\tlog_source_const_data,\t\t\t\t\t\t\t\t\\\n\t\tZ_LOG_ITEM_CONST_DATA(_name)) =\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t.name = COND_CODE_1(CONFIG_LOG_FMT_SECTION,\t\t\t\t\t\\\n\t\t\t\t(UTIL_CAT(_name, _str)), (STRINGIFY(_name))),\t\t\t\\\n\t\t.level = (_level)\t\t\t\t\t\t\t\t\\\n\t}\n\n#define _LOG_MODULE_DYNAMIC_DATA_CREATE(_name)\t\t\t\t\t\\\n\tSTRUCT_SECTION_ITERABLE_ALTERNATE(log_dynamic, log_source_dynamic_data, \\\n\t\t\tLOG_ITEM_DYNAMIC_DATA(_name))\n\n#define _LOG_MODULE_DYNAMIC_DATA_COND_CREATE(_name)\t\t\\\n\tIF_ENABLED(CONFIG_LOG_RUNTIME_FILTERING,\t\t\\\n\t\t  (_LOG_MODULE_DYNAMIC_DATA_CREATE(_name);))\n\n#define _LOG_MODULE_DATA_CREATE(_name, _level)\t\t\t\\\n\t_LOG_MODULE_CONST_DATA_CREATE(_name, _level);\t\t\\\n\t_LOG_MODULE_DYNAMIC_DATA_COND_CREATE(_name)\n\n/* Determine if data for the module shall be created. It is created if logging\n * is enabled, override level is set or module specific level is set (not off).\n */\n#define Z_DO_LOG_MODULE_REGISTER(...) \\\n\tCOND_CODE_1(CONFIG_LOG, \\\n\t\t(Z_LOG_EVAL(CONFIG_LOG_OVERRIDE_LEVEL, \\\n\t\t   (1), \\\n\t\t   (Z_LOG_EVAL(_LOG_LEVEL_RESOLVE(__VA_ARGS__), (1), (0))) \\\n\t\t  )), (0))\n\n/* Determine if the data of the log module shall be in the partition\n * &#x27;k_log_partition&#x27; to allow a user mode thread access to this data.\n */\n#if CONFIG_USERSPACE &amp;&amp; CONFIG_LOG_ALWAYS_RUNTIME\nextern struct k_mem_partition k_log_partition;\n#define Z_LOG_MODULE_PARTITION(_k_app_mem) _k_app_mem(k_log_partition)\n#else\n#define Z_LOG_MODULE_PARTITION(_k_app_mem)\n#endif\n\n/**\n * @brief Create module-specific state and register the module with Logger.\n *\n * This macro normally must be used after including &lt;zephyr/logging/log.h&gt; to\n * complete the initialization of the module.\n *\n * Module registration can be skipped in two cases:\n *\n * - The module consists of more than one file, and another file\n *   invokes this macro. (LOG_MODULE_DECLARE() should be used instead\n *   in all of the module&#x27;s other files.)\n * - Instance logging is used and there is no need to create module entry. In\n *   that case LOG_LEVEL_SET() should be used to set log level used within the\n *   file.\n *\n * Macro accepts one or two parameters:\n * - module name\n * - optional log level. If not provided then default log level is used in\n *  the file.\n *\n * Example usage:\n * - LOG_MODULE_REGISTER(foo, CONFIG_FOO_LOG_LEVEL)\n * - LOG_MODULE_REGISTER(foo)\n *\n *\n * @note The module&#x27;s state is defined, and the module is registered,\n *       only if LOG_LEVEL for the current source file is non-zero or\n *       it is not defined and CONFIG_LOG_DEFAULT_LEVEL is non-zero.\n *       In other cases, this macro has no effect.\n * @see LOG_MODULE_DECLARE\n */\n#define LOG_MODULE_REGISTER(...)\t\t\t\t\t\\\n\tCOND_CODE_1(\t\t\t\t\t\t\t\\\n\t\tZ_DO_LOG_MODULE_REGISTER(__VA_ARGS__),\t\t\t\\\n\t\t(_LOG_MODULE_DATA_CREATE(GET_ARG_N(1, __VA_ARGS__),\t\\\n\t\t\t\t      _LOG_LEVEL_RESOLVE(__VA_ARGS__))),\\\n\t\t() \\\n\t)\t\t\t\t\t\t\t\t\\\n\tLOG_MODULE_DECLARE(__VA_ARGS__)\n\n/**\n * @brief Macro for declaring a log module (not registering it).\n *\n * Modules which are split up over multiple files must have exactly\n * one file use LOG_MODULE_REGISTER() to create module-specific state\n * and register the module with the logger core.\n *\n * The other files in the module should use this macro instead to\n * declare that same state. (Otherwise, LOG_INF() etc. will not be\n * able to refer to module-specific state variables.)\n *\n * Macro accepts one or two parameters:\n * - module name\n * - optional log level. If not provided then default log level is used in\n *  the file.\n *\n * Example usage:\n * - LOG_MODULE_DECLARE(foo, CONFIG_FOO_LOG_LEVEL)\n * - LOG_MODULE_DECLARE(foo)\n *\n * @note The module&#x27;s state is declared only if LOG_LEVEL for the\n *       current source file is non-zero or it is not defined and\n *       CONFIG_LOG_DEFAULT_LEVEL is non-zero.  In other cases,\n *       this macro has no effect.\n * @see LOG_MODULE_REGISTER\n */\n#define LOG_MODULE_DECLARE(...)\t\t\t\t\t\t      \\\n\textern const struct log_source_const_data\t\t\t      \\\n\t\t\tZ_LOG_ITEM_CONST_DATA(GET_ARG_N(1, __VA_ARGS__));     \\\n\textern struct log_source_dynamic_data\t\t\t\t      \\\n\t\t\tLOG_ITEM_DYNAMIC_DATA(GET_ARG_N(1, __VA_ARGS__));     \\\n\t\t\t\t\t\t\t\t\t      \\\n\tZ_LOG_MODULE_PARTITION(K_APP_DMEM)\t\t\t\t      \\\n\tstatic const struct log_source_const_data *\t\t\t      \\\n\t\t__log_current_const_data __unused =\t\t\t      \\\n\t\t\tZ_DO_LOG_MODULE_REGISTER(__VA_ARGS__) ?\t\t      \\\n\t\t\t&amp;Z_LOG_ITEM_CONST_DATA(GET_ARG_N(1, __VA_ARGS__)) :   \\\n\t\t\tNULL;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tZ_LOG_MODULE_PARTITION(K_APP_DMEM)\t\t\t\t      \\\n\tstatic struct log_source_dynamic_data *\t\t\t\t      \\\n\t\t__log_current_dynamic_data __unused =\t\t\t      \\\n\t\t\t(Z_DO_LOG_MODULE_REGISTER(__VA_ARGS__) &amp;&amp;\t      \\\n\t\t\tIS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) ?\t      \\\n\t\t\t&amp;LOG_ITEM_DYNAMIC_DATA(GET_ARG_N(1, __VA_ARGS__)) :   \\\n\t\t\tNULL;\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tZ_LOG_MODULE_PARTITION(K_APP_BMEM)\t\t\t\t      \\\n\tstatic const uint32_t __log_level __unused =\t\t\t      \\\n\t\t\t\t\t_LOG_LEVEL_RESOLVE(__VA_ARGS__)\n\n/**\n * @brief Macro for setting log level in the file or function where instance\n * logging API is used.\n *\n * @param level Level used in file or in function.\n *\n */\n#define LOG_LEVEL_SET(level) static const uint32_t __log_level __unused = \\\n\t\t\t\tZ_LOG_RESOLVED_LEVEL(level, 0)\n\n#ifdef CONFIG_LOG_CUSTOM_HEADER\n/* This include must always be at the end of log.h */\n#include &lt;zephyr_custom_log.h&gt;\n#endif\n\n/*\n * Eclipse CDT or JetBrains Clion parser is sometimes confused by logging API\n * code and freezes the whole IDE. Following lines hides LOG_x macros from them.\n */\n#if defined(__CDT_PARSER__) || defined(__JETBRAINS_IDE__)\n#undef LOG_ERR\n#undef LOG_WRN\n#undef LOG_INF\n#undef LOG_DBG\n\n#undef LOG_HEXDUMP_ERR\n#undef LOG_HEXDUMP_WRN\n#undef LOG_HEXDUMP_INF\n#undef LOG_HEXDUMP_DBG\n\n#define LOG_ERR(...) (void) 0\n#define LOG_WRN(...) (void) 0\n#define LOG_DBG(...) (void) 0\n#define LOG_INF(...) (void) 0\n\n#define LOG_HEXDUMP_ERR(...) (void) 0\n#define LOG_HEXDUMP_WRN(...) (void) 0\n#define LOG_HEXDUMP_DBG(...) (void) 0\n#define LOG_HEXDUMP_INF(...) (void) 0\n#endif\n\n/**\n * @}\n */\n\n#endif /* ZEPHYR_INCLUDE_LOGGING_LOG_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "content": "/*\n * Copyright (c) 2018 Nordic Semiconductor ASA\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n#ifndef ZEPHYR_INCLUDE_LOGGING_LOG_CORE_H_\n#define ZEPHYR_INCLUDE_LOGGING_LOG_CORE_H_\n\n#include &lt;zephyr/logging/log_msg.h&gt;\n#include &lt;zephyr/logging/log_instance.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;zephyr/sys/util.h&gt;\n\n/* This header file keeps all macros and functions needed for creating logging\n * messages (macros like @ref LOG_ERR).\n */\n#define LOG_LEVEL_NONE 0\n#define LOG_LEVEL_ERR  1\n#define LOG_LEVEL_WRN  2\n#define LOG_LEVEL_INF  3\n#define LOG_LEVEL_DBG  4\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n#ifndef CONFIG_LOG\n#define CONFIG_LOG_DEFAULT_LEVEL 0\n#define CONFIG_LOG_MAX_LEVEL 0\n#endif\n\n/* Id of local domain. */\n#define Z_LOG_LOCAL_DOMAIN_ID 0\n\n#define LOG_FUNCTION_PREFIX_MASK \\\n\t(((uint32_t)IS_ENABLED(CONFIG_LOG_FUNC_NAME_PREFIX_ERR) &lt;&lt; \\\n\t  LOG_LEVEL_ERR) | \\\n\t ((uint32_t)IS_ENABLED(CONFIG_LOG_FUNC_NAME_PREFIX_WRN) &lt;&lt; \\\n\t  LOG_LEVEL_WRN) | \\\n\t ((uint32_t)IS_ENABLED(CONFIG_LOG_FUNC_NAME_PREFIX_INF) &lt;&lt; \\\n\t  LOG_LEVEL_INF) | \\\n\t ((uint32_t)IS_ENABLED(CONFIG_LOG_FUNC_NAME_PREFIX_DBG) &lt;&lt; LOG_LEVEL_DBG))\n\n/** @brief Macro for returning local level value if defined or default.\n *\n * Check @ref IS_ENABLED macro for detailed explanation of the trick.\n */\n#define Z_LOG_RESOLVED_LEVEL(_level, _default) \\\n\tZ_LOG_RESOLVED_LEVEL1(_level, _default)\n\n#define Z_LOG_RESOLVED_LEVEL1(_level, _default) \\\n\t__COND_CODE(_LOG_XXXX##_level, (_level), (_default))\n\n#define _LOG_XXXX0  _LOG_YYYY,\n#define _LOG_XXXX1  _LOG_YYYY,\n#define _LOG_XXXX2  _LOG_YYYY,\n#define _LOG_XXXX3  _LOG_YYYY,\n#define _LOG_XXXX4  _LOG_YYYY,\n\n/**\n * @brief Macro for conditional code generation if provided log level allows.\n *\n * Macro behaves similarly to standard \\#if \\#else \\#endif clause. The\n * difference is that it is evaluated when used and not when header file is\n * included.\n *\n * @param _eval_level Evaluated level. If level evaluates to one of existing log\n *\t\t      log level (1-4) then macro evaluates to _iftrue.\n * @param _iftrue     Code that should be inserted when evaluated to true. Note,\n *\t\t      that parameter must be provided in brackets.\n * @param _iffalse    Code that should be inserted when evaluated to false.\n *\t\t      Note, that parameter must be provided in brackets.\n */\n#define Z_LOG_EVAL(_eval_level, _iftrue, _iffalse) \\\n\tZ_LOG_EVAL1(_eval_level, _iftrue, _iffalse)\n\n#define Z_LOG_EVAL1(_eval_level, _iftrue, _iffalse) \\\n\t__COND_CODE(_LOG_ZZZZ##_eval_level, _iftrue, _iffalse)\n\n#define _LOG_ZZZZ1  _LOG_YYYY,\n#define _LOG_ZZZZ2  _LOG_YYYY,\n#define _LOG_ZZZZ3  _LOG_YYYY,\n#define _LOG_ZZZZ4  _LOG_YYYY,\n\n/**\n *\n * @brief Macro for getting ID of current module.\n */\n#define LOG_CURRENT_MODULE_ID() (__log_level != 0 ? \\\n\tlog_const_source_id(__log_current_const_data) : 0U)\n\n/* Set of defines that are set to 1 if function name prefix is enabled for given level. */\n#define Z_LOG_FUNC_PREFIX_0 0\n#define Z_LOG_FUNC_PREFIX_1 COND_CODE_1(CONFIG_LOG_FUNC_NAME_PREFIX_ERR, (1), (0))\n#define Z_LOG_FUNC_PREFIX_2 COND_CODE_1(CONFIG_LOG_FUNC_NAME_PREFIX_WRN, (1), (0))\n#define Z_LOG_FUNC_PREFIX_3 COND_CODE_1(CONFIG_LOG_FUNC_NAME_PREFIX_INF, (1), (0))\n#define Z_LOG_FUNC_PREFIX_4 COND_CODE_1(CONFIG_LOG_FUNC_NAME_PREFIX_DBG, (1), (0))\n\n/**\n * @brief Macro for optional injection of function name as first argument of\n *\t  formatted string. COND_CODE_0() macro is used to handle no arguments\n *\t  case.\n *\n * The purpose of this macro is to prefix string literal with format specifier\n * for function name and inject function name as first argument. In order to\n * handle string with no arguments _LOG_Z_EVAL is used.\n */\n#define Z_LOG_STR_WITH_PREFIX2(...) \\\n\t&quot;%s: &quot; GET_ARG_N(1, __VA_ARGS__), (const char *)__func__\\\n\t\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__),\\\n\t\t\t    (),\\\n\t\t\t    (, GET_ARGS_LESS_N(1, __VA_ARGS__))\\\n\t\t\t   )\n\n/* Macro handles case when no format string is provided: e.g. LOG_DBG().\n * Handling of format string is deferred to the next level macro.\n */\n#define Z_LOG_STR_WITH_PREFIX(...) \\\n\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\\n\t\t(&quot;%s&quot;, (const char *)__func__), \\\n\t\t(Z_LOG_STR_WITH_PREFIX2(__VA_ARGS__)))\n\n/**\n * @brief Handle optional injection of function name as the first argument.\n *\n * Additionally, macro is handling the empty message case.\n */\n#define Z_LOG_STR(_level, ...) \\\n\tCOND_CODE_1(UTIL_CAT(Z_LOG_FUNC_PREFIX_##_level), \\\n\t\t(Z_LOG_STR_WITH_PREFIX(__VA_ARGS__)), (__VA_ARGS__))\n\n#define Z_LOG_LEVEL_CHECK(_level, _check_level, _default_level) \\\n\t((_level) &lt;= Z_LOG_RESOLVED_LEVEL(_check_level, _default_level))\n\n/** @brief Compile time level checking.\n *\n * This check is resolved at compile time and logging message is removed if check fails.\n *\n * @param _level Log level.\n *\n * @retval true Message shall be compiled in.\n * @retval false Message shall removed during the compilation.\n */\n#define Z_LOG_CONST_LEVEL_CHECK(_level)\t\t\t\t\t    \\\n\t(IS_ENABLED(CONFIG_LOG) &amp;&amp;\t\t\t\t\t    \\\n\t(Z_LOG_LEVEL_CHECK(_level, CONFIG_LOG_OVERRIDE_LEVEL, LOG_LEVEL_NONE) \\\n\t||\t\t\t\t\t\t\t\t    \\\n\t((IS_ENABLED(CONFIG_LOG_OVERRIDE_LEVEL) == false) &amp;&amp;\t\t    \\\n\t((_level) &lt;= __log_level) &amp;&amp;\t\t\t\t\t    \\\n\t((_level) &lt;= CONFIG_LOG_MAX_LEVEL)\t\t\t\t    \\\n\t)\t\t\t\t\t\t\t\t    \\\n\t))\n\n/** @brief Static level checking for instance logging.\n *\n * This check applies only to instance logging and only if runtime filtering\n * is disabled. It is performed in runtime but because level comes from the\n * structure which is constant it is not exact runtime filtering because it\n * cannot be changed in runtime.\n *\n * @param _level Log level.\n * @param _inst 1 is source is the instance of a module.\n * @param _source Data associated with the instance.\n *\n * @retval true Continue with log message creation.\n * @retval false Drop that message.\n */\n#define Z_LOG_STATIC_INST_LEVEL_CHECK(_level, _inst, _source)                                      \\\n\t(IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) || !_inst ||                                     \\\n\t (_level &lt;= ((const struct log_source_const_data *)_source)-&gt;level))\n\n/** @brief Dynamic level checking.\n *\n * It uses the level from the dynamic structure.\n *\n * @param _level Log level.\n * @param _source Data associated with the source.\n *\n * @retval true Continue with log message creation.\n * @retval false Drop that message.\n */\n#define Z_LOG_DYNAMIC_LEVEL_CHECK(_level, _source)                                                 \\\n\t(!IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) || k_is_user_context() ||                       \\\n\t ((_level) &lt;= Z_LOG_RUNTIME_FILTER(((struct log_source_dynamic_data *)_source)-&gt;filters)))\n\n/** @brief Check if message shall be created.\n *\n * Aggregate all checks into a single one.\n *\n * @param _level Log level.\n * @param _inst 1 is source is the instance of a module.\n * @param _source Data associated with the source.\n *\n * @retval true Continue with log message creation.\n * @retval false Drop that message.\n */\n#define Z_LOG_LEVEL_ALL_CHECK(_level, _inst, _source)                                              \\\n\t(Z_LOG_CONST_LEVEL_CHECK(_level) &amp;&amp;                                                        \\\n\t Z_LOG_STATIC_INST_LEVEL_CHECK(_level, _inst, _source) &amp;&amp;                                  \\\n\t Z_LOG_DYNAMIC_LEVEL_CHECK(_level, _source))\n\n/** @brief Get current module data that is used for source id retrieving.\n *\n * If runtime filtering is used then pointer to dynamic data is returned and else constant\n * data is used.\n */\n#define Z_LOG_CURRENT_DATA()                                                                       \\\n\tCOND_CODE_1(CONFIG_LOG_RUNTIME_FILTERING, \\\n\t\t\t(__log_current_dynamic_data), (__log_current_const_data))\n\n/*****************************************************************************/\n/****************** Definitions used by minimal logging *********************/\n/*****************************************************************************/\nvoid z_log_minimal_hexdump_print(int level, const void *data, size_t size);\nvoid z_log_minimal_vprintk(const char *fmt, va_list ap);\nvoid z_log_minimal_printk(const char *fmt, ...);\n\n#define Z_LOG_TO_PRINTK(_level, fmt, ...) do { \\\n\tz_log_minimal_printk(&quot;%c: &quot; fmt &quot;\\n&quot;, \\\n\t\t\t     z_log_minimal_level_to_char(_level), \\\n\t\t\t     ##__VA_ARGS__); \\\n} while (false)\n\n#define Z_LOG_TO_VPRINTK(_level, fmt, valist) do { \\\n\tz_log_minimal_printk(&quot;%c: &quot;, z_log_minimal_level_to_char(_level)); \\\n\tz_log_minimal_vprintk(fmt, valist); \\\n\tz_log_minimal_printk(&quot;\\n&quot;); \\\n} while (false)\n\nstatic inline char z_log_minimal_level_to_char(int level)\n{\n\tswitch (level) {\n\tcase LOG_LEVEL_ERR:\n\t\treturn &#x27;E&#x27;;\n\tcase LOG_LEVEL_WRN:\n\t\treturn &#x27;W&#x27;;\n\tcase LOG_LEVEL_INF:\n\t\treturn &#x27;I&#x27;;\n\tcase LOG_LEVEL_DBG:\n\t\treturn &#x27;D&#x27;;\n\tdefault:\n\t\treturn &#x27;?&#x27;;\n\t}\n}\n\n#define Z_LOG_INST(_inst) COND_CODE_1(CONFIG_LOG, (_inst), NULL)\n\n/* If strings are removed from the binary then there is a risk of creating invalid\n * cbprintf package if %p is used with character pointer which is interpreted as\n * string. A compile time check is performed (since format string is known at\n * compile time) and check fails logging message is not created but error is\n * emitted instead. String check may increase compilation time so it is not\n * always performed (could significantly increase CI time).\n */\n#ifdef CONFIG_LOG_FMT_STRING_VALIDATE\n#define LOG_STRING_WARNING(_mode, _src, ...) \\\n\t    Z_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode, \\\n\t\t\t     Z_LOG_LOCAL_DOMAIN_ID, _src, LOG_LEVEL_ERR, NULL, 0, \\\n\t\t\t     &quot;char pointer used for %%p, cast to void *:\\&quot;%s\\&quot;&quot;, \\\n\t\t\t     GET_ARG_N(1, __VA_ARGS__))\n\n#define LOG_POINTERS_VALIDATE(string_ok, ...) \\\n\tTOOLCHAIN_DISABLE_GCC_WARNING(TOOLCHAIN_WARNING_POINTER_ARITH); \\\n\tstring_ok = Z_CBPRINTF_POINTERS_VALIDATE(__VA_ARGS__); \\\n\tTOOLCHAIN_ENABLE_GCC_WARNING(TOOLCHAIN_WARNING_POINTER_ARITH);\n#else\n#define LOG_POINTERS_VALIDATE(string_ok, ...) string_ok = true\n#define LOG_STRING_WARNING(_mode, _src, ...)\n#endif\n\n/*****************************************************************************/\n/****************** Macros for standard logging ******************************/\n/*****************************************************************************/\n/** @internal\n * @brief Generic logging macro.\n *\n * It checks against static levels (resolved at compile timer), runtime levels\n * and modes and dispatch to relevant processing path.\n *\n * @param _level Log message severity level.\n *\n * @param _inst Set to 1 for instance specific log message. 0 otherwise.\n * @param _source Pointer to a structure associated with the module or instance.\n *                If it is a module then it is used only when runtime filtering is\n *                enabled. If it is instance then it is used in both cases.\n *\n * @param ... String with arguments.\n */\n#define Z_LOG2(_level, _inst, _source, ...)                                                        \\\n\tdo {                                                                                       \\\n\t\tif (!Z_LOG_LEVEL_ALL_CHECK(_level, _inst, _source)) {                              \\\n\t\t\tbreak;                                                                     \\\n\t\t}                                                                                  \\\n\t\tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) {                                         \\\n\t\t\tZ_LOG_TO_PRINTK(_level, __VA_ARGS__);                                      \\\n\t\t\tbreak;                                                                     \\\n\t\t}                                                                                  \\\n\t\tint _mode;                                                                         \\\n\t\tbool string_ok;                                                                    \\\n\t\tLOG_POINTERS_VALIDATE(string_ok, __VA_ARGS__);                                     \\\n\t\tif (!string_ok) {                                                                  \\\n\t\t\tLOG_STRING_WARNING(_mode, _source, __VA_ARGS__);                           \\\n\t\t\tbreak;                                                                     \\\n\t\t}                                                                                  \\\n\t\tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode,                    \\\n\t\t\t\t Z_LOG_LOCAL_DOMAIN_ID, _source, _level, NULL, 0, __VA_ARGS__);    \\\n\t\t(void)_mode;                                                                       \\\n\t\tif (false) {                                                                       \\\n\t\t\t/* Arguments checker present but never evaluated.*/                        \\\n\t\t\t/* Placed here to ensure that __VA_ARGS__ are*/                            \\\n\t\t\t/* evaluated once when log is enabled.*/                                   \\\n\t\t\tz_log_printf_arg_checker(__VA_ARGS__);                                     \\\n\t\t}                                                                                  \\\n\t} while (false)\n\n#define Z_LOG(_level, ...)                 Z_LOG2(_level, 0, Z_LOG_CURRENT_DATA(), __VA_ARGS__)\n#define Z_LOG_INSTANCE(_level, _inst, ...) Z_LOG2(_level, 1, Z_LOG_INST(_inst), __VA_ARGS__)\n\n/*****************************************************************************/\n/****************** Macros for hexdump logging *******************************/\n/*****************************************************************************/\n/** @internal\n * @brief Generic logging macro.\n *\n * It checks against static levels (resolved at compile timer), runtime levels\n * and modes and dispatch to relevant processing path.\n *\n * @param _level Log message severity level.\n *\n * @param _inst Set to 1 for instance specific log message. 0 otherwise.\n *\n * @param _source Pointer to a structure associated with the module or instance.\n *                If it is a module then it is used only when runtime filtering is\n *                enabled. If it is instance then it is used in both cases.\n *\n * @param _data Hexdump data;\n *\n * @param _len Hexdump data length.\n *\n * @param ... String.\n */\n#define Z_LOG_HEXDUMP2(_level, _inst, _source, _data, _len, ...)                                   \\\n\tdo {                                                                                       \\\n\t\tif (!Z_LOG_LEVEL_ALL_CHECK(_level, _inst, _source)) {                              \\\n\t\t\tbreak;                                                                     \\\n\t\t}                                                                                  \\\n\t\tconst char *_str = GET_ARG_N(1, __VA_ARGS__);                                      \\\n\t\tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) {                                         \\\n\t\t\tZ_LOG_TO_PRINTK(_level, &quot;%s&quot;, _str);                                       \\\n\t\t\tz_log_minimal_hexdump_print((_level), (const char *)(_data), (_len));      \\\n\t\t\tbreak;                                                                     \\\n\t\t}                                                                                  \\\n\t\tint _mode;                                                                         \\\n\t\tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode,                    \\\n\t\t\t\t Z_LOG_LOCAL_DOMAIN_ID, _source, _level, _data, _len,              \\\n\t\t\t\t COND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\\n\t\t\t\t(), \\\n\t\t\t  (COND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\\n\t\t\t\t  (&quot;%s&quot;, __VA_ARGS__), (__VA_ARGS__)))));   \\\n\t\t(void)_mode;                                                                       \\\n\t} while (false)\n\n#define Z_LOG_HEXDUMP(_level, _data, _length, ...)                                                 \\\n\tZ_LOG_HEXDUMP2(_level, 0, Z_LOG_CURRENT_DATA(), _data, _length, __VA_ARGS__)\n\n#define Z_LOG_HEXDUMP_INSTANCE(_level, _inst, _data, _length, ...)                                 \\\n\tZ_LOG_HEXDUMP2(_level, 1, Z_LOG_INST(_inst), _data, _length, __VA_ARGS__)\n\n/*****************************************************************************/\n/****************** Filtering macros *****************************************/\n/*****************************************************************************/\n\n/** @brief Number of bits used to encode log level. */\n#define LOG_LEVEL_BITS 3U\n\n/** @brief Filter slot size. */\n#define LOG_FILTER_SLOT_SIZE LOG_LEVEL_BITS\n\n/** @brief Number of slots in one word. */\n#define LOG_FILTERS_NUM_OF_SLOTS (32 / LOG_FILTER_SLOT_SIZE)\n\n/** @brief Maximum number of backends supported when runtime filtering is enabled. */\n#define LOG_FILTERS_MAX_BACKENDS \\\n\t(LOG_FILTERS_NUM_OF_SLOTS - (1 + IS_ENABLED(CONFIG_LOG_FRONTEND)))\n\n/** @brief Slot reserved for the frontend. Last slot is used. */\n#define LOG_FRONTEND_SLOT_ID (LOG_FILTERS_NUM_OF_SLOTS - 1)\n\n/** @brief Slot mask. */\n#define LOG_FILTER_SLOT_MASK (BIT(LOG_FILTER_SLOT_SIZE) - 1U)\n\n/** @brief Bit offset of a slot.\n *\n *  @param _id Slot ID.\n */\n#define LOG_FILTER_SLOT_SHIFT(_id) (LOG_FILTER_SLOT_SIZE * (_id))\n\n#define LOG_FILTER_SLOT_GET(_filters, _id) \\\n\t((*(_filters) &gt;&gt; LOG_FILTER_SLOT_SHIFT(_id)) &amp; LOG_FILTER_SLOT_MASK)\n\n#define LOG_FILTER_SLOT_SET(_filters, _id, _filter)\t\t\t      \\\n\tdo {\t\t\t\t\t\t\t\t      \\\n\t\tuint32_t others = *(_filters) &amp; ~(LOG_FILTER_SLOT_MASK &lt;&lt;     \\\n\t\t\t\t LOG_FILTER_SLOT_SHIFT(_id));\t\t      \\\n\t\t*(_filters) = others | (((_filter) &amp; LOG_FILTER_SLOT_MASK) &lt;&lt; \\\n\t\t\t       LOG_FILTER_SLOT_SHIFT(_id));\t\t      \\\n\t} while (false)\n\n#define LOG_FILTER_AGGR_SLOT_IDX 0\n\n#define LOG_FILTER_AGGR_SLOT_GET(_filters) \\\n\tLOG_FILTER_SLOT_GET(_filters, LOG_FILTER_AGGR_SLOT_IDX)\n\n#define LOG_FILTER_FIRST_BACKEND_SLOT_IDX 1\n\n/* Return aggregated (highest) level for all enabled backends, e.g. if there\n * are 3 active backends, one backend is set to get INF logs from a module and\n * two other backends are set for ERR, returned level is INF.\n */\n#define Z_LOG_RUNTIME_FILTER(_filter) \\\n\tLOG_FILTER_SLOT_GET(&amp;(_filter), LOG_FILTER_AGGR_SLOT_IDX)\n\n/** @brief Log level value used to indicate log entry that should not be\n *\t   formatted (raw string).\n */\n#define LOG_LEVEL_INTERNAL_RAW_STRING LOG_LEVEL_NONE\n\nTYPE_SECTION_START_EXTERN(struct log_source_const_data, log_const);\nTYPE_SECTION_END_EXTERN(struct log_source_const_data, log_const);\n\n/** @brief Create message for logging printk-like string or a raw string.\n *\n * Part of printk string processing is appending of carriage return after any\n * new line character found in the string. If it is not desirable then @p _is_raw\n * can be set to 1 to indicate raw string. This information is stored in the source\n * field which is not used for its typical purpose in this case.\n *\n * @param _is_raw\tSet to 1 to indicate raw string, set to 0 to indicate printk.\n * @param ...\t\tFormat string with arguments.\n */\n#define Z_LOG_PRINTK(_is_raw, ...) do { \\\n\tif (!IS_ENABLED(CONFIG_LOG)) { \\\n\t\tbreak; \\\n\t} \\\n\tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) { \\\n\t\tz_log_minimal_printk(__VA_ARGS__); \\\n\t\tbreak; \\\n\t} \\\n\tint _mode; \\\n\tif (0) {\\\n\t\tz_log_printf_arg_checker(__VA_ARGS__); \\\n\t} \\\n\tZ_LOG_MSG_CREATE(!IS_ENABLED(CONFIG_USERSPACE), _mode, \\\n\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, (const void *)(uintptr_t)_is_raw, \\\n\t\t\t  LOG_LEVEL_INTERNAL_RAW_STRING, NULL, 0, __VA_ARGS__);\\\n} while (0)\n\n/** @brief Get index of the log source based on the address of the constant data\n *         associated with the source.\n *\n * @param data Address of the constant data.\n *\n * @return Source ID.\n */\nstatic inline uint32_t log_const_source_id(\n\t\t\t\tconst struct log_source_const_data *data)\n{\n\treturn ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/\n\t\t\tsizeof(struct log_source_const_data);\n}\n\nTYPE_SECTION_START_EXTERN(struct log_source_dynamic_data, log_dynamic);\nTYPE_SECTION_END_EXTERN(struct log_source_dynamic_data, log_dynamic);\n\n/** @brief Creates name of variable and section for runtime log data.\n *\n *  @param _name Name.\n */\n#define LOG_ITEM_DYNAMIC_DATA(_name) UTIL_CAT(log_dynamic_, _name)\n\n#define LOG_INSTANCE_DYNAMIC_DATA(_module_name, _inst) \\\n\tLOG_ITEM_DYNAMIC_DATA(Z_LOG_INSTANCE_FULL_NAME(_module_name, _inst))\n\n/** @brief Get index of the log source based on the address of the dynamic data\n *         associated with the source.\n *\n * @param data Address of the dynamic data.\n *\n * @return Source ID.\n */\nstatic inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)\n{\n\treturn ((uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_dynamic))/\n\t\t\tsizeof(struct log_source_dynamic_data);\n}\n\n/** @brief Get index of the log source based on the address of the associated data.\n *\n * @param source Address of the data structure (dynamic if runtime filtering is\n * enabled and static otherwise).\n *\n * @return Source ID.\n */\nstatic inline uint32_t log_source_id(const void *source)\n{\n\treturn IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?\n\t\tlog_dynamic_source_id((struct log_source_dynamic_data *)source) :\n\t\tlog_const_source_id((const struct log_source_const_data *)source);\n}\n\n/** @brief Dummy function to trigger log messages arguments type checking. */\nstatic inline __printf_like(1, 2)\nvoid z_log_printf_arg_checker(const char *fmt, ...)\n{\n\tARG_UNUSED(fmt);\n}\n\n/**\n * @brief Write a generic log message.\n *\n * @note This function is intended to be used when porting other log systems.\n *\n * @param level          Log level..\n * @param fmt            String to format.\n * @param ap             Pointer to arguments list.\n */\nstatic inline void log_generic(uint8_t level, const char *fmt, va_list ap)\n{\n\tz_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL, level,\n\t\t\t\t   NULL, 0, 0, fmt, ap);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZEPHYR_INCLUDE_LOGGING_LOG_CORE_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "content": "/*\n * Copyright (c) 2021 Nordic Semiconductor ASA\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n#ifndef ZEPHYR_INCLUDE_LOGGING_LOG_MSG_H_\n#define ZEPHYR_INCLUDE_LOGGING_LOG_MSG_H_\n\n#include &lt;zephyr/logging/log_instance.h&gt;\n#include &lt;zephyr/sys/mpsc_packet.h&gt;\n#include &lt;zephyr/sys/cbprintf.h&gt;\n#include &lt;zephyr/sys/atomic.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n#include &lt;zephyr/sys/util.h&gt;\n#include &lt;string.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n\n#ifdef __GNUC__\n#ifndef alloca\n#define alloca __builtin_alloca\n#endif\n#else\n#include &lt;alloca.h&gt;\n#endif\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n#define LOG_MSG_DEBUG 0\n#define LOG_MSG_DBG(...) IF_ENABLED(LOG_MSG_DEBUG, (printk(__VA_ARGS__)))\n\n#ifdef CONFIG_LOG_TIMESTAMP_64BIT\ntypedef uint64_t log_timestamp_t;\n#else\ntypedef uint32_t log_timestamp_t;\n#endif\n\n/**\n * @brief Log message API\n * @defgroup log_msg Log message API\n * @ingroup logger\n * @{\n */\n\n#define Z_LOG_MSG_LOG 0\n\n#define Z_LOG_MSG_PACKAGE_BITS 11\n\n#define Z_LOG_MSG_MAX_PACKAGE BIT_MASK(Z_LOG_MSG_PACKAGE_BITS)\n\n#define LOG_MSG_GENERIC_HDR \\\n\tMPSC_PBUF_HDR;\\\n\tuint32_t type:1\n\nstruct log_msg_desc {\n\tLOG_MSG_GENERIC_HDR;\n\tuint32_t domain:3;\n\tuint32_t level:3;\n\tuint32_t package_len:Z_LOG_MSG_PACKAGE_BITS;\n\tuint32_t data_len:12;\n};\n\nunion log_msg_source {\n\tconst struct log_source_const_data *fixed;\n\tstruct log_source_dynamic_data *dynamic;\n\tvoid *raw;\n};\n\nstruct log_msg_hdr {\n\tstruct log_msg_desc desc;\n/* Attempting to keep best alignment. When address is 64 bit and timestamp 32\n * swap the order to have 16 byte header instead of 24 byte.\n */\n#if (INTPTR_MAX &gt; INT32_MAX) &amp;&amp; !defined(CONFIG_LOG_TIMESTAMP_64BIT)\n\tlog_timestamp_t timestamp;\n\tconst void *source;\n#else\n\tconst void *source;\n\tlog_timestamp_t timestamp;\n#endif\n#if defined(CONFIG_LOG_THREAD_ID_PREFIX)\n\tvoid *tid;\n#endif\n};\n/* Messages are aligned to alignment required by cbprintf package. */\n#define Z_LOG_MSG_ALIGNMENT CBPRINTF_PACKAGE_ALIGNMENT\n\n#define Z_LOG_MSG_PADDING \\\n\t((sizeof(struct log_msg_hdr) % Z_LOG_MSG_ALIGNMENT) &gt; 0 ? \\\n\t(Z_LOG_MSG_ALIGNMENT - (sizeof(struct log_msg_hdr) % Z_LOG_MSG_ALIGNMENT)) : \\\n\t\t0)\n\nstruct log_msg {\n\tstruct log_msg_hdr hdr;\n\t/* Adding padding to ensure that cbprintf package that follows is\n\t * properly aligned.\n\t */\n\tuint8_t padding[Z_LOG_MSG_PADDING];\n\tuint8_t data[];\n};\n\n/**\n * @cond INTERNAL_HIDDEN\n */\nBUILD_ASSERT(sizeof(struct log_msg) % Z_LOG_MSG_ALIGNMENT == 0,\n\t     &quot;Log msg size must aligned&quot;);\n/**\n * @endcond\n */\n\n\nstruct log_msg_generic_hdr {\n\tLOG_MSG_GENERIC_HDR;\n};\n\nunion log_msg_generic {\n\tunion mpsc_pbuf_generic buf;\n\tstruct log_msg_generic_hdr generic;\n\tstruct log_msg log;\n};\n\n/** @brief Method used for creating a log message.\n *\n * It is used for testing purposes to validate that expected mode was used.\n */\nenum z_log_msg_mode {\n\t/* Runtime mode is least efficient but supports all cases thus it is\n\t * treated as a fallback method when others cannot be used.\n\t */\n\tZ_LOG_MSG_MODE_RUNTIME,\n\t/* Mode creates statically a string package on stack and calls a\n\t * function for creating a message. It takes code size than\n\t * Z_LOG_MSG_MODE_ZERO_COPY but is a bit slower.\n\t */\n\tZ_LOG_MSG_MODE_FROM_STACK,\n\n\t/* Mode calculates size of the message and allocates it and writes\n\t * directly to the message space. It is the fastest method but requires\n\t * more code size.\n\t */\n\tZ_LOG_MSG_MODE_ZERO_COPY,\n\n\t/* Mode optimized for simple messages with 0 to 2 32 bit word arguments.*/\n\tZ_LOG_MSG_MODE_SIMPLE,\n};\n\n#define Z_LOG_MSG_DESC_INITIALIZER(_domain_id, _level, _plen, _dlen) \\\n{ \\\n\t.valid = 0, \\\n\t.busy = 0, \\\n\t.type = Z_LOG_MSG_LOG, \\\n\t.domain = (_domain_id), \\\n\t.level = (_level), \\\n\t.package_len = (_plen), \\\n\t.data_len = (_dlen), \\\n}\n\n#define Z_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt) \\\n\t(CBPRINTF_PACKAGE_FIRST_RO_STR_CNT(_cstr_cnt) | \\\n\t(IS_ENABLED(CONFIG_LOG_MSG_APPEND_RO_STRING_LOC) ? \\\n\t CBPRINTF_PACKAGE_ADD_STRING_IDXS : 0))\n\n#ifdef CONFIG_LOG_USE_VLA\n#define Z_LOG_MSG_ON_STACK_ALLOC(ptr, len) \\\n\tlong long _ll_buf[DIV_ROUND_UP(len, sizeof(long long))]; \\\n\tlong double _ld_buf[DIV_ROUND_UP(len, sizeof(long double))]; \\\n\t(ptr) = (sizeof(long double) == Z_LOG_MSG_ALIGNMENT) ? \\\n\t\t\t(struct log_msg *)_ld_buf : (struct log_msg *)_ll_buf; \\\n\tif (IS_ENABLED(CONFIG_LOG_TEST_CLEAR_MESSAGE_SPACE)) { \\\n\t\t/* During test fill with 0&#x27;s to simplify message comparison */ \\\n\t\tmemset((ptr), 0, (len)); \\\n\t}\n#else /* Z_LOG_MSG_USE_VLA */\n/* When VLA cannot be used we need to trick compiler a bit and create multiple\n * fixed size arrays and take the smallest one that will fit the message.\n * Compiler will remove unused arrays and stack usage will be kept similar\n * to vla case, rounded to the size of the used buffer.\n */\n#define Z_LOG_MSG_ON_STACK_ALLOC(ptr, len) \\\n\tlong long _ll_buf32[32 / sizeof(long long)]; \\\n\tlong long _ll_buf48[48 / sizeof(long long)]; \\\n\tlong long _ll_buf64[64 / sizeof(long long)]; \\\n\tlong long _ll_buf128[128 / sizeof(long long)]; \\\n\tlong long _ll_buf256[256 / sizeof(long long)]; \\\n\tlong double _ld_buf32[32 / sizeof(long double)]; \\\n\tlong double _ld_buf48[48 / sizeof(long double)]; \\\n\tlong double _ld_buf64[64 / sizeof(long double)]; \\\n\tlong double _ld_buf128[128 / sizeof(long double)]; \\\n\tlong double _ld_buf256[256 / sizeof(long double)]; \\\n\tif (sizeof(long double) == Z_LOG_MSG_ALIGNMENT) { \\\n\t\tptr = (len &gt; 128) ? (struct log_msg *)_ld_buf256 : \\\n\t\t\t((len &gt; 64) ? (struct log_msg *)_ld_buf128 : \\\n\t\t\t((len &gt; 48) ? (struct log_msg *)_ld_buf64 : \\\n\t\t\t((len &gt; 32) ? (struct log_msg *)_ld_buf48 : \\\n\t\t\t\t      (struct log_msg *)_ld_buf32)));\\\n\t} else { \\\n\t\tptr = (len &gt; 128) ? (struct log_msg *)_ll_buf256 : \\\n\t\t\t((len &gt; 64) ? (struct log_msg *)_ll_buf128 : \\\n\t\t\t((len &gt; 48) ? (struct log_msg *)_ll_buf64 : \\\n\t\t\t((len &gt; 32) ? (struct log_msg *)_ll_buf48 : \\\n\t\t\t\t      (struct log_msg *)_ll_buf32)));\\\n\t} \\\n\tif (IS_ENABLED(CONFIG_LOG_TEST_CLEAR_MESSAGE_SPACE)) { \\\n\t\t/* During test fill with 0&#x27;s to simplify message comparison */ \\\n\t\tmemset((ptr), 0, (len)); \\\n\t}\n#endif /* Z_LOG_MSG_USE_VLA */\n\n#define Z_LOG_MSG_ALIGN_OFFSET \\\n\toffsetof(struct log_msg, data)\n\n#define Z_LOG_MSG_LEN(pkg_len, data_len) \\\n\t(offsetof(struct log_msg, data) + (pkg_len) + (data_len))\n\n#define Z_LOG_MSG_ALIGNED_WLEN(pkg_len, data_len) \\\n\tDIV_ROUND_UP(ROUND_UP(Z_LOG_MSG_LEN(pkg_len, data_len), \\\n\t\t\t\t  Z_LOG_MSG_ALIGNMENT), \\\n\t\t\t sizeof(uint32_t))\n\n/*\n * With Zephyr SDK 0.14.2, aarch64-zephyr-elf-gcc (10.3.0) fails to ensure $sp\n * is below the active memory during message construction. As a result,\n * interrupts happening in the middle of that process can end up smashing active\n * data and causing a logging fault. Work around this by inserting a compiler\n * barrier after the allocation and before any use to make sure GCC moves the\n * stack pointer soon enough\n */\n\n#define Z_LOG_ARM64_VLA_PROTECT() compiler_barrier()\n\n#define _LOG_MSG_SIMPLE_XXXX0 1\n#define _LOG_MSG_SIMPLE_XXXX1 1\n#define _LOG_MSG_SIMPLE_XXXX2 1\n\n/* Determine if amount of arguments (less than 3) qualifies to  simple message. */\n#define LOG_MSG_SIMPLE_ARG_CNT_CHECK(...) \\\n\tCOND_CODE_1(UTIL_CAT(_LOG_MSG_SIMPLE_XXXX, NUM_VA_ARGS_LESS_1(__VA_ARGS__)), (1), (0))\n\n/* Set of marcos used to determine if arguments type allows simplified message creation mode. */\n#define LOG_MSG_SIMPLE_ARG_TYPE_CHECK_0(fmt) 1\n#define LOG_MSG_SIMPLE_ARG_TYPE_CHECK_1(fmt, arg) Z_CBPRINTF_IS_WORD_NUM(arg)\n#define LOG_MSG_SIMPLE_ARG_TYPE_CHECK_2(fmt, arg0, arg1) \\\n\tZ_CBPRINTF_IS_WORD_NUM(arg0) &amp;&amp; Z_CBPRINTF_IS_WORD_NUM(arg1)\n\n/** brief Determine if string arguments types allow to use simplified message creation mode.\n *\n * @param ... String with arguments.\n */\n#define LOG_MSG_SIMPLE_ARG_TYPE_CHECK(...) \\\n\tUTIL_CAT(LOG_MSG_SIMPLE_ARG_TYPE_CHECK_, NUM_VA_ARGS_LESS_1(__VA_ARGS__))(__VA_ARGS__)\n\n/** @brief Check if message can be handled using simplified method.\n *\n * Following conditions must be met:\n * - 32 bit platform\n * - Number of arguments from 0 to 2\n * - Type of an argument must be a numeric value that fits in 32 bit word.\n *\n * @param ... String with arguments.\n *\n * @retval 1 if message qualifies.\n * @retval 0 if message does not qualify.\n */\n#define LOG_MSG_SIMPLE_CHECK(...) \\\n\tCOND_CODE_1(CONFIG_64BIT, (0), (\\\n\t\tCOND_CODE_1(LOG_MSG_SIMPLE_ARG_CNT_CHECK(__VA_ARGS__), ( \\\n\t\t\t\tLOG_MSG_SIMPLE_ARG_TYPE_CHECK(__VA_ARGS__)), (0))))\n\n/* Helper macro for handing log with one argument. Macro casts the first argument to uint32_t. */\n#define Z_LOG_MSG_SIMPLE_CREATE_1(_source, _level, ...) \\\n\tz_log_msg_simple_create_1(_source, _level, GET_ARG_N(1, __VA_ARGS__), \\\n\t\t\t(uint32_t)(uintptr_t)GET_ARG_N(2, __VA_ARGS__))\n\n/* Helper macro for handing log with two arguments. Macro casts arguments to uint32_t.\n */\n#define Z_LOG_MSG_SIMPLE_CREATE_2(_source, _level, ...) \\\n\tz_log_msg_simple_create_2(_source, _level, GET_ARG_N(1, __VA_ARGS__), \\\n\t\t\t(uint32_t)(uintptr_t)GET_ARG_N(2, __VA_ARGS__), \\\n\t\t\t(uint32_t)(uintptr_t)GET_ARG_N(3, __VA_ARGS__))\n\n/* Call specific function based on the number of arguments.\n * Since up 2 to arguments are supported COND_CODE_0 and COND_CODE_1 can be used to\n * handle all cases (0, 1 and 2 arguments). When tracing is enable then for each\n * function a macro is create. The difference between function and macro is that\n * macro is applied to any input arguments so we need to make sure that it is\n * always called with proper number of arguments. For that it is wrapped around\n * into another macro and dummy arguments to cover for cases when there is less\n * arguments in a log call.\n */\n#define Z_LOG_MSG_SIMPLE_FUNC2(arg_cnt, _source, _level, ...) \\\n\tCOND_CODE_0(arg_cnt, \\\n\t\t\t(z_log_msg_simple_create_0(_source, _level, GET_ARG_N(1, __VA_ARGS__))), \\\n\t\t\t(COND_CODE_1(arg_cnt, ( \\\n\t\t\t    Z_LOG_MSG_SIMPLE_CREATE_1(_source, _level, __VA_ARGS__, dummy) \\\n\t\t\t    ), ( \\\n\t\t\t    Z_LOG_MSG_SIMPLE_CREATE_2(_source, _level, __VA_ARGS__, dummy, dummy) \\\n\t\t\t    ) \\\n\t\t\t)))\n\n/** @brief Call specific function to create a log message.\n *\n * Macro picks matching function (based on number of arguments) and calls it.\n * String arguments are casted to uint32_t.\n *\n * @param _source\tSource.\n * @param _level\tSeverity level.\n * @param ...\t\tString with arguments.\n */\n#define LOG_MSG_SIMPLE_FUNC(_source, _level, ...) \\\n\tZ_LOG_MSG_SIMPLE_FUNC2(NUM_VA_ARGS_LESS_1(__VA_ARGS__), _source, _level, __VA_ARGS__)\n\n/** @brief Create log message using simplified method.\n *\n * Macro is gated by the argument count check to run @ref LOG_MSG_SIMPLE_FUNC only\n * on entries with 2 or less arguments.\n *\n * @param _domain_id\tDomain ID.\n * @param _source\tPointer to the source structure.\n * @param _level\tSeverity level.\n * @param ...\t\tString with arguments.\n */\n#define Z_LOG_MSG_SIMPLE_ARGS_CREATE(_domain_id, _source, _level, ...) \\\n\tIF_ENABLED(LOG_MSG_SIMPLE_ARG_CNT_CHECK(__VA_ARGS__), (\\\n\t\tLOG_MSG_SIMPLE_FUNC(_source, _level, __VA_ARGS__); \\\n\t))\n\n#define Z_LOG_MSG_STACK_CREATE(_cstr_cnt, _domain_id, _source, _level, _data, _dlen, ...) \\\ndo { \\\n\tint _plen; \\\n\tuint32_t _options = Z_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt) | \\\n\t\t\t  CBPRINTF_PACKAGE_ADD_RW_STR_POS; \\\n\tif (GET_ARG_N(1, __VA_ARGS__) == NULL) { \\\n\t\t_plen = 0; \\\n\t} else { \\\n\t\tCBPRINTF_STATIC_PACKAGE(NULL, 0, _plen, Z_LOG_MSG_ALIGN_OFFSET, _options, \\\n\t\t\t\t\t__VA_ARGS__); \\\n\t} \\\n\tTOOLCHAIN_DISABLE_WARNING(TOOLCHAIN_WARNING_SHADOW) \\\n\tstruct log_msg *_msg; \\\n\tTOOLCHAIN_ENABLE_WARNING(TOOLCHAIN_WARNING_SHADOW) \\\n\tZ_LOG_MSG_ON_STACK_ALLOC(_msg, Z_LOG_MSG_LEN(_plen, 0)); \\\n\tZ_LOG_ARM64_VLA_PROTECT(); \\\n\tif (_plen != 0) { \\\n\t\tCBPRINTF_STATIC_PACKAGE(_msg-&gt;data, _plen, \\\n\t\t\t\t\t_plen, Z_LOG_MSG_ALIGN_OFFSET, _options, \\\n\t\t\t\t\t__VA_ARGS__);\\\n\t} \\\n\tstruct log_msg_desc _desc = \\\n\t\tZ_LOG_MSG_DESC_INITIALIZER(_domain_id, _level, \\\n\t\t\t\t\t   (uint32_t)_plen, _dlen); \\\n\tLOG_MSG_DBG(&quot;creating message on stack: package len: %d, data len: %d\\n&quot;, \\\n\t\t\t_plen, (int)(_dlen)); \\\n\tz_log_msg_static_create((void *)(_source), _desc, _msg-&gt;data, (_data)); \\\n} while (false)\n\n#ifdef CONFIG_LOG_SPEED\n#define Z_LOG_MSG_SIMPLE_CREATE(_cstr_cnt, _domain_id, _source, _level, ...) do { \\\n\tint _plen; \\\n\tCBPRINTF_STATIC_PACKAGE(NULL, 0, _plen, Z_LOG_MSG_ALIGN_OFFSET, \\\n\t\t\t\tZ_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt), \\\n\t\t\t\t__VA_ARGS__); \\\n\tsize_t _msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(_plen, 0); \\\n\tstruct log_msg *_msg = z_log_msg_alloc(_msg_wlen); \\\n\tstruct log_msg_desc _desc = \\\n\t\tZ_LOG_MSG_DESC_INITIALIZER(_domain_id, _level, (uint32_t)_plen, 0); \\\n\tLOG_MSG_DBG(&quot;creating message zero copy: package len: %d, msg: %p\\n&quot;, \\\n\t\t\t_plen, _msg); \\\n\tif (_msg) { \\\n\t\tCBPRINTF_STATIC_PACKAGE(_msg-&gt;data, _plen, _plen, \\\n\t\t\t\t\tZ_LOG_MSG_ALIGN_OFFSET, \\\n\t\t\t\t\tZ_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt), \\\n\t\t\t\t\t__VA_ARGS__); \\\n\t} \\\n\tz_log_msg_finalize(_msg, (void *)_source, _desc, NULL); \\\n} while (false)\n#else\n/* Alternative empty macro created to speed up compilation when LOG_SPEED is\n * disabled (default).\n */\n#define Z_LOG_MSG_SIMPLE_CREATE(...)\n#endif\n\n/* Macro handles case when local variable with log message string is created. It\n * replaces original string literal with that variable.\n */\n#define Z_LOG_FMT_ARGS_2(_name, ...) \\\n\tCOND_CODE_1(CONFIG_LOG_FMT_SECTION, \\\n\t\t(COND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\\n\t\t   (_name), (_name, GET_ARGS_LESS_N(1, __VA_ARGS__)))), \\\n\t\t(__VA_ARGS__))\n\n/** @brief Wrapper for log message string with arguments.\n *\n * Wrapper is replacing first argument with a variable from a dedicated memory\n * section if option is enabled. Macro handles the case when there is no\n * log message provided.\n *\n * @param _name Name of the variable with log message string. It is optionally used.\n * @param ... Optional log message with arguments (may be empty).\n */\n#define Z_LOG_FMT_ARGS(_name, ...) \\\n\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\\n\t\t(NULL), \\\n\t\t(Z_LOG_FMT_ARGS_2(_name, ##__VA_ARGS__)))\n\n#if defined(CONFIG_LOG_USE_TAGGED_ARGUMENTS)\n\n#define Z_LOG_FMT_TAGGED_ARGS_2(_name, ...) \\\n\tCOND_CODE_1(CONFIG_LOG_FMT_SECTION, \\\n\t\t    (_name, Z_CBPRINTF_TAGGED_ARGS(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\\n\t\t\t\t\t\t   GET_ARGS_LESS_N(1, __VA_ARGS__))), \\\n\t\t    (GET_ARG_N(1, __VA_ARGS__), \\\n\t\t     Z_CBPRINTF_TAGGED_ARGS(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\\n\t\t\t\t\t    GET_ARGS_LESS_N(1, __VA_ARGS__))))\n\n/** @brief Wrapper for log message string with tagged arguments.\n *\n * Wrapper is replacing first argument with a variable from a dedicated memory\n * section if option is enabled. Macro handles the case when there is no\n * log message provided. Each subsequent arguments are tagged by preceding\n * each argument with its type value.\n *\n * @param _name Name of the variable with log message string. It is optionally used.\n * @param ... Optional log message with arguments (may be empty).\n */\n#define Z_LOG_FMT_TAGGED_ARGS(_name, ...) \\\n\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\\n\t\t(Z_CBPRINTF_TAGGED_ARGS(0)), \\\n\t\t(Z_LOG_FMT_TAGGED_ARGS_2(_name, ##__VA_ARGS__)))\n\n#define Z_LOG_FMT_RUNTIME_ARGS(...) \\\n\tZ_LOG_FMT_TAGGED_ARGS(__VA_ARGS__)\n\n#else\n\n#define Z_LOG_FMT_RUNTIME_ARGS(...) \\\n\tZ_LOG_FMT_ARGS(__VA_ARGS__)\n\n#endif /* CONFIG_LOG_USE_TAGGED_ARGUMENTS */\n\n/* Macro handles case when there is no string provided, in that case variable\n * is not created.\n */\n#define Z_LOG_MSG_STR_VAR_IN_SECTION(_name, ...) \\\n\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\\n\t\t    (/* No args provided, no variable */), \\\n\t\t    (static const char _name[] \\\n\t\t     __in_section(_log_strings, static, _CONCAT(_name, _)) __used __noasan = \\\n\t\t\tGET_ARG_N(1, __VA_ARGS__);))\n\n/** @brief Create variable in the dedicated memory section (if enabled).\n *\n * Variable is initialized with a format string from the log message.\n *\n * @param _name Variable name.\n * @param ... Optional log message with arguments (may be empty).\n */\n#define Z_LOG_MSG_STR_VAR(_name, ...) \\\n\tIF_ENABLED(CONFIG_LOG_FMT_SECTION, \\\n\t\t   (Z_LOG_MSG_STR_VAR_IN_SECTION(_name, ##__VA_ARGS__)))\n\n/** @brief Create log message and write it into the logger buffer.\n *\n * Macro handles creation of log message which includes storing log message\n * description, timestamp, arguments, copying string arguments into message and\n * copying user data into the message space. There are 3 modes of message\n * creation:\n * - at compile time message size is determined, message is allocated and\n *   content is written directly to the message. It is the fastest but cannot\n *   be used in user mode. Message size cannot be determined at compile time if\n *   it contains data or string arguments which are string pointers.\n * - at compile time message size is determined, string package is created on\n *   stack, message is created in function call. String package can only be\n *   created on stack if it does not contain unexpected pointers to strings.\n * - string package is created at runtime. This mode has no limitations but\n *   it is significantly slower.\n *\n * @param _try_0cpy If positive then, if possible, message content is written\n * directly to message. If 0 then, if possible, string package is created on\n * the stack and message is created in the function call.\n *\n * @param _mode Used for testing. It is set according to message creation mode\n *\t\tused.\n *\n * @param _cstr_cnt Number of constant strings present in the string. It is\n * used to help detect messages which must be runtime processed, compared to\n * message which can be prebuilt at compile time.\n *\n * @param _domain_id Domain ID.\n *\n * @param _source Pointer to the constant descriptor of the log message source.\n *\n * @param _level Log message level.\n *\n * @param _data Pointer to the data. Can be null.\n *\n * @param _dlen Number of data bytes. 0 if data is not provided.\n *\n * @param ...  Optional string with arguments (fmt, ...). It may be empty.\n */\n#if defined(CONFIG_LOG_ALWAYS_RUNTIME) || !defined(CONFIG_LOG)\n#define Z_LOG_MSG_CREATE2(_try_0cpy, _mode,  _cstr_cnt, _domain_id, _source,\\\n\t\t\t  _level, _data, _dlen, ...) \\\ndo {\\\n\tZ_LOG_MSG_STR_VAR(_fmt, ##__VA_ARGS__) \\\n\tz_log_msg_runtime_create((_domain_id), (void *)(_source), \\\n\t\t\t\t  (_level), (uint8_t *)(_data), (_dlen),\\\n\t\t\t\t  Z_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt) | \\\n\t\t\t\t  (IS_ENABLED(CONFIG_LOG_USE_TAGGED_ARGUMENTS) ? \\\n\t\t\t\t   CBPRINTF_PACKAGE_ARGS_ARE_TAGGED : 0), \\\n\t\t\t\t  Z_LOG_FMT_RUNTIME_ARGS(_fmt, ##__VA_ARGS__));\\\n\t(_mode) = Z_LOG_MSG_MODE_RUNTIME; \\\n} while (false)\n#else /* CONFIG_LOG_ALWAYS_RUNTIME || !CONFIG_LOG */\n#define Z_LOG_MSG_CREATE3(_try_0cpy, _mode,  _cstr_cnt, _domain_id, _source,\\\n\t\t\t  _level, _data, _dlen, ...) \\\ndo { \\\n\tZ_LOG_MSG_STR_VAR(_fmt, ##__VA_ARGS__); \\\n\tbool has_rw_str = CBPRINTF_MUST_RUNTIME_PACKAGE( \\\n\t\t\t\t\tZ_LOG_MSG_CBPRINTF_FLAGS(_cstr_cnt), \\\n\t\t\t\t\t__VA_ARGS__); \\\n\tif (IS_ENABLED(CONFIG_LOG_SPEED) &amp;&amp; (_try_0cpy) &amp;&amp; ((_dlen) == 0) &amp;&amp; !has_rw_str) {\\\n\t\tLOG_MSG_DBG(&quot;create zero-copy message\\n&quot;);\\\n\t\tZ_LOG_MSG_SIMPLE_CREATE(_cstr_cnt, _domain_id, _source, \\\n\t\t\t\t\t_level, Z_LOG_FMT_ARGS(_fmt, ##__VA_ARGS__)); \\\n\t\t(_mode) = Z_LOG_MSG_MODE_ZERO_COPY; \\\n\t} else { \\\n\t\tIF_ENABLED(UTIL_AND(IS_ENABLED(CONFIG_LOG_SIMPLE_MSG_OPTIMIZE), \\\n\t\t\t\t    UTIL_AND(UTIL_NOT(_domain_id), UTIL_NOT(_cstr_cnt))), \\\n\t\t\t( \\\n\t\t\tbool can_simple = LOG_MSG_SIMPLE_CHECK(__VA_ARGS__); \\\n\t\t\tif (can_simple &amp;&amp; ((_dlen) == 0) &amp;&amp; !k_is_user_context()) { \\\n\t\t\t\tLOG_MSG_DBG(&quot;create fast message\\n&quot;);\\\n\t\t\t\tZ_LOG_MSG_SIMPLE_ARGS_CREATE(_domain_id, _source, _level, \\\n\t\t\t\t\t\t     Z_LOG_FMT_ARGS(_fmt, ##__VA_ARGS__)); \\\n\t\t\t\t_mode = Z_LOG_MSG_MODE_SIMPLE; \\\n\t\t\t\tbreak; \\\n\t\t\t} \\\n\t\t\t) \\\n\t\t) \\\n\t\tLOG_MSG_DBG(&quot;create on stack message\\n&quot;);\\\n\t\tZ_LOG_MSG_STACK_CREATE(_cstr_cnt, _domain_id, _source, _level, _data, \\\n\t\t\t\t\t_dlen, Z_LOG_FMT_ARGS(_fmt, ##__VA_ARGS__)); \\\n\t\t(_mode) = Z_LOG_MSG_MODE_FROM_STACK; \\\n\t} \\\n\t(void)(_mode); \\\n} while (false)\n\n#if defined(__cplusplus)\n#define Z_AUTO_TYPE auto\n#else\n#define Z_AUTO_TYPE __auto_type\n#endif\n\n/* Macro for getting name of a local variable with the exception of the first argument\n * which is a formatted string in log message.\n */\n#define Z_LOG_LOCAL_ARG_NAME(idx, arg) COND_CODE_0(idx, (arg), (_v##idx))\n\n/* Create local variable from input variable (expect for the first (fmt) argument). */\n#define Z_LOG_LOCAL_ARG_CREATE(idx, arg) \\\n\tCOND_CODE_0(idx, (), (Z_AUTO_TYPE Z_LOG_LOCAL_ARG_NAME(idx, arg) = Z_ARGIFY(arg)))\n\n/* First level of processing creates stack variables to be passed for further processing.\n * This is done to prevent multiple evaluations of input arguments (in case argument\n * evaluation has side effects, e.g. it is a non-pure function call).\n */\n#define Z_LOG_MSG_CREATE2(_try_0cpy, _mode, _cstr_cnt,  _domain_id, _source, \\\n\t\t\t   _level, _data, _dlen, ...) \\\ndo { \\\n\tFOR_EACH_IDX(Z_LOG_LOCAL_ARG_CREATE, (;), __VA_ARGS__); \\\n\tZ_LOG_MSG_CREATE3(_try_0cpy, _mode,  _cstr_cnt, _domain_id, _source,\\\n\t\t\t   _level, _data, _dlen, \\\n\t\t\t   FOR_EACH_IDX(Z_LOG_LOCAL_ARG_NAME, (,), __VA_ARGS__)); \\\n} while (false)\n#endif /* CONFIG_LOG_ALWAYS_RUNTIME || !CONFIG_LOG */\n\n\n#define Z_LOG_MSG_CREATE(_try_0cpy, _mode,  _domain_id, _source,\\\n\t\t\t  _level, _data, _dlen, ...) \\\n\tZ_LOG_MSG_CREATE2(_try_0cpy, _mode, UTIL_CAT(Z_LOG_FUNC_PREFIX_, _level), \\\n\t\t\t   _domain_id, _source, _level, _data, _dlen, \\\n\t\t\t   Z_LOG_STR(_level, __VA_ARGS__))\n\n/** @brief Allocate log message.\n *\n * @param wlen Length in 32 bit words.\n *\n * @return allocated space or null if cannot be allocated.\n */\nstruct log_msg *z_log_msg_alloc(uint32_t wlen);\n\n/** @brief Finalize message.\n *\n * Finalization includes setting source, copying data and timestamp in the\n * message followed by committing the message.\n *\n * @param msg Message.\n *\n * @param source Address of the source descriptor.\n *\n * @param desc Message descriptor.\n *\n * @param data Data.\n */\nvoid z_log_msg_finalize(struct log_msg *msg, const void *source,\n\t\t\t const struct log_msg_desc desc, const void *data);\n\n/** @brief Create log message using simplified method for string with no arguments.\n *\n * @param source Pointer to the source structure.\n * @param level  Severity level.\n * @param fmt    String pointer.\n */\n__syscall void z_log_msg_simple_create_0(const void *source, uint32_t level,\n\t\t\t\t\t const char *fmt);\n\n/** @brief Create log message using simplified method for string with a one argument.\n *\n * @param source Pointer to the source structure.\n * @param level  Severity level.\n * @param fmt    String pointer.\n * @param arg    String argument.\n */\n__syscall void z_log_msg_simple_create_1(const void *source, uint32_t level,\n\t\t\t\t\t const char *fmt, uint32_t arg);\n\n/** @brief Create log message using simplified method for string with two arguments.\n *\n * @param source Pointer to the source structure.\n * @param level  Severity level.\n * @param fmt    String pointer.\n * @param arg0   String argument.\n * @param arg1   String argument.\n */\n__syscall void z_log_msg_simple_create_2(const void *source, uint32_t level,\n\t\t\t\t\t const char *fmt, uint32_t arg0, uint32_t arg1);\n\n/** @brief Create a logging message from message details and string package.\n *\n * @param source Source.\n *\n * @param desc Message descriptor.\n *\n * @param package Package.\n *\n * @param data Data.\n */\n__syscall void z_log_msg_static_create(const void *source,\n\t\t\t\t\tconst struct log_msg_desc desc,\n\t\t\t\t\tuint8_t *package, const void *data);\n\n/** @brief Create message at runtime.\n *\n * Function allows to build any log message based on input data. Processing\n * time is significantly higher than statically message creating.\n *\n * @param domain_id Domain ID.\n *\n * @param source Source.\n *\n * @param level Log level.\n *\n * @param data Data.\n *\n * @param dlen Data length.\n *\n * @param package_flags Package flags.\n *\n * @param fmt String.\n *\n * @param ap Variable list of string arguments.\n */\nvoid z_log_msg_runtime_vcreate(uint8_t domain_id, const void *source,\n\t\t\t\tuint8_t level, const void *data,\n\t\t\t\tsize_t dlen, uint32_t package_flags,\n\t\t\t\tconst char *fmt,\n\t\t\t\tva_list ap);\n\n/** @brief Create message at runtime.\n *\n * Function allows to build any log message based on input data. Processing\n * time is significantly higher than statically message creating.\n *\n * @param domain_id Domain ID.\n *\n * @param source Source.\n *\n * @param level Log level.\n *\n * @param data Data.\n *\n * @param dlen Data length.\n *\n * @param package_flags Package flags.\n *\n * @param fmt String.\n *\n * @param ... String arguments.\n */\nstatic inline void z_log_msg_runtime_create(uint8_t domain_id,\n\t\t\t\t\t     const void *source,\n\t\t\t\t\t     uint8_t level, const void *data,\n\t\t\t\t\t     size_t dlen, uint32_t package_flags,\n\t\t\t\t\t     const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tz_log_msg_runtime_vcreate(domain_id, source, level,\n\t\t\t\t   data, dlen, package_flags, fmt, ap);\n\tva_end(ap);\n}\n\nstatic inline bool z_log_item_is_msg(const union log_msg_generic *msg)\n{\n\treturn msg-&gt;generic.type == Z_LOG_MSG_LOG;\n}\n\n/** @brief Get total length (in 32 bit words) of a log message.\n *\n * @param desc Log message descriptor.\n *\n * @return Length.\n */\nstatic inline uint32_t log_msg_get_total_wlen(const struct log_msg_desc desc)\n{\n\treturn Z_LOG_MSG_ALIGNED_WLEN(desc.package_len, desc.data_len);\n}\n\n/** @brief Get length of the log item.\n *\n * @param item Item.\n *\n * @return Length in 32 bit words.\n */\nstatic inline uint32_t log_msg_generic_get_wlen(const union mpsc_pbuf_generic *item)\n{\n\tconst union log_msg_generic *generic_msg = (const union log_msg_generic *)item;\n\n\tif (z_log_item_is_msg(generic_msg)) {\n\t\tconst struct log_msg *msg = (const struct log_msg *)generic_msg;\n\n\t\treturn log_msg_get_total_wlen(msg-&gt;hdr.desc);\n\t}\n\n\treturn 0;\n}\n\n/** @brief Get log message domain ID.\n *\n * @param msg Log message.\n *\n * @return Domain ID\n */\nstatic inline uint8_t log_msg_get_domain(struct log_msg *msg)\n{\n\treturn msg-&gt;hdr.desc.domain;\n}\n\n/** @brief Get log message level.\n *\n * @param msg Log message.\n *\n * @return Log level.\n */\nstatic inline uint8_t log_msg_get_level(struct log_msg *msg)\n{\n\treturn msg-&gt;hdr.desc.level;\n}\n\n/** @brief Get message source data.\n *\n * @param msg Log message.\n *\n * @return Pointer to the source data.\n */\nstatic inline const void *log_msg_get_source(struct log_msg *msg)\n{\n\treturn msg-&gt;hdr.source;\n}\n\n/** @brief Get log message source ID.\n *\n * @param msg Log message.\n *\n * @return Source ID, or -1 if not available.\n */\nint16_t log_msg_get_source_id(struct log_msg *msg);\n\n/** @brief Get timestamp.\n *\n * @param msg Log message.\n *\n * @return Timestamp.\n */\nstatic inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)\n{\n\treturn msg-&gt;hdr.timestamp;\n}\n\n/** @brief Get Thread ID.\n *\n * @param msg Log message.\n *\n * @return Thread ID.\n */\nstatic inline void *log_msg_get_tid(struct log_msg *msg)\n{\n#if defined(CONFIG_LOG_THREAD_ID_PREFIX)\n\treturn msg-&gt;hdr.tid;\n#else\n\tARG_UNUSED(msg);\n\treturn NULL;\n#endif\n}\n\n/** @brief Get data buffer.\n *\n * @param msg log message.\n *\n * @param len location where data length is written.\n *\n * @return pointer to the data buffer.\n */\nstatic inline uint8_t *log_msg_get_data(struct log_msg *msg, size_t *len)\n{\n\t*len = msg-&gt;hdr.desc.data_len;\n\n\treturn msg-&gt;data + msg-&gt;hdr.desc.package_len;\n}\n\n/** @brief Get string package.\n *\n * @param msg log message.\n *\n * @param len location where string package length is written.\n *\n * @return pointer to the package.\n */\nstatic inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)\n{\n\t*len = msg-&gt;hdr.desc.package_len;\n\n\treturn msg-&gt;data;\n}\n\n/**\n * @}\n */\n\n#include &lt;zephyr/syscalls/log_msg.h&gt;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZEPHYR_INCLUDE_LOGGING_LOG_MSG_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h", "content": "/*\n * Copyright (c) 2015, Wind River Systems, Inc.\n * Copyright (c) 2017, Oticon A/S\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_ARCH_COMMON_FFS_H_\n#define ZEPHYR_INCLUDE_ARCH_COMMON_FFS_H_\n\n#ifndef _ASMLANGUAGE\n\n#include &lt;zephyr/types.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n *\n * @brief find most significant bit set in a 32-bit word\n *\n * This routine finds the first bit set starting from the most significant bit\n * in the argument passed in and returns the index of that bit.  Bits are\n * numbered starting at 1 from the least significant bit.  A return value of\n * zero indicates that the value passed is zero.\n *\n * @return most significant bit set, 0 if @a op is 0\n */\n\nstatic ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)\n{\n\tif (op == 0) {\n\t\treturn 0;\n\t}\n\n\treturn 32 - __builtin_clz(op);\n}\n\n\n/**\n *\n * @brief find least significant bit set in a 32-bit word\n *\n * This routine finds the first bit set starting from the least significant bit\n * in the argument passed in and returns the index of that bit.  Bits are\n * numbered starting at 1 from the least significant bit.  A return value of\n * zero indicates that the value passed is zero.\n *\n * @return least significant bit set, 0 if @a op is 0\n */\n\nstatic ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)\n{\n#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS\n\treturn __builtin_ffs(op);\n\n#else\n\t/*\n\t * Toolchain does not have __builtin_ffs(). Leverage find_lsb_set()\n\t * by first clearing all but the lowest set bit.\n\t */\n\n\top = op ^ (op &amp; (op - 1));\n\n\treturn find_msb_set(op);\n#endif /* CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS */\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _ASMLANGUAGE */\n\n#endif /* ZEPHYR_INCLUDE_ARCH_COMMON_FFS_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h", "content": "/*\n * Copyright (c) 2020, Wind River Systems, Inc.\n * Copyright (c) 2017, Oticon A/S\n * Copyright (c) 2020, Synopsys\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* Memory bits manipulation functions in non-arch-specific C code */\n\n#ifndef ZEPHYR_INCLUDE_ARCH_COMMON_SYS_BITOPS_H_\n#define ZEPHYR_INCLUDE_ARCH_COMMON_SYS_BITOPS_H_\n\n#ifndef _ASMLANGUAGE\n\n#include &lt;zephyr/toolchain.h&gt;\n#include &lt;zephyr/types.h&gt;\n#include &lt;zephyr/sys/sys_io.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstatic ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)\n{\n\tuint32_t temp = *(volatile uint32_t *)addr;\n\n\t*(volatile uint32_t *)addr = temp | (1 &lt;&lt; bit);\n}\n\nstatic ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)\n{\n\tuint32_t temp = *(volatile uint32_t *)addr;\n\n\t*(volatile uint32_t *)addr = temp &amp; ~(1 &lt;&lt; bit);\n}\n\nstatic ALWAYS_INLINE int sys_test_bit(mem_addr_t addr, unsigned int bit)\n{\n\tuint32_t temp = *(volatile uint32_t *)addr;\n\n\treturn temp &amp; (1 &lt;&lt; bit);\n}\n\nstatic ALWAYS_INLINE void sys_set_bits(mem_addr_t addr, unsigned int mask)\n{\n\tuint32_t temp = *(volatile uint32_t *)addr;\n\n\t*(volatile uint32_t *)addr = temp | mask;\n}\n\nstatic ALWAYS_INLINE void sys_clear_bits(mem_addr_t addr, unsigned int mask)\n{\n\tuint32_t temp = *(volatile uint32_t *)addr;\n\n\t*(volatile uint32_t *)addr = temp &amp; ~mask;\n}\n\nstatic ALWAYS_INLINE\n\tvoid sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)\n{\n\t/* Doing memory offsets in terms of 32-bit values to prevent\n\t * alignment issues\n\t */\n\tsys_set_bit(addr + ((bit &gt;&gt; 5) &lt;&lt; 2), bit &amp; 0x1F);\n}\n\nstatic ALWAYS_INLINE\n\tvoid sys_bitfield_clear_bit(mem_addr_t addr, unsigned int bit)\n{\n\tsys_clear_bit(addr + ((bit &gt;&gt; 5) &lt;&lt; 2), bit &amp; 0x1F);\n}\n\nstatic ALWAYS_INLINE\n\tint sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)\n{\n\treturn sys_test_bit(addr + ((bit &gt;&gt; 5) &lt;&lt; 2), bit &amp; 0x1F);\n}\n\nstatic ALWAYS_INLINE\n\tint sys_test_and_set_bit(mem_addr_t addr, unsigned int bit)\n{\n\tint ret;\n\n\tret = sys_test_bit(addr, bit);\n\tsys_set_bit(addr, bit);\n\n\treturn ret;\n}\n\nstatic ALWAYS_INLINE\n\tint sys_test_and_clear_bit(mem_addr_t addr, unsigned int bit)\n{\n\tint ret;\n\n\tret = sys_test_bit(addr, bit);\n\tsys_clear_bit(addr, bit);\n\n\treturn ret;\n}\n\nstatic ALWAYS_INLINE\n\tint sys_bitfield_test_and_set_bit(mem_addr_t addr, unsigned int bit)\n{\n\tint ret;\n\n\tret = sys_bitfield_test_bit(addr, bit);\n\tsys_bitfield_set_bit(addr, bit);\n\n\treturn ret;\n}\n\nstatic ALWAYS_INLINE\n\tint sys_bitfield_test_and_clear_bit(mem_addr_t addr, unsigned int bit)\n{\n\tint ret;\n\n\tret = sys_bitfield_test_bit(addr, bit);\n\tsys_bitfield_clear_bit(addr, bit);\n\n\treturn ret;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _ASMLANGUAGE */\n\n#endif /* ZEPHYR_INCLUDE_ARCH_COMMON_SYS_BITOPS_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h", "content": "/*\n * Copyright (c) 2015 Intel Corporation.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_DEVICE_H_\n#define ZEPHYR_INCLUDE_DEVICE_H_\n\n#include &lt;stdint.h&gt;\n\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/init.h&gt;\n#include &lt;zephyr/linker/sections.h&gt;\n#include &lt;zephyr/pm/state.h&gt;\n#include &lt;zephyr/sys/device_mmio.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n#include &lt;zephyr/sys/util.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n\n#ifdef CONFIG_LLEXT\n#include &lt;zephyr/llext/symbol.h&gt;\n#endif\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @brief Device Model\n * @defgroup device_model Device Model\n * @since 1.0\n * @version 1.1.0\n * @{\n */\n\n/** @cond INTERNAL_HIDDEN */\n\n/**\n * @brief Flag value used in lists of device dependencies to separate distinct\n * groups.\n */\n#define Z_DEVICE_DEPS_SEP INT16_MIN\n\n/**\n * @brief Flag value used in lists of device dependencies to indicate the end of\n * the list.\n */\n#define Z_DEVICE_DEPS_ENDS INT16_MAX\n\n/** @brief Determine if a DT node is mutable */\n#define Z_DEVICE_IS_MUTABLE(node_id)                                                               \\\n\tCOND_CODE_1(IS_ENABLED(CONFIG_DEVICE_MUTABLE), (DT_PROP(node_id, zephyr_mutable)), (0))\n\n/** @endcond */\n\n/**\n * @brief Type used to represent a &quot;handle&quot; for a device.\n *\n * Every @ref device has an associated handle. You can get a pointer to a\n * @ref device from its handle and vice versa, but the handle uses less space\n * than a pointer. The device.h API mainly uses handles to store lists of\n * multiple devices in a compact way.\n *\n * The extreme values and zero have special significance. Negative values\n * identify functionality that does not correspond to a Zephyr device, such as\n * the system clock or a SYS_INIT() function.\n *\n * @see device_handle_get()\n * @see device_from_handle()\n */\ntypedef int16_t device_handle_t;\n\n/** @brief Flag value used to identify an unknown device. */\n#define DEVICE_HANDLE_NULL 0\n\n/**\n * @brief Expands to the name of a global device object.\n *\n * Return the full name of a device object symbol created by DEVICE_DEFINE(),\n * using the `dev_id` provided to DEVICE_DEFINE(). This is the name of the\n * global variable storing the device structure, not a pointer to the string in\n * the @ref device.name field.\n *\n * It is meant to be used for declaring extern symbols pointing to device\n * objects before using the DEVICE_GET macro to get the device object.\n *\n * This macro is normally only useful within device driver source code. In other\n * situations, you are probably looking for device_get_binding().\n *\n * @param dev_id Device identifier.\n *\n * @return The full name of the device object defined by device definition\n * macros.\n */\n#define DEVICE_NAME_GET(dev_id) _CONCAT(__device_, dev_id)\n\n/* This macro synthesizes a unique dev_id from a devicetree node by using\n * the node&#x27;s dependency ordinal.\n *\n * The ordinal used in this name can be mapped to the path by\n * examining zephyr/include/generated/zephyr/devicetree_generated.h.\n */\n#define Z_DEVICE_DT_DEP_ORD(node_id) _CONCAT(dts_ord_, DT_DEP_ORD(node_id))\n\n/* Same as above, but uses the hash of the node path instead of the ordinal.\n *\n * The hash used in this name can be mapped to the path by\n * examining zephyr/include/generated/zephyr/devicetree_generated.h.\n */\n#define Z_DEVICE_DT_HASH(node_id) _CONCAT(dts_, DT_NODE_HASH(node_id))\n\n/* By default, device identifiers are obtained using the dependency ordinal.\n * When LLEXT_EXPORT_DEV_IDS_BY_HASH is defined, the main Zephyr binary exports\n * DT identifiers via EXPORT_SYMBOL_NAMED as hashed versions of their paths.\n * When matching extensions are built, that is what they need to look for.\n *\n * The ordinal or hash used in this name can be mapped to the path by\n * examining zephyr/include/generated/zephyr/devicetree_generated.h.\n */\n#if defined(LL_EXTENSION_BUILD) &amp;&amp; defined(CONFIG_LLEXT_EXPORT_DEV_IDS_BY_HASH)\n#define Z_DEVICE_DT_DEV_ID(node_id) Z_DEVICE_DT_HASH(node_id)\n#else\n#define Z_DEVICE_DT_DEV_ID(node_id) Z_DEVICE_DT_DEP_ORD(node_id)\n#endif\n\n#if defined(CONFIG_LLEXT_EXPORT_DEV_IDS_BY_HASH)\n/* Export device identifiers by hash */\n#define Z_DEVICE_EXPORT(node_id)\t\t\t\t\t       \\\n\tEXPORT_SYMBOL_NAMED(DEVICE_DT_NAME_GET(node_id),\t\t       \\\n\t\t\t    DEVICE_NAME_GET(Z_DEVICE_DT_HASH(node_id)))\n#elif defined(CONFIG_LLEXT_EXPORT_DEVICES)\n/* Export device identifiers using the builtin name */\n#define Z_DEVICE_EXPORT(node_id) EXPORT_SYMBOL(DEVICE_DT_NAME_GET(node_id))\n#endif\n\n/**\n * @brief Create a device object and set it up for boot time initialization,\n * with de-init capabilities.\n *\n * This macro defines a @ref device that is automatically configured by the\n * kernel during system initialization. This macro should only be used when the\n * device is not being allocated from a devicetree node. If you are allocating a\n * device from a devicetree node, use DEVICE_DT_DEINIT_DEFINE() or\n * DEVICE_DT_INST_DEINIT_DEFINE() instead.\n *\n * @param dev_id A unique token which is used in the name of the global device\n * structure as a C identifier.\n * @param name A string name for the device, which will be stored in\n * @ref device.name. This name can be used to look up the device with\n * device_get_binding(). This must be less than Z_DEVICE_MAX_NAME_LEN characters\n * (including terminating `NULL`) in order to be looked up from user mode.\n * @param init_fn Pointer to the device&#x27;s initialization function, which will be\n * run by the kernel during system initialization. Can be `NULL`.\n * @param deinit_fn Pointer to the device&#x27;s de-initialization function. Can be\n * `NULL`. It must release any acquired resources (e.g. pins, bus, clock...) and\n * leave the device in its reset state.\n * @param pm Pointer to the device&#x27;s power management resources, a\n * @ref pm_device, which will be stored in @ref device.pm field. Use `NULL` if\n * the device does not use PM.\n * @param data Pointer to the device&#x27;s private mutable data, which will be\n * stored in @ref device.data.\n * @param config Pointer to the device&#x27;s private constant data, which will be\n * stored in @ref device.config.\n * @param level The device&#x27;s initialization level (PRE_KERNEL_1, PRE_KERNEL_2 or\n * POST_KERNEL).\n * @param prio The device&#x27;s priority within its initialization level. See\n * SYS_INIT() for details.\n * @param api Pointer to the device&#x27;s API structure. Can be `NULL`.\n */\n#define DEVICE_DEINIT_DEFINE(dev_id, name, init_fn, deinit_fn, pm, data,       \\\n\t\t\t     config, level, prio, api)                         \\\n\tZ_DEVICE_STATE_DEFINE(dev_id);                                         \\\n\tZ_DEVICE_DEFINE(DT_INVALID_NODE, dev_id, name, init_fn, deinit_fn, 0U, \\\n\t\t\tpm, data, config, level, prio, api,                    \\\n\t\t\t&amp;Z_DEVICE_STATE_NAME(dev_id))\n\n/**\n * @brief Create a device object and set it up for boot time initialization.\n *\n * @see DEVICE_DEINIT_DEFINE()\n */\n#define DEVICE_DEFINE(dev_id, name, init_fn, pm, data, config, level, prio,    \\\n\t\t      api)                                                     \\\n\tDEVICE_DEINIT_DEFINE(dev_id, name, init_fn, NULL, pm, data, config,    \\\n\t\t\t     level, prio, api)\n\n/**\n * @brief Return a string name for a devicetree node.\n *\n * This macro returns a string literal usable as a device&#x27;s name from a\n * devicetree node identifier.\n *\n * @param node_id The devicetree node identifier.\n *\n * @return The value of the node&#x27;s `label` property, if it has one.\n * Otherwise, the node&#x27;s full name in `node-name@unit-address` form.\n */\n#define DEVICE_DT_NAME(node_id)                                                \\\n\tDT_PROP_OR(node_id, label, DT_NODE_FULL_NAME(node_id))\n\n/**\n * @brief Create a device object from a devicetree node identifier and set it up\n * for boot time initialization.\n *\n * This macro defines a @ref device that is automatically configured by the\n * kernel during system initialization. The global device object&#x27;s name as a C\n * identifier is derived from the node&#x27;s dependency ordinal or hash.\n * @ref device.name is set to `DEVICE_DT_NAME(node_id)`.\n *\n * The device is declared with extern visibility, so a pointer to a global\n * device object can be obtained with `DEVICE_DT_GET(node_id)` from any source\n * file that includes `&lt;zephyr/device.h&gt;` (even from extensions, when\n * @kconfig{CONFIG_LLEXT_EXPORT_DEVICES} is enabled). Before using the\n * pointer, the referenced object should be checked using device_is_ready().\n *\n * @param node_id The devicetree node identifier.\n * @param init_fn Pointer to the device&#x27;s initialization function, which will be\n * run by the kernel during system initialization. Can be `NULL`.\n * @param deinit_fn Pointer to the device&#x27;s de-initialization function. Can be\n * `NULL`. It must release any acquired resources (e.g. pins, bus, clock...) and\n * leave the device in its reset state.\n * @param pm Pointer to the device&#x27;s power management resources, a\n * @ref pm_device, which will be stored in @ref device.pm. Use `NULL` if the\n * device does not use PM.\n * @param data Pointer to the device&#x27;s private mutable data, which will be\n * stored in @ref device.data.\n * @param config Pointer to the device&#x27;s private constant data, which will be\n * stored in @ref device.config field.\n * @param level The device&#x27;s initialization level (PRE_KERNEL_1, PRE_KERNEL_2 or\n * POST_KERNEL).\n * @param prio The device&#x27;s priority within its initialization level. See\n * SYS_INIT() for details.\n * @param api Pointer to the device&#x27;s API structure. Can be `NULL`.\n */\n#define DEVICE_DT_DEINIT_DEFINE(node_id, init_fn, deinit_fn, pm, data, config, \\\n\t\t\t\tlevel, prio, api, ...)                         \\\n\tZ_DEVICE_STATE_DEFINE(Z_DEVICE_DT_DEV_ID(node_id));                    \\\n\tZ_DEVICE_DEFINE(node_id, Z_DEVICE_DT_DEV_ID(node_id),                  \\\n\t\t\tDEVICE_DT_NAME(node_id), init_fn, deinit_fn,           \\\n\t\t\tZ_DEVICE_DT_FLAGS(node_id), pm, data, config, level,   \\\n\t\t\tprio, api,                                             \\\n\t\t\t&amp;Z_DEVICE_STATE_NAME(Z_DEVICE_DT_DEV_ID(node_id)),     \\\n\t\t\t__VA_ARGS__)\n\n/**\n * @brief Create a device object from a devicetree node identifier and set it up\n * for boot time initialization.\n *\n * @see DEVICE_DT_DEINIT_DEFINE()\n */\n#define DEVICE_DT_DEFINE(node_id, init_fn, pm, data, config, level, prio, api, \\\n\t\t\t ...)                                                  \\\n\tDEVICE_DT_DEINIT_DEFINE(node_id, init_fn, NULL, pm, data, config,      \\\n\t\t\t\tlevel, prio, api, __VA_ARGS__)\n\n/**\n * @brief Like DEVICE_DT_DEINIT_DEFINE(), but uses an instance of a\n * `DT_DRV_COMPAT` compatible instead of a node identifier.\n *\n * @param inst Instance number. The `node_id` argument to DEVICE_DT_DEFINE() is\n * set to `DT_DRV_INST(inst)`.\n * @param ... Other parameters as expected by DEVICE_DT_DEFINE().\n */\n#define DEVICE_DT_INST_DEINIT_DEFINE(inst, ...)                                \\\n\tDEVICE_DT_DEINIT_DEFINE(DT_DRV_INST(inst), __VA_ARGS__)\n\n/**\n * @brief Like DEVICE_DT_DEFINE(), but uses an instance of a `DT_DRV_COMPAT`\n * compatible instead of a node identifier.\n *\n * @param inst Instance number. The `node_id` argument to DEVICE_DT_DEFINE() is\n * set to `DT_DRV_INST(inst)`.\n * @param ... Other parameters as expected by DEVICE_DT_DEFINE().\n */\n#define DEVICE_DT_INST_DEFINE(inst, ...)                                       \\\n\tDEVICE_DT_DEFINE(DT_DRV_INST(inst), __VA_ARGS__)\n\n/**\n * @brief The name of the global device object for @p node_id\n *\n * Returns the name of the global device structure as a C identifier. The device\n * must be allocated using DEVICE_DT_DEFINE() or DEVICE_DT_INST_DEFINE() for\n * this to work.\n *\n * This macro is normally only useful within device driver source code. In other\n * situations, you are probably looking for DEVICE_DT_GET().\n *\n * @param node_id Devicetree node identifier\n *\n * @return The name of the device object as a C identifier\n */\n#define DEVICE_DT_NAME_GET(node_id) DEVICE_NAME_GET(Z_DEVICE_DT_DEV_ID(node_id))\n\n/**\n * @brief Get a @ref device reference from a devicetree node identifier.\n *\n * Returns a pointer to a device object created from a devicetree node, if any\n * device was allocated by a driver.\n *\n * If no such device was allocated, this will fail at linker time. If you get an\n * error that looks like `undefined reference to __device_dts_ord_&lt;N&gt;`, that is\n * what happened. Check to make sure your device driver is being compiled,\n * usually by enabling the Kconfig options it requires.\n *\n * @param node_id A devicetree node identifier\n *\n * @return A pointer to the device object created for that node\n */\n#define DEVICE_DT_GET(node_id) (&amp;DEVICE_DT_NAME_GET(node_id))\n\n/**\n * @brief Get a @ref device reference for an instance of a `DT_DRV_COMPAT`\n * compatible.\n *\n * This is equivalent to `DEVICE_DT_GET(DT_DRV_INST(inst))`.\n *\n * @param inst `DT_DRV_COMPAT` instance number\n * @return A pointer to the device object created for that instance\n */\n#define DEVICE_DT_INST_GET(inst) DEVICE_DT_GET(DT_DRV_INST(inst))\n\n/**\n * @brief Get a @ref device reference from a devicetree compatible.\n *\n * If an enabled devicetree node has the given compatible and a device\n * object was created from it, this returns a pointer to that device.\n *\n * If there no such devices, this returns NULL.\n *\n * If there are multiple, this returns an arbitrary one.\n *\n * If this returns non-NULL, the device must be checked for readiness\n * before use, e.g. with device_is_ready().\n *\n * @param compat lowercase-and-underscores devicetree compatible\n * @return a pointer to a device, or NULL\n */\n#define DEVICE_DT_GET_ANY(compat)                                              \\\n\tCOND_CODE_1(DT_HAS_COMPAT_STATUS_OKAY(compat),                         \\\n\t\t    (DEVICE_DT_GET(DT_COMPAT_GET_ANY_STATUS_OKAY(compat))),    \\\n\t\t    (NULL))\n\n/**\n * @brief Get a @ref device reference from a devicetree compatible.\n *\n * If an enabled devicetree node has the given compatible and a device object\n * was created from it, this returns a pointer to that device.\n *\n * If there are no such devices, this will fail at compile time.\n *\n * If there are multiple, this returns an arbitrary one.\n *\n * If this returns non-NULL, the device must be checked for readiness before\n * use, e.g. with device_is_ready().\n *\n * @param compat lowercase-and-underscores devicetree compatible\n * @return a pointer to a device\n */\n#define DEVICE_DT_GET_ONE(compat)                                              \\\n\tCOND_CODE_1(DT_HAS_COMPAT_STATUS_OKAY(compat),                         \\\n\t\t    (DEVICE_DT_GET(DT_COMPAT_GET_ANY_STATUS_OKAY(compat))),    \\\n\t\t    (ZERO_OR_COMPILE_ERROR(0)))\n\n/**\n * @brief Utility macro to obtain an optional reference to a device.\n *\n * If the node identifier refers to a node with status `okay`, this returns\n * `DEVICE_DT_GET(node_id)`. Otherwise, it returns `NULL`.\n *\n * @param node_id devicetree node identifier\n *\n * @return a @ref device reference for the node identifier, which may be `NULL`.\n */\n#define DEVICE_DT_GET_OR_NULL(node_id)                                         \\\n\tCOND_CODE_1(DT_NODE_HAS_STATUS_OKAY(node_id),                          \\\n\t\t    (DEVICE_DT_GET(node_id)), (NULL))\n\n/**\n * @brief Get a @ref device reference from a devicetree phandles by idx.\n *\n * Returns a pointer to a device object referenced by a phandles property, by idx.\n *\n * @param node_id A devicetree node identifier\n * @param prop lowercase-and-underscores property with type `phandle`,\n *            `phandles`, or `phandle-array`\n * @param idx logical index into @p phs, which must be zero if @p phs\n *            has type `phandle`\n *\n * @return A pointer to the device object created for that node\n */\n#define DEVICE_DT_GET_BY_IDX(node_id, prop, idx) \\\n\tDEVICE_DT_GET(DT_PHANDLE_BY_IDX(node_id, prop, idx))\n\n/**\n * @brief Obtain a pointer to a device object by name\n *\n * @details Return the address of a device object created by\n * DEVICE_DEFINE(), using the dev_id provided to DEVICE_DEFINE().\n *\n * @param dev_id Device identifier.\n *\n * @return A pointer to the device object created by DEVICE_DEFINE()\n */\n#define DEVICE_GET(dev_id) (&amp;DEVICE_NAME_GET(dev_id))\n\n/**\n * @brief Declare a static device object\n *\n * This macro can be used at the top-level to declare a device, such\n * that DEVICE_GET() may be used before the full declaration in\n * DEVICE_DEFINE().\n *\n * This is often useful when configuring interrupts statically in a\n * device&#x27;s init or per-instance config function, as the init function\n * itself is required by DEVICE_DEFINE() and use of DEVICE_GET()\n * inside it creates a circular dependency.\n *\n * @param dev_id Device identifier.\n */\n#define DEVICE_DECLARE(dev_id)                                                 \\\n\tstatic const struct device DEVICE_NAME_GET(dev_id)\n\n/**\n * @brief Get a @ref init_entry reference from a devicetree node.\n *\n * @param node_id A devicetree node identifier\n *\n * @return A pointer to the @ref init_entry object created for that node\n */\n#define DEVICE_INIT_DT_GET(node_id)                                            \\\n\t(&amp;Z_INIT_ENTRY_NAME(DEVICE_DT_NAME_GET(node_id)))\n\n/**\n * @brief Get a @ref init_entry reference from a device identifier.\n *\n * @param dev_id Device identifier.\n *\n * @return A pointer to the init_entry object created for that device\n */\n#define DEVICE_INIT_GET(dev_id) (&amp;Z_INIT_ENTRY_NAME(DEVICE_NAME_GET(dev_id)))\n\n/**\n * @brief Runtime device dynamic structure (in RAM) per driver instance\n *\n * Fields in this are expected to be default-initialized to zero. The\n * kernel driver infrastructure and driver access functions are\n * responsible for ensuring that any non-zero initialization is done\n * before they are accessed.\n */\nstruct device_state {\n\t/**\n\t * Device initialization return code (positive errno value).\n\t *\n\t * Device initialization functions return a negative errno code if they\n\t * fail. In Zephyr, errno values do not exceed 255, so we can store the\n\t * positive result value in a uint8_t type.\n\t */\n\tuint8_t init_res;\n\n\t/** Indicates the device initialization function has been\n\t * invoked.\n\t */\n\tbool initialized : 1;\n};\n\nstruct pm_device_base;\nstruct pm_device;\nstruct pm_device_isr;\n#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)\nstruct device_dt_metadata;\n#endif\n\n#ifdef CONFIG_DEVICE_DEPS_DYNAMIC\n#define Z_DEVICE_DEPS_CONST\n#else\n#define Z_DEVICE_DEPS_CONST const\n#endif\n\n/** Device flags */\ntypedef uint8_t device_flags_t;\n\n/**\n * @name Device flags\n * @{\n */\n\n/** Device initialization is deferred */\n#define DEVICE_FLAG_INIT_DEFERRED BIT(0)\n\n/** @} */\n\n/** Device operations */\nstruct device_ops {\n\t/** Initialization function */\n\tint (*init)(const struct device *dev);\n\t/** De-initialization function */\n\tint (*deinit)(const struct device *dev);\n};\n\n/**\n * @brief Runtime device structure (in ROM) per driver instance\n */\nstruct device {\n\t/** Name of the device instance */\n\tconst char *name;\n\t/** Address of device instance config information */\n\tconst void *config;\n\t/** Address of the API structure exposed by the device instance */\n\tconst void *api;\n\t/** Address of the common device state */\n\tstruct device_state *state;\n\t/** Address of the device instance private data */\n\tvoid *data;\n\t/** Device operations */\n\tstruct device_ops ops;\n\t/** Device flags */\n\tdevice_flags_t flags;\n#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)\n\t/**\n\t * Optional pointer to dependencies associated with the device.\n\t *\n\t * This encodes a sequence of sets of device handles that have some\n\t * relationship to this node. The individual sets are extracted with\n\t * dedicated API, such as device_required_handles_get(). Only available\n\t * if @kconfig{CONFIG_DEVICE_DEPS} is enabled.\n\t */\n\tZ_DEVICE_DEPS_CONST device_handle_t *deps;\n#endif /* CONFIG_DEVICE_DEPS */\n#if defined(CONFIG_PM_DEVICE) || defined(__DOXYGEN__)\n\t/**\n\t * Reference to the device PM resources (only available if\n\t * @kconfig{CONFIG_PM_DEVICE} is enabled).\n\t */\n\tunion {\n\t\tstruct pm_device_base *pm_base;\n\t\tstruct pm_device *pm;\n\t\tstruct pm_device_isr *pm_isr;\n\t};\n#endif\n#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)\n\tconst struct device_dt_metadata *dt_meta;\n#endif /* CONFIG_DEVICE_DT_METADATA */\n};\n\n/**\n * @brief Get the handle for a given device\n *\n * @param dev the device for which a handle is desired.\n *\n * @return the handle for the device, or DEVICE_HANDLE_NULL if the device does\n * not have an associated handle.\n */\nstatic inline device_handle_t device_handle_get(const struct device *dev)\n{\n\tdevice_handle_t ret = DEVICE_HANDLE_NULL;\n\tSTRUCT_SECTION_START_EXTERN(device);\n\n\t/* TODO: If/when devices can be constructed that are not part of the\n\t * fixed sequence we&#x27;ll need another solution.\n\t */\n\tif (dev != NULL) {\n\t\tret = 1 + (device_handle_t)(dev - STRUCT_SECTION_START(device));\n\t}\n\n\treturn ret;\n}\n\n/**\n * @brief Get the device corresponding to a handle.\n *\n * @param dev_handle the device handle\n *\n * @return the device that has that handle, or a null pointer if @p dev_handle\n * does not identify a device.\n */\nstatic inline const struct device *\ndevice_from_handle(device_handle_t dev_handle)\n{\n\tSTRUCT_SECTION_START_EXTERN(device);\n\tconst struct device *dev = NULL;\n\tsize_t numdev;\n\n\tSTRUCT_SECTION_COUNT(device, &amp;numdev);\n\n\tif ((dev_handle &gt; 0) &amp;&amp; ((size_t)dev_handle &lt;= numdev)) {\n\t\tdev = &amp;STRUCT_SECTION_START(device)[dev_handle - 1];\n\t}\n\n\treturn dev;\n}\n\n#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)\n\n/**\n * @brief Prototype for functions used when iterating over a set of devices.\n *\n * Such a function may be used in API that identifies a set of devices and\n * provides a visitor API supporting caller-specific interaction with each\n * device in the set.\n *\n * The visit is said to succeed if the visitor returns a non-negative value.\n *\n * @param dev a device in the set being iterated\n * @param context state used to support the visitor function\n *\n * @return A non-negative number to allow walking to continue, and a negative\n * error code to case the iteration to stop.\n *\n * @see device_required_foreach()\n * @see device_supported_foreach()\n */\ntypedef int (*device_visitor_callback_t)(const struct device *dev,\n\t\t\t\t\t void *context);\n\n/**\n * @brief Get the device handles for devicetree dependencies of this device.\n *\n * This function returns a pointer to an array of device handles. The length of\n * the array is stored in the @p count parameter.\n *\n * The array contains a handle for each device that @p dev requires directly, as\n * determined from the devicetree. This does not include transitive\n * dependencies; you must recursively determine those.\n *\n * @param dev the device for which dependencies are desired.\n * @param count pointer to where this function should store the length of the\n * returned array. No value is stored if the call returns a null pointer. The\n * value may be set to zero if the device has no devicetree dependencies.\n *\n * @return a pointer to a sequence of @p count device handles, or a null pointer\n * if @p dev does not have any dependency data.\n */\nstatic inline const device_handle_t *\ndevice_required_handles_get(const struct device *dev, size_t *count)\n{\n\tconst device_handle_t *rv = dev-&gt;deps;\n\n\tif (rv != NULL) {\n\t\tsize_t i = 0;\n\n\t\twhile ((rv[i] != Z_DEVICE_DEPS_ENDS) &amp;&amp;\n\t\t       (rv[i] != Z_DEVICE_DEPS_SEP)) {\n\t\t\t++i;\n\t\t}\n\t\t*count = i;\n\t}\n\n\treturn rv;\n}\n\n/**\n * @brief Get the device handles for injected dependencies of this device.\n *\n * This function returns a pointer to an array of device handles. The length of\n * the array is stored in the @p count parameter.\n *\n * The array contains a handle for each device that @p dev manually injected as\n * a dependency, via providing extra arguments to Z_DEVICE_DEFINE. This does not\n * include transitive dependencies; you must recursively determine those.\n *\n * @param dev the device for which injected dependencies are desired.\n * @param count pointer to where this function should store the length of the\n * returned array. No value is stored if the call returns a null pointer. The\n * value may be set to zero if the device has no devicetree dependencies.\n *\n * @return a pointer to a sequence of @p *count device handles, or a null\n * pointer if @p dev does not have any dependency data.\n */\nstatic inline const device_handle_t *\ndevice_injected_handles_get(const struct device *dev, size_t *count)\n{\n\tconst device_handle_t *rv = dev-&gt;deps;\n\tsize_t region = 0;\n\tsize_t i = 0;\n\n\tif (rv != NULL) {\n\t\t/* Fast forward to injected devices */\n\t\twhile (region != 1) {\n\t\t\tif (*rv == Z_DEVICE_DEPS_SEP) {\n\t\t\t\tregion++;\n\t\t\t}\n\t\t\trv++;\n\t\t}\n\t\twhile ((rv[i] != Z_DEVICE_DEPS_ENDS) &amp;&amp;\n\t\t       (rv[i] != Z_DEVICE_DEPS_SEP)) {\n\t\t\t++i;\n\t\t}\n\t\t*count = i;\n\t}\n\n\treturn rv;\n}\n\n/**\n * @brief Get the set of handles that this device supports.\n *\n * This function returns a pointer to an array of device handles. The length of\n * the array is stored in the @p count parameter.\n *\n * The array contains a handle for each device that @p dev &quot;supports&quot; -- that\n * is, devices that require @p dev directly -- as determined from the\n * devicetree. This does not include transitive dependencies; you must\n * recursively determine those.\n *\n * @param dev the device for which supports are desired.\n * @param count pointer to where this function should store the length of the\n * returned array. No value is stored if the call returns a null pointer. The\n * value may be set to zero if nothing in the devicetree depends on @p dev.\n *\n * @return a pointer to a sequence of @p *count device handles, or a null\n * pointer if @p dev does not have any dependency data.\n */\nstatic inline const device_handle_t *\ndevice_supported_handles_get(const struct device *dev, size_t *count)\n{\n\tconst device_handle_t *rv = dev-&gt;deps;\n\tsize_t region = 0;\n\tsize_t i = 0;\n\n\tif (rv != NULL) {\n\t\t/* Fast forward to supporting devices */\n\t\twhile (region != 2) {\n\t\t\tif (*rv == Z_DEVICE_DEPS_SEP) {\n\t\t\t\tregion++;\n\t\t\t}\n\t\t\trv++;\n\t\t}\n\t\t/* Count supporting devices.\n\t\t * Trailing NULL&#x27;s can be injected by gen_device_deps.py due to\n\t\t * CONFIG_PM_DEVICE_POWER_DOMAIN_DYNAMIC_NUM\n\t\t */\n\t\twhile ((rv[i] != Z_DEVICE_DEPS_ENDS) &amp;&amp;\n\t\t       (rv[i] != DEVICE_HANDLE_NULL)) {\n\t\t\t++i;\n\t\t}\n\t\t*count = i;\n\t}\n\n\treturn rv;\n}\n\n/**\n * @brief Visit every device that @p dev directly requires.\n *\n * Zephyr maintains information about which devices are directly required by\n * another device; for example an I2C-based sensor driver will require an I2C\n * controller for communication. Required devices can derive from\n * statically-defined devicetree relationships or dependencies registered at\n * runtime.\n *\n * This API supports operating on the set of required devices. Example uses\n * include making sure required devices are ready before the requiring device is\n * used, and releasing them when the requiring device is no longer needed.\n *\n * There is no guarantee on the order in which required devices are visited.\n *\n * If the @p visitor_cb function returns a negative value iteration is halted,\n * and the returned value from the visitor is returned from this function.\n *\n * @note This API is not available to unprivileged threads.\n *\n * @param dev a device of interest. The devices that this device depends on will\n * be used as the set of devices to visit. This parameter must not be null.\n * @param visitor_cb the function that should be invoked on each device in the\n * dependency set. This parameter must not be null.\n * @param context state that is passed through to the visitor function. This\n * parameter may be null if @p visitor_cb tolerates a null @p context.\n *\n * @return The number of devices that were visited if all visits succeed, or\n * the negative value returned from the first visit that did not succeed.\n */\nint device_required_foreach(const struct device *dev,\n\t\t\t    device_visitor_callback_t visitor_cb,\n\t\t\t    void *context);\n\n/**\n * @brief Visit every device that @p dev directly supports.\n *\n * Zephyr maintains information about which devices are directly supported by\n * another device; for example an I2C controller will support an I2C-based\n * sensor driver. Supported devices can derive from statically-defined\n * devicetree relationships.\n *\n * This API supports operating on the set of supported devices. Example uses\n * include iterating over the devices connected to a regulator when it is\n * powered on.\n *\n * There is no guarantee on the order in which required devices are visited.\n *\n * If the @p visitor_cb function returns a negative value iteration is halted,\n * and the returned value from the visitor is returned from this function.\n *\n * @note This API is not available to unprivileged threads.\n *\n * @param dev a device of interest. The devices that this device supports\n * will be used as the set of devices to visit. This parameter must not be null.\n * @param visitor_cb the function that should be invoked on each device in the\n * support set. This parameter must not be null.\n * @param context state that is passed through to the visitor function. This\n * parameter may be null if @p visitor_cb tolerates a null @p context.\n *\n * @return The number of devices that were visited if all visits succeed, or the\n * negative value returned from the first visit that did not succeed.\n */\nint device_supported_foreach(const struct device *dev,\n\t\t\t     device_visitor_callback_t visitor_cb,\n\t\t\t     void *context);\n\n#endif /* CONFIG_DEVICE_DEPS */\n\n/**\n * @brief Get a @ref device reference from its @ref device.name field.\n *\n * This function iterates through the devices on the system. If a device with\n * the given @p name field is found, and that device initialized successfully at\n * boot time, this function returns a pointer to the device.\n *\n * If no device has the given @p name, this function returns `NULL`.\n *\n * This function also returns NULL when a device is found, but it failed to\n * initialize successfully at boot time. (To troubleshoot this case, set a\n * breakpoint on your device driver&#x27;s initialization function.)\n *\n * @param name device name to search for. A null pointer, or a pointer to an\n * empty string, will cause NULL to be returned.\n *\n * @return pointer to device structure with the given name; `NULL` if the device\n * is not found or if the device with that name&#x27;s initialization function\n * failed.\n */\n__syscall const struct device *device_get_binding(const char *name);\n\n/**\n * @brief Get access to the static array of static devices.\n *\n * @param devices where to store the pointer to the array of statically\n * allocated devices. The array must not be mutated through this pointer.\n *\n * @return the number of statically allocated devices.\n */\nsize_t z_device_get_all_static(const struct device **devices);\n\n/**\n * @brief Verify that a device is ready for use.\n *\n * Indicates whether the provided device pointer is for a device known to be\n * in a state where it can be used with its standard API.\n *\n * This can be used with device pointers captured from DEVICE_DT_GET(), which\n * does not include the readiness checks of device_get_binding(). At minimum\n * this means that the device has been successfully initialized.\n *\n * @param dev pointer to the device in question.\n *\n * @retval true If the device is ready for use.\n * @retval false If the device is not ready for use or if a NULL device pointer\n * is passed as argument.\n */\n__syscall bool device_is_ready(const struct device *dev);\n\n/**\n * @brief Initialize a device.\n *\n * A device whose initialization was deferred (by marking it as\n * ``zephyr,deferred-init`` on devicetree) needs to be initialized manually via\n * this call. De-initialized devices can also be initialized again via this\n * call.\n *\n * @param dev device to be initialized.\n *\n * @retval -EALREADY Device is already initialized.\n * @retval -errno For other errors.\n */\n__syscall int device_init(const struct device *dev);\n\n/**\n * @brief De-initialize a device.\n *\n * When a device is de-initialized, it will release any resources it has\n * acquired (e.g. pins, memory, clocks, DMA channels, etc.) and its status will\n * be left as in its reset state.\n *\n * @warning It is the responsibility of the caller to ensure that the device is\n * ready to be de-initialized.\n *\n * @param dev device to be de-initialized.\n *\n * @retval 0 If successful\n * @retval -EPERM If device has not been initialized.\n * @retval -ENOTSUP If device does not support de-initialization.\n * @retval -errno For any other errors.\n */\n__syscall int device_deinit(const struct device *dev);\n\n/**\n * @}\n */\n\n/** @cond INTERNAL_HIDDEN */\n\n/**\n * @brief Synthesize a unique name for the device state associated with\n * @p dev_id.\n */\n#define Z_DEVICE_STATE_NAME(dev_id) _CONCAT(__devstate_, dev_id)\n\n/**\n * @brief Utility macro to define and initialize the device state.\n *\n * @param dev_id Device identifier.\n */\n#define Z_DEVICE_STATE_DEFINE(dev_id)                                          \\\n\tstatic Z_DECL_ALIGN(struct device_state) Z_DEVICE_STATE_NAME(dev_id)   \\\n\t\t__attribute__((__section__(&quot;.z_devstate&quot;)))\n\n/**\n * @brief Device flags obtained from DT.\n *\n * @param node_id Devicetree node identifier.\n */\n#define Z_DEVICE_DT_FLAGS(node_id)                                             \\\n\t(DT_PROP_OR(node_id, zephyr_deferred_init, 0U) * DEVICE_FLAG_INIT_DEFERRED)\n\n#if defined(CONFIG_DEVICE_DEPS) || defined(__DOXYGEN__)\n\n/**\n * @brief Synthesize the name of the object that holds device ordinal and\n * dependency data.\n *\n * @param dev_id Device identifier.\n */\n#define Z_DEVICE_DEPS_NAME(dev_id) _CONCAT(__devicedeps_, dev_id)\n\n/**\n * @brief Expand extra dependencies with a comma in between.\n *\n * @param ... Extra dependencies.\n */\n#define Z_DEVICE_EXTRA_DEPS(...)                                            \\\n\tFOR_EACH_NONEMPTY_TERM(IDENTITY, (,), __VA_ARGS__)\n\n/** @brief Linker section were device dependencies are placed. */\n#define Z_DEVICE_DEPS_SECTION                                               \\\n\t__attribute__((__section__(&quot;.__device_deps_pass1&quot;)))\n\n#ifdef __cplusplus\n#define Z_DEVICE_DEPS_EXTERN extern\n#else\n#define Z_DEVICE_DEPS_EXTERN\n#endif\n\n/**\n * @brief Define device dependencies.\n *\n * Initial build provides a record that associates the device object with its\n * devicetree ordinal, and provides the dependency ordinals. These are provided\n * as weak definitions (to prevent the reference from being captured when the\n * original object file is compiled), and in a distinct pass1 section (which\n * will be replaced by postprocessing).\n *\n * Before processing in gen_device_deps.py, the array format is:\n * {\n *     DEVICE_ORDINAL (or DEVICE_HANDLE_NULL if not a devicetree node),\n *     List of devicetree dependency ordinals (if any),\n *     Z_DEVICE_DEPS_SEP,\n *     List of injected dependency ordinals (if any),\n *     Z_DEVICE_DEPS_SEP,\n *     List of devicetree supporting ordinals (if any),\n * }\n *\n * After processing in gen_device_deps.py, the format is updated to:\n * {\n *     List of existing devicetree dependency handles (if any),\n *     Z_DEVICE_DEPS_SEP,\n *     List of injected devicetree dependency handles (if any),\n *     Z_DEVICE_DEPS_SEP,\n *     List of existing devicetree support handles (if any),\n *     DEVICE_HANDLE_NULL\n * }\n *\n * It is also (experimentally) necessary to provide explicit alignment on each\n * object. Otherwise x86-64 builds will introduce padding between objects in the\n * same input section in individual object files, which will be retained in\n * subsequent links both wasting space and resulting in aggregate size changes\n * relative to pass2 when all objects will be in the same input section.\n */\n#define Z_DEVICE_DEPS_DEFINE(node_id, dev_id, ...)                             \\\n\textern Z_DEVICE_DEPS_CONST device_handle_t Z_DEVICE_DEPS_NAME(         \\\n\t\tdev_id)[];                                                     \\\n\tZ_DEVICE_DEPS_CONST Z_DECL_ALIGN(device_handle_t)                      \\\n\tZ_DEVICE_DEPS_SECTION Z_DEVICE_DEPS_EXTERN __weak                      \\\n\t\tZ_DEVICE_DEPS_NAME(dev_id)[] = {                               \\\n\t\tCOND_CODE_1(                                                   \\\n\t\t\tDT_NODE_EXISTS(node_id),                               \\\n\t\t\t(DT_DEP_ORD(node_id), DT_REQUIRES_DEP_ORDS(node_id)),  \\\n\t\t\t(DEVICE_HANDLE_NULL,)) /**/                            \\\n\t\tZ_DEVICE_DEPS_SEP,                                             \\\n\t\tZ_DEVICE_EXTRA_DEPS(__VA_ARGS__) /**/                          \\\n\t\tZ_DEVICE_DEPS_SEP,                                             \\\n\t\tCOND_CODE_1(DT_NODE_EXISTS(node_id),                           \\\n\t\t\t    (DT_SUPPORTS_DEP_ORDS(node_id)), ()) /**/          \\\n\t}\n\n#endif /* CONFIG_DEVICE_DEPS */\n#if defined(CONFIG_DEVICE_DT_METADATA) || defined(__DOXYGEN__)\n/**\n * @brief Devicetree node labels associated with a device\n */\nstruct device_dt_nodelabels {\n\t/* @brief number of elements in the nodelabels array */\n\tsize_t num_nodelabels;\n\t/* @brief array of node labels as strings, exactly as they\n\t *        appear in the final devicetree\n\t */\n\tconst char *nodelabels[];\n};\n\n/**\n * @brief Devicetree metadata associated with a device\n *\n * This is currently limited to node labels, but the structure is\n * generic enough to be extended later without requiring breaking\n * changes.\n */\nstruct device_dt_metadata {\n\t/**\n\t * @brief Node labels associated with the device\n\t * @see device_get_dt_nodelabels()\n\t */\n\tconst struct device_dt_nodelabels *nl;\n};\n\n/**\n * @brief Get a @ref device reference from a devicetree node label.\n *\n * If:\n *\n * 1. a device was defined from a devicetree node, for example\n *    with DEVICE_DT_DEFINE() or another similar macro, and\n * 2. that devicetree node has @p nodelabel as one of its node labels, and\n * 3. the device initialized successfully at boot time,\n *\n * then this function returns a pointer to the device. Otherwise, it\n * returns NULL.\n *\n * @param nodelabel a devicetree node label\n * @return a device reference for a device created from a node with that\n *         node label, or NULL if either no such device exists or the device\n *         failed to initialize\n */\n__syscall const struct device *device_get_by_dt_nodelabel(const char *nodelabel);\n\n/**\n * @brief Get the devicetree node labels associated with a device\n * @param dev device whose metadata to look up\n * @return information about the devicetree node labels or NULL if not available\n */\nstatic inline const struct device_dt_nodelabels *\ndevice_get_dt_nodelabels(const struct device *dev)\n{\n\tif (dev-&gt;dt_meta == NULL) {\n\t\treturn NULL;\n\t}\n\treturn dev-&gt;dt_meta-&gt;nl;\n}\n\n/**\n * @brief Maximum devicetree node label length.\n *\n * The maximum length is set so that device_get_by_dt_nodelabel() can\n * be used from userspace.\n */\n#define Z_DEVICE_MAX_NODELABEL_LEN Z_DEVICE_MAX_NAME_LEN\n\n/**\n * @brief Name of the identifier for a device&#x27;s DT metadata structure\n * @param dev_id device identifier\n */\n#define Z_DEVICE_DT_METADATA_NAME_GET(dev_id) UTIL_CAT(__dev_dt_meta_, dev_id)\n\n/**\n * @brief Name of the identifier for the array of node label strings\n *        saved for a device.\n */\n#define Z_DEVICE_DT_NODELABELS_NAME_GET(dev_id) UTIL_CAT(__dev_dt_nodelabels_, dev_id)\n\n/**\n * @brief Initialize an entry in the device DT node label lookup table\n *\n * Allocates and initializes a struct device_dt_metadata in the\n * appropriate iterable section for use finding devices.\n */\n#define Z_DEVICE_DT_METADATA_DEFINE(node_id, dev_id)\t\t\t\\\n\tstatic const struct device_dt_nodelabels\t\t\t\\\n\tZ_DEVICE_DT_NODELABELS_NAME_GET(dev_id) = {\t\t\t\\\n\t\t.num_nodelabels = DT_NUM_NODELABELS(node_id),\t\t\\\n\t\t.nodelabels = DT_NODELABEL_STRING_ARRAY(node_id),\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatic const struct device_dt_metadata\t\t\t\t\\\n\tZ_DEVICE_DT_METADATA_NAME_GET(dev_id) = {\t\t\t\\\n\t\t.nl = &amp;Z_DEVICE_DT_NODELABELS_NAME_GET(dev_id),\t\t\t\\\n\t};\n#endif  /* CONFIG_DEVICE_DT_METADATA */\n\n/**\n * @brief Init sub-priority of the device\n *\n * The sub-priority is defined by the devicetree ordinal, which ensures that\n * multiple drivers running at the same priority level run in an order that\n * respects the devicetree dependencies.\n */\n#define Z_DEVICE_INIT_SUB_PRIO(node_id)                                        \\\n\tCOND_CODE_1(DT_NODE_EXISTS(node_id),                                   \\\n\t\t    (DT_DEP_ORD_STR_SORTABLE(node_id)), (0))\n\n/**\n * @brief Maximum device name length.\n *\n * The maximum length is set so that device_get_binding() can be used from\n * userspace.\n */\n#define Z_DEVICE_MAX_NAME_LEN 48U\n\n/**\n * @brief Compile time check for device name length\n *\n * @param name Device name.\n */\n#define Z_DEVICE_NAME_CHECK(name)                                              \\\n\tBUILD_ASSERT(sizeof(Z_STRINGIFY(name)) &lt;= Z_DEVICE_MAX_NAME_LEN,       \\\n\t\t\t    Z_STRINGIFY(name) &quot; too long&quot;)\n\n/**\n * @brief Initializer for @ref device.\n *\n * @param name_ Name of the device.\n * @param init_fn_ Init function (optional).\n * @param deinit_fn_ De-init function (optional).\n * @param flags_ Device flags.\n * @param pm_ Reference to @ref pm_device_base (optional).\n * @param data_ Reference to device data.\n * @param config_ Reference to device config.\n * @param api_ Reference to device API ops.\n * @param state_ Reference to device state.\n * @param deps_ Reference to device dependencies.\n * @param node_id_ Devicetree node identifier\n * @param dev_id_ Device identifier token, as passed to Z_DEVICE_BASE_DEFINE\n */\n#define Z_DEVICE_INIT(name_, init_fn_, deinit_fn_, flags_, pm_, data_, config_, api_,   \\\n\t\t      state_, deps_, node_id_, dev_id_)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\t.name = name_,\t\t\t\t\t\t\t\t\\\n\t\t.config = (config_),\t\t\t\t\t\t\t\\\n\t\t.api = (api_),\t\t\t\t\t\t\t\t\\\n\t\t.state = (state_),\t\t\t\t\t\t\t\\\n\t\t.data = (data_),\t\t\t\t\t\t\t\\\n\t\t.ops = { .init = (init_fn_), .deinit = (deinit_fn_) },\t\t\t\\\n\t\t.flags = (flags_),\t\t\t\t\t\t\t\\\n\t\tIF_ENABLED(CONFIG_DEVICE_DEPS, (.deps = (deps_),)) /**/\t\t\t\\\n\t\tIF_ENABLED(CONFIG_PM_DEVICE, Z_DEVICE_INIT_PM_BASE(pm_)) /**/\t\t\\\n\t\tIF_ENABLED(CONFIG_DEVICE_DT_METADATA,\t\t\t\t\t\\\n\t\t\t   (IF_ENABLED(DT_NODE_EXISTS(node_id_),\t\t\t\\\n\t\t\t\t       (.dt_meta = &amp;Z_DEVICE_DT_METADATA_NAME_GET(\t\\\n\t\t\t\t\t\tdev_id_),))))\t\t\t\t\\\n\t}\n\n/*\n * Anonymous unions require C11. Some pre-C11 gcc versions have early support for anonymous\n * unions but they require these braces when combined with C99 designated initializers. For\n * more details see https://docs.zephyrproject.org/latest/develop/languages/cpp/\n */\n#if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__) &lt; 201100\n#  define Z_DEVICE_INIT_PM_BASE(pm_) ({ .pm_base = (pm_),},)\n#else\n#  define Z_DEVICE_INIT_PM_BASE(pm_)   (.pm_base = (pm_),)\n#endif\n\n/**\n * @brief Device section name (used for sorting purposes).\n *\n * @param level Initialization level\n * @param prio Initialization priority\n */\n#define Z_DEVICE_SECTION_NAME(level, prio)                                     \\\n\t_CONCAT(INIT_LEVEL_ORD(level), _##prio)\n\n/**\n * @brief Define a @ref device\n *\n * @param node_id Devicetree node id for the device (DT_INVALID_NODE if a\n * software device).\n * @param dev_id Device identifier (used to name the defined @ref device).\n * @param name Name of the device.\n * @param init_fn Init function.\n * @param deinit_fn De-init function.\n * @param flags Device flags.\n * @param pm Reference to @ref pm_device_base associated with the device.\n * (optional).\n * @param data Reference to device data.\n * @param config Reference to device config.\n * @param level Initialization level.\n * @param prio Initialization priority.\n * @param api Reference to device API.\n * @param ... Optional dependencies, manually specified.\n */\n#define Z_DEVICE_BASE_DEFINE(node_id, dev_id, name, init_fn, deinit_fn, flags, pm, data, config,   \\\n\t\t\t     level, prio, api, state, deps)                                        \\\n\tCOND_CODE_1(DT_NODE_EXISTS(node_id), (), (static))                                         \\\n\tCOND_CODE_1(Z_DEVICE_IS_MUTABLE(node_id), (), (const))                                     \\\n\tSTRUCT_SECTION_ITERABLE_NAMED_ALTERNATE(                                                   \\\n\t\tdevice, COND_CODE_1(Z_DEVICE_IS_MUTABLE(node_id), (device_mutable), (device)),     \\\n\t\tZ_DEVICE_SECTION_NAME(level, prio), DEVICE_NAME_GET(dev_id)) =                     \\\n\t\tZ_DEVICE_INIT(name, init_fn, deinit_fn, flags, pm, data, config, api, state, deps, \\\n\t\t\t      node_id, dev_id)\n\n/**\n * @brief Issue an error if the given init level is not supported.\n *\n * @param level Init level\n */\n#define Z_DEVICE_CHECK_INIT_LEVEL(level)                                       \\\n\tCOND_CODE_1(Z_INIT_PRE_KERNEL_1_##level, (),                           \\\n\t(COND_CODE_1(Z_INIT_PRE_KERNEL_2_##level, (),                          \\\n\t(COND_CODE_1(Z_INIT_POST_KERNEL_##level, (),                           \\\n\t(ZERO_OR_COMPILE_ERROR(0)))))))\n\n/**\n * @brief Define the init entry for a device.\n *\n * @param node_id Devicetree node id for the device (DT_INVALID_NODE if a\n * software device).\n * @param dev_id Device identifier.\n * @param level Initialization level.\n * @param prio Initialization priority.\n */\n#define Z_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id, level, prio)                                   \\\n\tZ_DEVICE_CHECK_INIT_LEVEL(level)                                                           \\\n                                                                                                   \\\n\tstatic const Z_DECL_ALIGN(struct init_entry) __used __noasan Z_INIT_ENTRY_SECTION(         \\\n\t\tlevel, prio, Z_DEVICE_INIT_SUB_PRIO(node_id))                                      \\\n\t\tZ_INIT_ENTRY_NAME(DEVICE_NAME_GET(dev_id)) = {                                     \\\n\t\t\t.init_fn = NULL,                                                           \\\n\t\t\t.dev = (const struct device *)&amp;DEVICE_NAME_GET(dev_id),                    \\\n\t\t}\n\n/**\n * @brief Define a @ref device and all other required objects.\n *\n * This is the common macro used to define @ref device objects. It can be used\n * to define both Devicetree and software devices.\n *\n * @param node_id Devicetree node id for the device (DT_INVALID_NODE if a\n * software device).\n * @param dev_id Device identifier (used to name the defined @ref device).\n * @param name Name of the device.\n * @param init_fn Device init function.\n * @param flags Device flags.\n * @param pm Reference to @ref pm_device_base associated with the device.\n * (optional).\n * @param data Reference to device data.\n * @param config Reference to device config.\n * @param level Initialization level.\n * @param prio Initialization priority.\n * @param api Reference to device API.\n * @param state Reference to device state.\n * @param ... Optional dependencies, manually specified.\n */\n#define Z_DEVICE_DEFINE(node_id, dev_id, name, init_fn, deinit_fn, flags, pm,   \\\n\t\t\tdata, config, level, prio, api, state, ...)             \\\n\tZ_DEVICE_NAME_CHECK(name);                                              \\\n                                                                                \\\n\tIF_ENABLED(CONFIG_DEVICE_DEPS,                                          \\\n\t\t   (Z_DEVICE_DEPS_DEFINE(node_id, dev_id, __VA_ARGS__);))       \\\n                                                                                \\\n\tIF_ENABLED(CONFIG_DEVICE_DT_METADATA,                                   \\\n\t\t   (IF_ENABLED(DT_NODE_EXISTS(node_id),                         \\\n\t\t\t      (Z_DEVICE_DT_METADATA_DEFINE(node_id, dev_id);))))\\\n                                                                                \\\n\tZ_DEVICE_BASE_DEFINE(node_id, dev_id, name, init_fn, deinit_fn, flags,  \\\n\t\t\t     pm, data, config, level, prio, api, state,         \\\n\t\t\t     Z_DEVICE_DEPS_NAME(dev_id));                       \\\n                                                                                \\\n\tZ_DEVICE_INIT_ENTRY_DEFINE(node_id, dev_id, level, prio);               \\\n                                                                                \\\n\tIF_ENABLED(CONFIG_LLEXT_EXPORT_DEVICES,                                 \\\n\t\t(IF_ENABLED(DT_NODE_EXISTS(node_id),                            \\\n\t\t\t\t(Z_DEVICE_EXPORT(node_id);))))\n\n/**\n * @brief Declare a device for each status &quot;okay&quot; devicetree node.\n *\n * @note Disabled nodes should not result in devices, so not predeclaring these\n * keeps drivers honest.\n *\n * This is only &quot;maybe&quot; a device because some nodes have status &quot;okay&quot;, but\n * don&#x27;t have a corresponding @ref device allocated. There&#x27;s no way to figure\n * that out until after we&#x27;ve built the zephyr image, though.\n */\n#define Z_MAYBE_DEVICE_DECLARE_INTERNAL(node_id)                                                   \\\n\textern COND_CODE_1(Z_DEVICE_IS_MUTABLE(node_id), (),                                       \\\n\t\t\t   (const)) struct device DEVICE_DT_NAME_GET(node_id);\n\nDT_FOREACH_STATUS_OKAY_NODE(Z_MAYBE_DEVICE_DECLARE_INTERNAL)\n\n/** @brief Expands to the full type. */\n#define Z_DEVICE_API_TYPE(_class) _CONCAT(_class, _driver_api)\n\n/** @endcond */\n\n/**\n * @brief Wrapper macro for declaring device API structs inside iterable sections.\n *\n * @param _class The device API class.\n * @param _name The API instance name.\n */\n#define DEVICE_API(_class, _name) const STRUCT_SECTION_ITERABLE(Z_DEVICE_API_TYPE(_class), _name)\n\n/**\n * @brief Expands to the pointer of a device&#x27;s API for a given class.\n *\n * @param _class The device API class.\n * @param _dev The device instance pointer.\n *\n * @return the pointer to the device API.\n */\n#define DEVICE_API_GET(_class, _dev) ((const struct Z_DEVICE_API_TYPE(_class) *)_dev-&gt;api)\n\n/**\n * @brief Macro that evaluates to a boolean that can be used to check if\n *        a device is of a particular class.\n *\n * @param _class The device API class.\n * @param _dev The device instance pointer.\n *\n * @retval true If the device is of the given class\n * @retval false If the device is not of the given class\n */\n#define DEVICE_API_IS(_class, _dev)                                                                \\\n\t({                                                                                         \\\n\t\tSTRUCT_SECTION_START_EXTERN(Z_DEVICE_API_TYPE(_class));                            \\\n\t\tSTRUCT_SECTION_END_EXTERN(Z_DEVICE_API_TYPE(_class));                              \\\n\t\t(DEVICE_API_GET(_class, _dev) &lt; STRUCT_SECTION_END(Z_DEVICE_API_TYPE(_class)) &amp;&amp;   \\\n\t\t DEVICE_API_GET(_class, _dev) &gt;= STRUCT_SECTION_START(Z_DEVICE_API_TYPE(_class))); \\\n\t})\n\n#ifdef __cplusplus\n}\n#endif\n\n#include &lt;zephyr/syscalls/device.h&gt;\n\n#endif /* ZEPHYR_INCLUDE_DEVICE_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "content": "/**\n * @file drivers/sensor.h\n *\n * @brief Public APIs for the sensor driver.\n */\n\n/*\n * Copyright (c) 2016 Intel Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n#ifndef ZEPHYR_INCLUDE_DRIVERS_SENSOR_H_\n#define ZEPHYR_INCLUDE_DRIVERS_SENSOR_H_\n\n/**\n * @brief Sensor Interface\n * @defgroup sensor_interface Sensor Interface\n * @since 1.2\n * @version 1.0.0\n * @ingroup io_interfaces\n * @{\n */\n\n#include &lt;errno.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/drivers/sensor_data_types.h&gt;\n#include &lt;zephyr/dsp/types.h&gt;\n#include &lt;zephyr/rtio/rtio.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n#include &lt;zephyr/types.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @brief Representation of a sensor readout value.\n *\n * The value is represented as having an integer and a fractional part,\n * and can be obtained using the formula val1 + val2 * 10^(-6). Negative\n * values also adhere to the above formula, but may need special attention.\n * Here are some examples of the value representation:\n *\n *      0.5: val1 =  0, val2 =  500000\n *     -0.5: val1 =  0, val2 = -500000\n *     -1.0: val1 = -1, val2 =  0\n *     -1.5: val1 = -1, val2 = -500000\n */\nstruct sensor_value {\n\t/** Integer part of the value. */\n\tint32_t val1;\n\t/** Fractional part of the value (in one-millionth parts). */\n\tint32_t val2;\n};\n\n/**\n * @brief Sensor channels.\n */\nenum sensor_channel {\n\t/** Acceleration on the X axis, in m/s^2. */\n\tSENSOR_CHAN_ACCEL_X,\n\t/** Acceleration on the Y axis, in m/s^2. */\n\tSENSOR_CHAN_ACCEL_Y,\n\t/** Acceleration on the Z axis, in m/s^2. */\n\tSENSOR_CHAN_ACCEL_Z,\n\t/** Acceleration on the X, Y and Z axes. */\n\tSENSOR_CHAN_ACCEL_XYZ,\n\t/** Angular velocity around the X axis, in radians/s. */\n\tSENSOR_CHAN_GYRO_X,\n\t/** Angular velocity around the Y axis, in radians/s. */\n\tSENSOR_CHAN_GYRO_Y,\n\t/** Angular velocity around the Z axis, in radians/s. */\n\tSENSOR_CHAN_GYRO_Z,\n\t/** Angular velocity around the X, Y and Z axes. */\n\tSENSOR_CHAN_GYRO_XYZ,\n\t/** Magnetic field on the X axis, in Gauss. */\n\tSENSOR_CHAN_MAGN_X,\n\t/** Magnetic field on the Y axis, in Gauss. */\n\tSENSOR_CHAN_MAGN_Y,\n\t/** Magnetic field on the Z axis, in Gauss. */\n\tSENSOR_CHAN_MAGN_Z,\n\t/** Magnetic field on the X, Y and Z axes. */\n\tSENSOR_CHAN_MAGN_XYZ,\n\t/** Device die temperature in degrees Celsius. */\n\tSENSOR_CHAN_DIE_TEMP,\n\t/** Ambient temperature in degrees Celsius. */\n\tSENSOR_CHAN_AMBIENT_TEMP,\n\t/** Pressure in kilopascal. */\n\tSENSOR_CHAN_PRESS,\n\t/**\n\t * Proximity.  Adimensional.  A value of 1 indicates that an\n\t * object is close.\n\t */\n\tSENSOR_CHAN_PROX,\n\t/** Humidity, in percent. */\n\tSENSOR_CHAN_HUMIDITY,\n\t/** Illuminance in visible spectrum, in lux. */\n\tSENSOR_CHAN_LIGHT,\n\t/** Illuminance in infra-red spectrum, in lux. */\n\tSENSOR_CHAN_IR,\n\t/** Illuminance in red spectrum, in lux. */\n\tSENSOR_CHAN_RED,\n\t/** Illuminance in green spectrum, in lux. */\n\tSENSOR_CHAN_GREEN,\n\t/** Illuminance in blue spectrum, in lux. */\n\tSENSOR_CHAN_BLUE,\n\t/** Altitude, in meters */\n\tSENSOR_CHAN_ALTITUDE,\n\n\t/** 1.0 micro-meters Particulate Matter, in ug/m^3 */\n\tSENSOR_CHAN_PM_1_0,\n\t/** 2.5 micro-meters Particulate Matter, in ug/m^3 */\n\tSENSOR_CHAN_PM_2_5,\n\t/** 10 micro-meters Particulate Matter, in ug/m^3 */\n\tSENSOR_CHAN_PM_10,\n\t/** Distance. From sensor to target, in meters */\n\tSENSOR_CHAN_DISTANCE,\n\n\t/** CO2 level, in parts per million (ppm) **/\n\tSENSOR_CHAN_CO2,\n\t/** O2 level, in parts per million (ppm) **/\n\tSENSOR_CHAN_O2,\n\t/** VOC level, in parts per billion (ppb) **/\n\tSENSOR_CHAN_VOC,\n\t/** Gas sensor resistance in ohms. */\n\tSENSOR_CHAN_GAS_RES,\n\n\t/** Voltage, in volts **/\n\tSENSOR_CHAN_VOLTAGE,\n\n\t/** Current Shunt Voltage in milli-volts **/\n\tSENSOR_CHAN_VSHUNT,\n\n\t/** Current, in amps **/\n\tSENSOR_CHAN_CURRENT,\n\t/** Power in watts **/\n\tSENSOR_CHAN_POWER,\n\n\t/** Resistance , in Ohm **/\n\tSENSOR_CHAN_RESISTANCE,\n\n\t/** Angular rotation, in degrees */\n\tSENSOR_CHAN_ROTATION,\n\n\t/** Position change on the X axis, in points. */\n\tSENSOR_CHAN_POS_DX,\n\t/** Position change on the Y axis, in points. */\n\tSENSOR_CHAN_POS_DY,\n\t/** Position change on the Z axis, in points. */\n\tSENSOR_CHAN_POS_DZ,\n\t/** Position change on the X, Y and Z axis, in points. */\n\tSENSOR_CHAN_POS_DXYZ,\n\n\t/** Revolutions per minute, in RPM. */\n\tSENSOR_CHAN_RPM,\n\n\t/** Frequency, in Hz. */\n\tSENSOR_CHAN_FREQUENCY,\n\n\t/** Voltage, in volts **/\n\tSENSOR_CHAN_GAUGE_VOLTAGE,\n\t/** Average current, in amps (negative=discharging) **/\n\tSENSOR_CHAN_GAUGE_AVG_CURRENT,\n\t/** Standby current, in amps (negative=discharging) **/\n\tSENSOR_CHAN_GAUGE_STDBY_CURRENT,\n\t/** Max load current, in amps (negative=discharging) **/\n\tSENSOR_CHAN_GAUGE_MAX_LOAD_CURRENT,\n\t/** Gauge temperature  **/\n\tSENSOR_CHAN_GAUGE_TEMP,\n\t/** State of charge measurement in % **/\n\tSENSOR_CHAN_GAUGE_STATE_OF_CHARGE,\n\t/** Full Charge Capacity in mAh **/\n\tSENSOR_CHAN_GAUGE_FULL_CHARGE_CAPACITY,\n\t/** Remaining Charge Capacity in mAh **/\n\tSENSOR_CHAN_GAUGE_REMAINING_CHARGE_CAPACITY,\n\t/** Nominal Available Capacity in mAh **/\n\tSENSOR_CHAN_GAUGE_NOM_AVAIL_CAPACITY,\n\t/** Full Available Capacity in mAh **/\n\tSENSOR_CHAN_GAUGE_FULL_AVAIL_CAPACITY,\n\t/** Average power in mW **/\n\tSENSOR_CHAN_GAUGE_AVG_POWER,\n\t/** State of health measurement in % **/\n\tSENSOR_CHAN_GAUGE_STATE_OF_HEALTH,\n\t/** Time to empty in minutes **/\n\tSENSOR_CHAN_GAUGE_TIME_TO_EMPTY,\n\t/** Time to full in minutes **/\n\tSENSOR_CHAN_GAUGE_TIME_TO_FULL,\n\t/** Cycle count (total number of charge/discharge cycles) **/\n\tSENSOR_CHAN_GAUGE_CYCLE_COUNT,\n\t/** Design voltage of cell in V (max voltage)*/\n\tSENSOR_CHAN_GAUGE_DESIGN_VOLTAGE,\n\t/** Desired voltage of cell in V (nominal voltage) */\n\tSENSOR_CHAN_GAUGE_DESIRED_VOLTAGE,\n\t/** Desired charging current in mA */\n\tSENSOR_CHAN_GAUGE_DESIRED_CHARGING_CURRENT,\n\t/** Game Rotation Vector (unit quaternion components X/Y/Z/W) */\n\tSENSOR_CHAN_GAME_ROTATION_VECTOR,\n\t/** Gravity Vector (X/Y/Z components in m/s^2) */\n\tSENSOR_CHAN_GRAVITY_VECTOR,\n\t/** Gyroscope bias (X/Y/Z components in radians/s) */\n\tSENSOR_CHAN_GBIAS_XYZ,\n\n\t/** All channels. */\n\tSENSOR_CHAN_ALL,\n\n\t/**\n\t * Number of all common sensor channels.\n\t */\n\tSENSOR_CHAN_COMMON_COUNT,\n\n\t/**\n\t * This and higher values are sensor specific.\n\t * Refer to the sensor header file.\n\t */\n\tSENSOR_CHAN_PRIV_START = SENSOR_CHAN_COMMON_COUNT,\n\n\t/**\n\t * Maximum value describing a sensor channel type.\n\t */\n\tSENSOR_CHAN_MAX = INT16_MAX,\n};\n\n/**\n * @brief Sensor trigger types.\n */\nenum sensor_trigger_type {\n\t/**\n\t * Timer-based trigger, useful when the sensor does not have an\n\t * interrupt line.\n\t */\n\tSENSOR_TRIG_TIMER,\n\t/** Trigger fires whenever new data is ready. */\n\tSENSOR_TRIG_DATA_READY,\n\t/**\n\t * Trigger fires when the selected channel varies significantly.\n\t * This includes any-motion detection when the channel is\n\t * acceleration or gyro. If detection is based on slope between\n\t * successive channel readings, the slope threshold is configured\n\t * via the @ref SENSOR_ATTR_SLOPE_TH and @ref SENSOR_ATTR_SLOPE_DUR\n\t * attributes.\n\t */\n\tSENSOR_TRIG_DELTA,\n\t/** Trigger fires when a near/far event is detected. */\n\tSENSOR_TRIG_NEAR_FAR,\n\t/**\n\t * Trigger fires when channel reading transitions configured\n\t * thresholds.  The thresholds are configured via the @ref\n\t * SENSOR_ATTR_LOWER_THRESH, @ref SENSOR_ATTR_UPPER_THRESH, and\n\t * @ref SENSOR_ATTR_HYSTERESIS attributes.\n\t */\n\tSENSOR_TRIG_THRESHOLD,\n\n\t/** Trigger fires when a single tap is detected. */\n\tSENSOR_TRIG_TAP,\n\n\t/** Trigger fires when a double tap is detected. */\n\tSENSOR_TRIG_DOUBLE_TAP,\n\n\t/** Trigger fires when a free fall is detected. */\n\tSENSOR_TRIG_FREEFALL,\n\n\t/** Trigger fires when motion is detected. */\n\tSENSOR_TRIG_MOTION,\n\n\t/** Trigger fires when no motion has been detected for a while. */\n\tSENSOR_TRIG_STATIONARY,\n\n\t/** Trigger fires when the FIFO watermark has been reached. */\n\tSENSOR_TRIG_FIFO_WATERMARK,\n\n\t/** Trigger fires when the FIFO becomes full. */\n\tSENSOR_TRIG_FIFO_FULL,\n\t/**\n\t * Number of all common sensor triggers.\n\t */\n\tSENSOR_TRIG_COMMON_COUNT,\n\n\t/**\n\t * This and higher values are sensor specific.\n\t * Refer to the sensor header file.\n\t */\n\tSENSOR_TRIG_PRIV_START = SENSOR_TRIG_COMMON_COUNT,\n\n\t/**\n\t * Maximum value describing a sensor trigger type.\n\t */\n\tSENSOR_TRIG_MAX = INT16_MAX,\n};\n\n/**\n * @brief Sensor trigger spec.\n */\nstruct sensor_trigger {\n\t/** Trigger type. */\n\tenum sensor_trigger_type type;\n\t/** Channel the trigger is set on. */\n\tenum sensor_channel chan;\n};\n\n/**\n * @brief Sensor attribute types.\n */\nenum sensor_attribute {\n\t/**\n\t * Sensor sampling frequency, i.e. how many times a second the\n\t * sensor takes a measurement.\n\t */\n\tSENSOR_ATTR_SAMPLING_FREQUENCY,\n\t/** Lower threshold for trigger. */\n\tSENSOR_ATTR_LOWER_THRESH,\n\t/** Upper threshold for trigger. */\n\tSENSOR_ATTR_UPPER_THRESH,\n\t/** Threshold for any-motion (slope) trigger. */\n\tSENSOR_ATTR_SLOPE_TH,\n\t/**\n\t * Duration for which the slope values needs to be\n\t * outside the threshold for the trigger to fire.\n\t */\n\tSENSOR_ATTR_SLOPE_DUR,\n\t/* Hysteresis for trigger thresholds. */\n\tSENSOR_ATTR_HYSTERESIS,\n\t/** Oversampling factor */\n\tSENSOR_ATTR_OVERSAMPLING,\n\t/** Sensor range, in SI units. */\n\tSENSOR_ATTR_FULL_SCALE,\n\t/**\n\t * The sensor value returned will be altered by the amount indicated by\n\t * offset: final_value = sensor_value + offset.\n\t */\n\tSENSOR_ATTR_OFFSET,\n\t/**\n\t * Calibration target. This will be used by the internal chip&#x27;s\n\t * algorithms to calibrate itself on a certain axis, or all of them.\n\t */\n\tSENSOR_ATTR_CALIB_TARGET,\n\t/** Configure the operating modes of a sensor. */\n\tSENSOR_ATTR_CONFIGURATION,\n\t/** Set a calibration value needed by a sensor. */\n\tSENSOR_ATTR_CALIBRATION,\n\t/** Enable/disable sensor features */\n\tSENSOR_ATTR_FEATURE_MASK,\n\t/** Alert threshold or alert enable/disable */\n\tSENSOR_ATTR_ALERT,\n\t/** Free-fall duration represented in milliseconds.\n\t *  If the sampling frequency is changed during runtime,\n\t *  this attribute should be set to adjust freefall duration\n\t *  to the new sampling frequency.\n\t */\n\tSENSOR_ATTR_FF_DUR,\n\n\t/** Hardware batch duration in ticks */\n\tSENSOR_ATTR_BATCH_DURATION,\n\t/* Configure the gain of a sensor. */\n\tSENSOR_ATTR_GAIN,\n\t/* Configure the resolution of a sensor. */\n\tSENSOR_ATTR_RESOLUTION,\n\t/**\n\t * Number of all common sensor attributes.\n\t */\n\tSENSOR_ATTR_COMMON_COUNT,\n\n\t/**\n\t * This and higher values are sensor specific.\n\t * Refer to the sensor header file.\n\t */\n\tSENSOR_ATTR_PRIV_START = SENSOR_ATTR_COMMON_COUNT,\n\n\t/**\n\t * Maximum value describing a sensor attribute type.\n\t */\n\tSENSOR_ATTR_MAX = INT16_MAX,\n};\n\n/**\n * @typedef sensor_trigger_handler_t\n * @brief Callback API upon firing of a trigger\n *\n * @param dev Pointer to the sensor device\n * @param trigger The trigger\n */\ntypedef void (*sensor_trigger_handler_t)(const struct device *dev,\n\t\t\t\t\t const struct sensor_trigger *trigger);\n\n/**\n * @typedef sensor_attr_set_t\n * @brief Callback API upon setting a sensor&#x27;s attributes\n *\n * See sensor_attr_set() for argument description\n */\ntypedef int (*sensor_attr_set_t)(const struct device *dev,\n\t\t\t\t enum sensor_channel chan,\n\t\t\t\t enum sensor_attribute attr,\n\t\t\t\t const struct sensor_value *val);\n\n/**\n * @typedef sensor_attr_get_t\n * @brief Callback API upon getting a sensor&#x27;s attributes\n *\n * See sensor_attr_get() for argument description\n */\ntypedef int (*sensor_attr_get_t)(const struct device *dev,\n\t\t\t\t enum sensor_channel chan,\n\t\t\t\t enum sensor_attribute attr,\n\t\t\t\t struct sensor_value *val);\n\n/**\n * @typedef sensor_trigger_set_t\n * @brief Callback API for setting a sensor&#x27;s trigger and handler\n *\n * See sensor_trigger_set() for argument description\n */\ntypedef int (*sensor_trigger_set_t)(const struct device *dev,\n\t\t\t\t    const struct sensor_trigger *trig,\n\t\t\t\t    sensor_trigger_handler_t handler);\n/**\n * @typedef sensor_sample_fetch_t\n * @brief Callback API for fetching data from a sensor\n *\n * See sensor_sample_fetch() for argument description\n */\ntypedef int (*sensor_sample_fetch_t)(const struct device *dev,\n\t\t\t\t     enum sensor_channel chan);\n/**\n * @typedef sensor_channel_get_t\n * @brief Callback API for getting a reading from a sensor\n *\n * See sensor_channel_get() for argument description\n */\ntypedef int (*sensor_channel_get_t)(const struct device *dev,\n\t\t\t\t    enum sensor_channel chan,\n\t\t\t\t    struct sensor_value *val);\n\n/**\n * @brief Sensor Channel Specification\n *\n * A sensor channel specification is a unique identifier per sensor device describing\n * a measurement channel.\n *\n * @note Typically passed by value as the size of a sensor_chan_spec is a single word.\n */\nstruct sensor_chan_spec {\n\tuint16_t chan_type; /**&lt; A sensor channel type */\n\tuint16_t chan_idx;  /**&lt; A sensor channel index */\n};\n\n/** @cond INTERNAL_HIDDEN */\n/* Ensure sensor_chan_spec is sensibly sized to pass by value */\nBUILD_ASSERT(sizeof(struct sensor_chan_spec) &lt;= sizeof(uintptr_t),\n\t     &quot;sensor_chan_spec size should be equal or less than the size of a machine word&quot;);\n/** @endcond */\n\n/**\n * @brief Check if channel specs are equivalent\n *\n * @param chan_spec0 First chan spec\n * @param chan_spec1 Second chan spec\n * @retval true If equivalent\n * @retval false If not equivalent\n */\nstatic inline bool sensor_chan_spec_eq(struct sensor_chan_spec chan_spec0,\n\t\t\t\t       struct sensor_chan_spec chan_spec1)\n{\n\treturn chan_spec0.chan_type == chan_spec1.chan_type &amp;&amp;\n\t\tchan_spec0.chan_idx == chan_spec1.chan_idx;\n}\n\n/**\n * @brief Decodes a single raw data buffer\n *\n * Data buffers are provided on the @ref rtio context that&#x27;s supplied to\n * @ref sensor_read.\n */\nstruct sensor_decoder_api {\n\t/**\n\t * @brief Get the number of frames in the current buffer.\n\t *\n\t * @param[in]  buffer The buffer provided on the @ref rtio context.\n\t * @param[in]  channel The channel to get the count for\n\t * @param[out] frame_count The number of frames on the buffer (at least 1)\n\t * @return 0 on success\n\t * @return -ENOTSUP if the channel/channel_idx aren&#x27;t found\n\t */\n\tint (*get_frame_count)(const uint8_t *buffer, struct sensor_chan_spec channel,\n\t\t\t       uint16_t *frame_count);\n\n\t/**\n\t * @brief Get the size required to decode a given channel\n\t *\n\t * When decoding a single frame, use @p base_size. For every additional frame, add another\n\t * @p frame_size. As an example, to decode 3 frames use: &#x27;base_size + 2 * frame_size&#x27;.\n\t *\n\t * @param[in]  channel The channel to query\n\t * @param[out] base_size The size of decoding the first frame\n\t * @param[out] frame_size The additional size of every additional frame\n\t * @return 0 on success\n\t * @return -ENOTSUP if the channel is not supported\n\t */\n\tint (*get_size_info)(struct sensor_chan_spec channel, size_t *base_size,\n\t\t\t     size_t *frame_size);\n\n\t/**\n\t * @brief Decode up to @p max_count samples from the buffer\n\t *\n\t * Decode samples of channel @ref sensor_channel across multiple frames. If there exist\n\t * multiple instances of the same channel, @p channel_index is used to differentiate them.\n\t * As an example, assume a sensor provides 2 distance measurements:\n\t *\n\t * @code{.c}\n\t * // Decode the first channel instance of &#x27;distance&#x27;\n\t * decoder-&gt;decode(buffer, SENSOR_CHAN_DISTANCE, 0, &amp;fit, 5, out);\n\t * ...\n\t *\n\t * // Decode the second channel instance of &#x27;distance&#x27;\n\t * decoder-&gt;decode(buffer, SENSOR_CHAN_DISTANCE, 1, &amp;fit, 5, out);\n\t * @endcode\n\t *\n\t * @param[in]     buffer The buffer provided on the @ref rtio context\n\t * @param[in]     channel The channel to decode\n\t * @param[in,out] fit The current frame iterator\n\t * @param[in]     max_count The maximum number of channels to decode.\n\t * @param[out]    data_out The decoded data\n\t * @return 0 no more samples to decode\n\t * @return &gt;0 the number of decoded frames\n\t * @return &lt;0 on error\n\t */\n\tint (*decode)(const uint8_t *buffer, struct sensor_chan_spec channel, uint32_t *fit,\n\t\t      uint16_t max_count, void *data_out);\n\n\t/**\n\t * @brief Check if the given trigger type is present\n\t *\n\t * @param[in] buffer The buffer provided on the @ref rtio context\n\t * @param[in] trigger The trigger type in question\n\t * @return Whether the trigger is present in the buffer\n\t */\n\tbool (*has_trigger)(const uint8_t *buffer, enum sensor_trigger_type trigger);\n};\n\n/**\n * @brief Used for iterating over the data frames via the sensor_decoder_api.\n *\n * Example usage:\n *\n * @code(.c)\n *     struct sensor_decode_context ctx = SENSOR_DECODE_CONTEXT_INIT(\n *         decoder, buffer, SENSOR_CHAN_ACCEL_XYZ, 0);\n *\n *     while (true) {\n *       struct sensor_three_axis_data accel_out_data;\n *\n *       num_decoded_channels = sensor_decode(ctx, &amp;accel_out_data, 1);\n *\n *       if (num_decoded_channels &lt;= 0) {\n *         printk(&quot;Done decoding buffer\\n&quot;);\n *         break;\n *       }\n *\n *       printk(&quot;Decoded (%&quot; PRId32 &quot;, %&quot; PRId32 &quot;, %&quot; PRId32 &quot;)\\n&quot;, accel_out_data.readings[0].x,\n *           accel_out_data.readings[0].y, accel_out_data.readings[0].z);\n *     }\n * @endcode\n */\nstruct sensor_decode_context {\n\tconst struct sensor_decoder_api *decoder;\n\tconst uint8_t *buffer;\n\tstruct sensor_chan_spec channel;\n\tuint32_t fit;\n};\n\n/**\n * @brief Initialize a sensor_decode_context\n */\n#define SENSOR_DECODE_CONTEXT_INIT(decoder_, buffer_, channel_type_, channel_index_)               \\\n\t{                                                                                          \\\n\t\t.decoder = (decoder_),                                                             \\\n\t\t.buffer = (buffer_),                                                               \\\n\t\t.channel = {.chan_type = (channel_type_), .chan_idx = (channel_index_)},           \\\n\t\t.fit = 0,                                                                          \\\n\t}\n\n/**\n * @brief Decode N frames using a sensor_decode_context\n *\n * @param[in,out] ctx The context to use for decoding\n * @param[out]    out The output buffer\n * @param[in]     max_count Maximum number of frames to decode\n * @return The decode result from sensor_decoder_api&#x27;s decode function\n */\nstatic inline int sensor_decode(struct sensor_decode_context *ctx, void *out, uint16_t max_count)\n{\n\treturn ctx-&gt;decoder-&gt;decode(ctx-&gt;buffer, ctx-&gt;channel, &amp;ctx-&gt;fit, max_count, out);\n}\n\nint sensor_natively_supported_channel_size_info(struct sensor_chan_spec channel, size_t *base_size,\n\t\t\t\t\t\tsize_t *frame_size);\n\n/**\n * @typedef sensor_get_decoder_t\n * @brief Get the decoder associate with the given device\n *\n * @see sensor_get_decoder for more details\n */\ntypedef int (*sensor_get_decoder_t)(const struct device *dev,\n\t\t\t\t    const struct sensor_decoder_api **api);\n\n/**\n * @brief Options for what to do with the associated data when a trigger is consumed\n */\nenum sensor_stream_data_opt {\n\t/** @brief Include whatever data is associated with the trigger */\n\tSENSOR_STREAM_DATA_INCLUDE = 0,\n\t/** @brief Do nothing with the associated trigger data, it may be consumed later */\n\tSENSOR_STREAM_DATA_NOP = 1,\n\t/** @brief Flush/clear whatever data is associated with the trigger */\n\tSENSOR_STREAM_DATA_DROP = 2,\n};\n\nstruct sensor_stream_trigger {\n\tenum sensor_trigger_type trigger;\n\tenum sensor_stream_data_opt opt;\n};\n\n#define SENSOR_STREAM_TRIGGER_PREP(_trigger, _opt)                                                 \\\n\t{                                                                                          \\\n\t\t.trigger = (_trigger), .opt = (_opt),                                              \\\n\t}\n\n/*\n * Internal data structure used to store information about the IODevice for async reading and\n * streaming sensor data.\n */\nstruct sensor_read_config {\n\tconst struct device *sensor;\n\tconst bool is_streaming;\n\tunion {\n\t\tstruct sensor_chan_spec *const channels;\n\t\tstruct sensor_stream_trigger *const triggers;\n\t};\n\tsize_t count;\n\tconst size_t max;\n};\n\n/**\n * @brief Define a reading instance of a sensor\n *\n * Use this macro to generate a @ref rtio_iodev for reading specific channels. Example:\n *\n * @code(.c)\n * SENSOR_DT_READ_IODEV(icm42688_accelgyro, DT_NODELABEL(icm42688),\n *     { SENSOR_CHAN_ACCEL_XYZ, 0 },\n *     { SENSOR_CHAN_GYRO_XYZ, 0 });\n *\n * int main(void) {\n *   sensor_read_async_mempool(&amp;icm42688_accelgyro, &amp;rtio);\n * }\n * @endcode\n */\n#define SENSOR_DT_READ_IODEV(name, dt_node, ...)                                                   \\\n\tstatic struct sensor_chan_spec _CONCAT(__channel_array_, name)[] = {__VA_ARGS__};          \\\n\tstatic struct sensor_read_config _CONCAT(__sensor_read_config_, name) = {                  \\\n\t\t.sensor = DEVICE_DT_GET(dt_node),                                                  \\\n\t\t.is_streaming = false,                                                             \\\n\t\t.channels = _CONCAT(__channel_array_, name),                                       \\\n\t\t.count = ARRAY_SIZE(_CONCAT(__channel_array_, name)),                              \\\n\t\t.max = ARRAY_SIZE(_CONCAT(__channel_array_, name)),                                \\\n\t};                                                                                         \\\n\tRTIO_IODEV_DEFINE(name, &amp;__sensor_iodev_api, _CONCAT(&amp;__sensor_read_config_, name))\n\n/**\n * @brief Define a stream instance of a sensor\n *\n * Use this macro to generate a @ref rtio_iodev for starting a stream that&#x27;s triggered by specific\n * interrupts. Example:\n *\n * @code(.c)\n * SENSOR_DT_STREAM_IODEV(imu_stream, DT_ALIAS(imu),\n *     {SENSOR_TRIG_FIFO_WATERMARK, SENSOR_STREAM_DATA_INCLUDE},\n *     {SENSOR_TRIG_FIFO_FULL, SENSOR_STREAM_DATA_NOP});\n *\n * int main(void) {\n *   struct rtio_sqe *handle;\n *   sensor_stream(&amp;imu_stream, &amp;rtio, NULL, &amp;handle);\n *   k_msleep(1000);\n *   rtio_sqe_cancel(handle);\n * }\n * @endcode\n */\n#define SENSOR_DT_STREAM_IODEV(name, dt_node, ...)                                                 \\\n\tstatic struct sensor_stream_trigger _CONCAT(__trigger_array_, name)[] = {__VA_ARGS__};     \\\n\tstatic struct sensor_read_config _CONCAT(__sensor_read_config_, name) = {                  \\\n\t\t.sensor = DEVICE_DT_GET(dt_node),                                                  \\\n\t\t.is_streaming = true,                                                              \\\n\t\t.triggers = _CONCAT(__trigger_array_, name),                                       \\\n\t\t.count = ARRAY_SIZE(_CONCAT(__trigger_array_, name)),                              \\\n\t\t.max = ARRAY_SIZE(_CONCAT(__trigger_array_, name)),                                \\\n\t};                                                                                         \\\n\tRTIO_IODEV_DEFINE(name, &amp;__sensor_iodev_api, &amp;_CONCAT(__sensor_read_config_, name))\n\n/* Used to submit an RTIO sqe to the sensor&#x27;s iodev */\ntypedef void (*sensor_submit_t)(const struct device *sensor, struct rtio_iodev_sqe *sqe);\n\n/* The default decoder API */\nextern const struct sensor_decoder_api __sensor_default_decoder;\n\n/* The default sensor iodev API */\nextern const struct rtio_iodev_api __sensor_iodev_api;\n\n__subsystem struct sensor_driver_api {\n\tsensor_attr_set_t attr_set;\n\tsensor_attr_get_t attr_get;\n\tsensor_trigger_set_t trigger_set;\n\tsensor_sample_fetch_t sample_fetch;\n\tsensor_channel_get_t channel_get;\n\tsensor_get_decoder_t get_decoder;\n\tsensor_submit_t submit;\n};\n\n/**\n * @brief Set an attribute for a sensor\n *\n * @param dev Pointer to the sensor device\n * @param chan The channel the attribute belongs to, if any.  Some\n * attributes may only be set for all channels of a device, depending on\n * device capabilities.\n * @param attr The attribute to set\n * @param val The value to set the attribute to\n *\n * @return 0 if successful, negative errno code if failure.\n */\n__syscall int sensor_attr_set(const struct device *dev,\n\t\t\t      enum sensor_channel chan,\n\t\t\t      enum sensor_attribute attr,\n\t\t\t      const struct sensor_value *val);\n\nstatic inline int z_impl_sensor_attr_set(const struct device *dev,\n\t\t\t\t\t enum sensor_channel chan,\n\t\t\t\t\t enum sensor_attribute attr,\n\t\t\t\t\t const struct sensor_value *val)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\tif (api-&gt;attr_set == NULL) {\n\t\treturn -ENOSYS;\n\t}\n\n\treturn api-&gt;attr_set(dev, chan, attr, val);\n}\n\n/**\n * @brief Get an attribute for a sensor\n *\n * @param dev Pointer to the sensor device\n * @param chan The channel the attribute belongs to, if any.  Some\n * attributes may only be set for all channels of a device, depending on\n * device capabilities.\n * @param attr The attribute to get\n * @param val Pointer to where to store the attribute\n *\n * @return 0 if successful, negative errno code if failure.\n */\n__syscall int sensor_attr_get(const struct device *dev,\n\t\t\t      enum sensor_channel chan,\n\t\t\t      enum sensor_attribute attr,\n\t\t\t      struct sensor_value *val);\n\nstatic inline int z_impl_sensor_attr_get(const struct device *dev,\n\t\t\t\t\t enum sensor_channel chan,\n\t\t\t\t\t enum sensor_attribute attr,\n\t\t\t\t\t struct sensor_value *val)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\tif (api-&gt;attr_get == NULL) {\n\t\treturn -ENOSYS;\n\t}\n\n\treturn api-&gt;attr_get(dev, chan, attr, val);\n}\n\n/**\n * @brief Activate a sensor&#x27;s trigger and set the trigger handler\n *\n * The handler will be called from a thread, so I2C or SPI operations are\n * safe.  However, the thread&#x27;s stack is limited and defined by the\n * driver.  It is currently up to the caller to ensure that the handler\n * does not overflow the stack.\n *\n * The user-allocated trigger will be stored by the driver as a pointer, rather\n * than a copy, and passed back to the handler. This enables the handler to use\n * CONTAINER_OF to retrieve a context pointer when the trigger is embedded in a\n * larger struct and requires that the trigger is not allocated on the stack.\n *\n * @funcprops \\supervisor\n *\n * @param dev Pointer to the sensor device\n * @param trig The trigger to activate\n * @param handler The function that should be called when the trigger\n * fires\n *\n * @return 0 if successful, negative errno code if failure.\n */\nstatic inline int sensor_trigger_set(const struct device *dev,\n\t\t\t\t     const struct sensor_trigger *trig,\n\t\t\t\t     sensor_trigger_handler_t handler)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\tif (api-&gt;trigger_set == NULL) {\n\t\treturn -ENOSYS;\n\t}\n\n\treturn api-&gt;trigger_set(dev, trig, handler);\n}\n\n/**\n * @brief Fetch a sample from the sensor and store it in an internal\n * driver buffer\n *\n * Read all of a sensor&#x27;s active channels and, if necessary, perform any\n * additional operations necessary to make the values useful.  The user\n * may then get individual channel values by calling @ref\n * sensor_channel_get.\n *\n * The function blocks until the fetch operation is complete.\n *\n * Since the function communicates with the sensor device, it is unsafe\n * to call it in an ISR if the device is connected via I2C or SPI.\n *\n * @param dev Pointer to the sensor device\n *\n * @return 0 if successful, negative errno code if failure.\n */\n__syscall int sensor_sample_fetch(const struct device *dev);\n\nstatic inline int z_impl_sensor_sample_fetch(const struct device *dev)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\treturn api-&gt;sample_fetch(dev, SENSOR_CHAN_ALL);\n}\n\n/**\n * @brief Fetch a sample from the sensor and store it in an internal\n * driver buffer\n *\n * Read and compute compensation for one type of sensor data (magnetometer,\n * accelerometer, etc). The user may then get individual channel values by\n * calling @ref sensor_channel_get.\n *\n * This is mostly implemented by multi function devices enabling reading at\n * different sampling rates.\n *\n * The function blocks until the fetch operation is complete.\n *\n * Since the function communicates with the sensor device, it is unsafe\n * to call it in an ISR if the device is connected via I2C or SPI.\n *\n * @param dev Pointer to the sensor device\n * @param type The channel that needs updated\n *\n * @return 0 if successful, negative errno code if failure.\n */\n__syscall int sensor_sample_fetch_chan(const struct device *dev,\n\t\t\t\t       enum sensor_channel type);\n\nstatic inline int z_impl_sensor_sample_fetch_chan(const struct device *dev,\n\t\t\t\t\t\t  enum sensor_channel type)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\treturn api-&gt;sample_fetch(dev, type);\n}\n\n/**\n * @brief Get a reading from a sensor device\n *\n * Return a useful value for a particular channel, from the driver&#x27;s\n * internal data.  Before calling this function, a sample must be\n * obtained by calling @ref sensor_sample_fetch or\n * @ref sensor_sample_fetch_chan. It is guaranteed that two subsequent\n * calls of this function for the same channels will yield the same\n * value, if @ref sensor_sample_fetch or @ref sensor_sample_fetch_chan\n * has not been called in the meantime.\n *\n * For vectorial data samples you can request all axes in just one call\n * by passing the specific channel with _XYZ suffix. The sample will be\n * returned at val[0], val[1] and val[2] (X, Y and Z in that order).\n *\n * @param dev Pointer to the sensor device\n * @param chan The channel to read\n * @param val Where to store the value\n *\n * @return 0 if successful, negative errno code if failure.\n */\n__syscall int sensor_channel_get(const struct device *dev,\n\t\t\t\t enum sensor_channel chan,\n\t\t\t\t struct sensor_value *val);\n\nstatic inline int z_impl_sensor_channel_get(const struct device *dev,\n\t\t\t\t\t    enum sensor_channel chan,\n\t\t\t\t\t    struct sensor_value *val)\n{\n\tconst struct sensor_driver_api *api =\n\t\t(const struct sensor_driver_api *)dev-&gt;api;\n\n\treturn api-&gt;channel_get(dev, chan, val);\n}\n\n#if defined(CONFIG_SENSOR_ASYNC_API) || defined(__DOXYGEN__)\n\n/*\n * Generic data structure used for encoding the sample timestamp and number of channels sampled.\n */\nstruct __attribute__((__packed__)) sensor_data_generic_header {\n\t/* The timestamp at which the data was collected from the sensor */\n\tuint64_t timestamp_ns;\n\n\t/*\n\t * The number of channels present in the frame. This will be the true number of elements in\n\t * channel_info and in the q31 values that follow the header.\n\t */\n\tuint32_t num_channels;\n\n\t/* Shift value for all samples in the frame */\n\tint8_t shift;\n\n\t/* This padding is needed to make sure that the &#x27;channels&#x27; field is aligned */\n\tint8_t _padding[sizeof(struct sensor_chan_spec) - 1];\n\n\t/* Channels present in the frame */\n\tstruct sensor_chan_spec channels[0];\n};\n\n/**\n * @brief checks if a given channel is a 3-axis channel\n *\n * @param[in] chan The channel to check\n * @retval true if @p chan is any of @ref SENSOR_CHAN_ACCEL_XYZ, @ref SENSOR_CHAN_GYRO_XYZ, or\n *         @ref SENSOR_CHAN_MAGN_XYZ, or @ref SENSOR_CHAN_POS_DXYZ\n * @retval false otherwise\n */\n#define SENSOR_CHANNEL_3_AXIS(chan)                                                                \\\n\t((chan) == SENSOR_CHAN_ACCEL_XYZ || (chan) == SENSOR_CHAN_GYRO_XYZ ||                      \\\n\t (chan) == SENSOR_CHAN_MAGN_XYZ || (chan) == SENSOR_CHAN_POS_DXYZ)\n\n/**\n * @brief checks if a given channel is an Accelerometer\n *\n * @param[in] chan The channel to check\n * @retval true if @p chan is any of @ref SENSOR_CHAN_ACCEL_XYZ, @ref SENSOR_CHAN_ACCEL_X, or\n *         @ref SENSOR_CHAN_ACCEL_Y, or @ref SENSOR_CHAN_ACCEL_Z\n * @retval false otherwise\n */\n#define SENSOR_CHANNEL_IS_ACCEL(chan)                                          \\\n\t((chan) == SENSOR_CHAN_ACCEL_XYZ || (chan) == SENSOR_CHAN_ACCEL_X ||   \\\n\t (chan) == SENSOR_CHAN_ACCEL_Y || (chan) == SENSOR_CHAN_ACCEL_Z)\n\n/**\n * @brief checks if a given channel is a Gyroscope\n *\n * @param[in] chan The channel to check\n * @retval true if @p chan is any of @ref SENSOR_CHAN_GYRO_XYZ, @ref SENSOR_CHAN_GYRO_X, or\n *         @ref SENSOR_CHAN_GYRO_Y, or @ref SENSOR_CHAN_GYRO_Z\n * @retval false otherwise\n */\n#define SENSOR_CHANNEL_IS_GYRO(chan)                                           \\\n\t((chan) == SENSOR_CHAN_GYRO_XYZ || (chan) == SENSOR_CHAN_GYRO_X ||     \\\n\t (chan) == SENSOR_CHAN_GYRO_Y || (chan) == SENSOR_CHAN_GYRO_Z)\n\n/**\n * @brief Get the sensor&#x27;s decoder API\n *\n * @param[in] dev The sensor device\n * @param[in] decoder Pointer to the decoder which will be set upon success\n * @return 0 on success\n * @return &lt; 0 on error\n */\n__syscall int sensor_get_decoder(const struct device *dev,\n\t\t\t\t const struct sensor_decoder_api **decoder);\n\nstatic inline int z_impl_sensor_get_decoder(const struct device *dev,\n\t\t\t\t\t    const struct sensor_decoder_api **decoder)\n{\n\tconst struct sensor_driver_api *api = (const struct sensor_driver_api *)dev-&gt;api;\n\n\t__ASSERT_NO_MSG(api != NULL);\n\n\tif (api-&gt;get_decoder == NULL) {\n\t\t*decoder = &amp;__sensor_default_decoder;\n\t\treturn 0;\n\t}\n\n\treturn api-&gt;get_decoder(dev, decoder);\n}\n\n/**\n * @brief Reconfigure a reading iodev\n *\n * Allows a reconfiguration of the iodev associated with reading a sample from a sensor.\n *\n * &lt;b&gt;Important&lt;/b&gt;: If the iodev is currently servicing a read operation, the data will likely be\n * invalid. Please be sure the flush or wait for all pending operations to complete before using the\n * data after a configuration change.\n *\n * It is also important that the `data` field of the iodev is a @ref sensor_read_config.\n *\n * @param[in] iodev The iodev to reconfigure\n * @param[in] sensor The sensor to read from\n * @param[in] channels One or more channels to read\n * @param[in] num_channels The number of channels in @p channels\n * @return 0 on success\n * @return &lt; 0 on error\n */\n__syscall int sensor_reconfigure_read_iodev(struct rtio_iodev *iodev, const struct device *sensor,\n\t\t\t\t\t    const struct sensor_chan_spec *channels,\n\t\t\t\t\t    size_t num_channels);\n\nstatic inline int z_impl_sensor_reconfigure_read_iodev(struct rtio_iodev *iodev,\n\t\t\t\t\t\t       const struct device *sensor,\n\t\t\t\t\t\t       const struct sensor_chan_spec *channels,\n\t\t\t\t\t\t       size_t num_channels)\n{\n\tstruct sensor_read_config *cfg = (struct sensor_read_config *)iodev-&gt;data;\n\n\tif (cfg-&gt;max &lt; num_channels || cfg-&gt;is_streaming) {\n\t\treturn -ENOMEM;\n\t}\n\n\tcfg-&gt;sensor = sensor;\n\tmemcpy(cfg-&gt;channels, channels, num_channels * sizeof(struct sensor_chan_spec));\n\tcfg-&gt;count = num_channels;\n\treturn 0;\n}\n\nstatic inline int sensor_stream(struct rtio_iodev *iodev, struct rtio *ctx, void *userdata,\n\t\t\t\tstruct rtio_sqe **handle)\n{\n\tif (IS_ENABLED(CONFIG_USERSPACE)) {\n\t\tstruct rtio_sqe sqe;\n\n\t\trtio_sqe_prep_read_multishot(&amp;sqe, iodev, RTIO_PRIO_NORM, userdata);\n\t\trtio_sqe_copy_in_get_handles(ctx, &amp;sqe, handle, 1);\n\t} else {\n\t\tstruct rtio_sqe *sqe = rtio_sqe_acquire(ctx);\n\n\t\tif (sqe == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (handle != NULL) {\n\t\t\t*handle = sqe;\n\t\t}\n\t\trtio_sqe_prep_read_multishot(sqe, iodev, RTIO_PRIO_NORM, userdata);\n\t}\n\trtio_submit(ctx, 0);\n\treturn 0;\n}\n\n/**\n * @brief Blocking one shot read of samples from a sensor into a buffer\n *\n * Using @p cfg, read data from the device by using the provided RTIO context\n * @p ctx. This call will generate a @ref rtio_sqe that will be given the provided buffer. The call\n * will wait for the read to complete before returning to the caller.\n *\n * @param[in] iodev The iodev created by @ref SENSOR_DT_READ_IODEV\n * @param[in] ctx The RTIO context to service the read\n * @param[in] buf Pointer to memory to read sample data into\n * @param[in] buf_len Size in bytes of the given memory that are valid to read into\n * @return 0 on success\n * @return &lt; 0 on error\n */\nstatic inline int sensor_read(struct rtio_iodev *iodev, struct rtio *ctx, uint8_t *buf,\n\t\t\t      size_t buf_len)\n{\n\tif (IS_ENABLED(CONFIG_USERSPACE)) {\n\t\tstruct rtio_sqe sqe;\n\n\t\trtio_sqe_prep_read(&amp;sqe, iodev, RTIO_PRIO_NORM, buf, buf_len, buf);\n\t\trtio_sqe_copy_in(ctx, &amp;sqe, 1);\n\t} else {\n\t\tstruct rtio_sqe *sqe = rtio_sqe_acquire(ctx);\n\n\t\tif (sqe == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trtio_sqe_prep_read(sqe, iodev, RTIO_PRIO_NORM, buf, buf_len, buf);\n\t}\n\trtio_submit(ctx, 0);\n\n\tstruct rtio_cqe *cqe = rtio_cqe_consume_block(ctx);\n\tint res = cqe-&gt;result;\n\n\t__ASSERT(cqe-&gt;userdata == buf,\n\t\t &quot;consumed non-matching completion for sensor read into buffer %p\\n&quot;, buf);\n\n\trtio_cqe_release(ctx, cqe);\n\n\treturn res;\n}\n\n/**\n * @brief One shot non-blocking read with pool allocated buffer\n *\n * Using @p cfg, read one snapshot of data from the device by using the provided RTIO context\n * @p ctx. This call will generate a @ref rtio_sqe that will leverage the RTIO&#x27;s internal\n * mempool when the time comes to service the read.\n *\n * @param[in] iodev The iodev created by @ref SENSOR_DT_READ_IODEV\n * @param[in] ctx The RTIO context to service the read\n * @param[in] userdata Optional userdata that will be available when the read is complete\n * @return 0 on success\n * @return &lt; 0 on error\n */\nstatic inline int sensor_read_async_mempool(struct rtio_iodev *iodev, struct rtio *ctx,\n\t\t\t\t\t    void *userdata)\n{\n\tif (IS_ENABLED(CONFIG_USERSPACE)) {\n\t\tstruct rtio_sqe sqe;\n\n\t\trtio_sqe_prep_read_with_pool(&amp;sqe, iodev, RTIO_PRIO_NORM, userdata);\n\t\trtio_sqe_copy_in(ctx, &amp;sqe, 1);\n\t} else {\n\t\tstruct rtio_sqe *sqe = rtio_sqe_acquire(ctx);\n\n\t\tif (sqe == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trtio_sqe_prep_read_with_pool(sqe, iodev, RTIO_PRIO_NORM, userdata);\n\t}\n\trtio_submit(ctx, 0);\n\treturn 0;\n}\n\n/**\n * @typedef sensor_processing_callback_t\n * @brief Callback function used with the helper processing function.\n *\n * @see sensor_processing_with_callback\n *\n * @param[in] result The result code of the read (0 being success)\n * @param[in] buf The data buffer holding the sensor data\n * @param[in] buf_len The length (in bytes) of the @p buf\n * @param[in] userdata The optional userdata passed to sensor_read_async_mempool()\n */\ntypedef void (*sensor_processing_callback_t)(int result, uint8_t *buf, uint32_t buf_len,\n\t\t\t\t\t     void *userdata);\n\n/**\n * @brief Helper function for common processing of sensor data.\n *\n * This function can be called in a blocking manner after sensor_read() or in a standalone\n * thread dedicated to processing. It will wait for a cqe from the RTIO context, once received, it\n * will decode the userdata and call the @p cb. Once the @p cb returns, the buffer will be released\n * back into @p ctx&#x27;s mempool if available.\n *\n * @param[in] ctx The RTIO context to wait on\n * @param[in] cb Callback to call when data is ready for processing\n */\nvoid sensor_processing_with_callback(struct rtio *ctx, sensor_processing_callback_t cb);\n\n#endif /* defined(CONFIG_SENSOR_ASYNC_API) || defined(__DOXYGEN__) */\n\n/**\n * @brief The value of gravitational constant in micro m/s^2.\n */\n#define SENSOR_G\t\t9806650LL\n\n/**\n * @brief The value of constant PI in micros.\n */\n#define SENSOR_PI\t\t3141592LL\n\n/**\n * @brief Helper function to convert acceleration from m/s^2 to Gs\n *\n * @param ms2 A pointer to a sensor_value struct holding the acceleration,\n *            in m/s^2.\n *\n * @return The converted value, in Gs.\n */\nstatic inline int32_t sensor_ms2_to_g(const struct sensor_value *ms2)\n{\n\tint64_t micro_ms2 = ms2-&gt;val1 * 1000000LL + ms2-&gt;val2;\n\n\tif (micro_ms2 &gt; 0) {\n\t\treturn (micro_ms2 + SENSOR_G / 2) / SENSOR_G;\n\t} else {\n\t\treturn (micro_ms2 - SENSOR_G / 2) / SENSOR_G;\n\t}\n}\n\n/**\n * @brief Helper function to convert acceleration from Gs to m/s^2\n *\n * @param g The G value to be converted.\n * @param ms2 A pointer to a sensor_value struct, where the result is stored.\n */\nstatic inline void sensor_g_to_ms2(int32_t g, struct sensor_value *ms2)\n{\n\tms2-&gt;val1 = ((int64_t)g * SENSOR_G) / 1000000LL;\n\tms2-&gt;val2 = ((int64_t)g * SENSOR_G) % 1000000LL;\n}\n\n/**\n * @brief Helper function to convert acceleration from m/s^2 to milli Gs\n *\n * @param ms2 A pointer to a sensor_value struct holding the acceleration,\n *            in m/s^2.\n *\n * @return The converted value, in milli Gs.\n */\nstatic inline int32_t sensor_ms2_to_mg(const struct sensor_value *ms2)\n{\n\tint64_t nano_ms2 = (ms2-&gt;val1 * 1000000LL + ms2-&gt;val2) * 1000LL;\n\n\tif (nano_ms2 &gt; 0) {\n\t\treturn (nano_ms2 + SENSOR_G / 2) / SENSOR_G;\n\t} else {\n\t\treturn (nano_ms2 - SENSOR_G / 2) / SENSOR_G;\n\t}\n}\n\n/**\n * @brief Helper function to convert acceleration from m/s^2 to micro Gs\n *\n * @param ms2 A pointer to a sensor_value struct holding the acceleration,\n *            in m/s^2.\n *\n * @return The converted value, in micro Gs.\n */\nstatic inline int32_t sensor_ms2_to_ug(const struct sensor_value *ms2)\n{\n\tint64_t micro_ms2 = (ms2-&gt;val1 * INT64_C(1000000)) + ms2-&gt;val2;\n\n\treturn (micro_ms2 * 1000000LL) / SENSOR_G;\n}\n\n/**\n * @brief Helper function to convert acceleration from micro Gs to m/s^2\n *\n * @param ug The micro G value to be converted.\n * @param ms2 A pointer to a sensor_value struct, where the result is stored.\n */\nstatic inline void sensor_ug_to_ms2(int32_t ug, struct sensor_value *ms2)\n{\n\tms2-&gt;val1 = ((int64_t)ug * SENSOR_G / 1000000LL) / 1000000LL;\n\tms2-&gt;val2 = ((int64_t)ug * SENSOR_G / 1000000LL) % 1000000LL;\n}\n\n/**\n * @brief Helper function for converting radians to degrees.\n *\n * @param rad A pointer to a sensor_value struct, holding the value in radians.\n *\n * @return The converted value, in degrees.\n */\nstatic inline int32_t sensor_rad_to_degrees(const struct sensor_value *rad)\n{\n\tint64_t micro_rad_s = rad-&gt;val1 * 1000000LL + rad-&gt;val2;\n\n\tif (micro_rad_s &gt; 0) {\n\t\treturn (micro_rad_s * 180LL + SENSOR_PI / 2) / SENSOR_PI;\n\t} else {\n\t\treturn (micro_rad_s * 180LL - SENSOR_PI / 2) / SENSOR_PI;\n\t}\n}\n\n/**\n * @brief Helper function for converting degrees to radians.\n *\n * @param d The value (in degrees) to be converted.\n * @param rad A pointer to a sensor_value struct, where the result is stored.\n */\nstatic inline void sensor_degrees_to_rad(int32_t d, struct sensor_value *rad)\n{\n\trad-&gt;val1 = ((int64_t)d * SENSOR_PI / 180LL) / 1000000LL;\n\trad-&gt;val2 = ((int64_t)d * SENSOR_PI / 180LL) % 1000000LL;\n}\n\n/**\n * @brief Helper function for converting radians to 10 micro degrees.\n *\n * When the unit is 1 micro degree, the range that the int32_t can represent is\n * +/-2147.483 degrees. In order to increase this range, here we use 10 micro\n * degrees as the unit.\n *\n * @param rad A pointer to a sensor_value struct, holding the value in radians.\n *\n * @return The converted value, in 10 micro degrees.\n */\nstatic inline int32_t sensor_rad_to_10udegrees(const struct sensor_value *rad)\n{\n\tint64_t micro_rad_s = rad-&gt;val1 * 1000000LL + rad-&gt;val2;\n\n\treturn (micro_rad_s * 180LL * 100000LL) / SENSOR_PI;\n}\n\n/**\n * @brief Helper function for converting 10 micro degrees to radians.\n *\n * @param d The value (in 10 micro degrees) to be converted.\n * @param rad A pointer to a sensor_value struct, where the result is stored.\n */\nstatic inline void sensor_10udegrees_to_rad(int32_t d, struct sensor_value *rad)\n{\n\trad-&gt;val1 = ((int64_t)d * SENSOR_PI / 180LL / 100000LL) / 1000000LL;\n\trad-&gt;val2 = ((int64_t)d * SENSOR_PI / 180LL / 100000LL) % 1000000LL;\n}\n\n/**\n * @brief Helper function for converting struct sensor_value to double.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline double sensor_value_to_double(const struct sensor_value *val)\n{\n\treturn (double)val-&gt;val1 + (double)val-&gt;val2 / 1000000;\n}\n\n/**\n * @brief Helper function for converting struct sensor_value to float.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline float sensor_value_to_float(const struct sensor_value *val)\n{\n\treturn (float)val-&gt;val1 + (float)val-&gt;val2 / 1000000;\n}\n\n/**\n * @brief Helper function for converting double to struct sensor_value.\n *\n * @param val A pointer to a sensor_value struct.\n * @param inp The converted value.\n * @return 0 if successful, negative errno code if failure.\n */\nstatic inline int sensor_value_from_double(struct sensor_value *val, double inp)\n{\n\tif (inp &lt; INT32_MIN || inp &gt; INT32_MAX) {\n\t\treturn -ERANGE;\n\t}\n\n\tdouble val2 = (inp - (int32_t)inp) * 1000000.0;\n\n\tif (val2 &lt; INT32_MIN || val2 &gt; INT32_MAX) {\n\t\treturn -ERANGE;\n\t}\n\n\tval-&gt;val1 = (int32_t)inp;\n\tval-&gt;val2 = (int32_t)val2;\n\n\treturn 0;\n}\n\n/**\n * @brief Helper function for converting float to struct sensor_value.\n *\n * @param val A pointer to a sensor_value struct.\n * @param inp The converted value.\n * @return 0 if successful, negative errno code if failure.\n */\nstatic inline int sensor_value_from_float(struct sensor_value *val, float inp)\n{\n\tfloat val2 = (inp - (int32_t)inp) * 1000000.0f;\n\n\tif (val2 &lt; INT32_MIN || val2 &gt; (float)(INT32_MAX - 1)) {\n\t\treturn -ERANGE;\n\t}\n\n\tval-&gt;val1 = (int32_t)inp;\n\tval-&gt;val2 = (int32_t)val2;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SENSOR_INFO\n\nstruct sensor_info {\n\tconst struct device *dev;\n\tconst char *vendor;\n\tconst char *model;\n\tconst char *friendly_name;\n};\n\n#define SENSOR_INFO_INITIALIZER(_dev, _vendor, _model, _friendly_name)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.dev = _dev,\t\t\t\t\t\t\\\n\t\t.vendor = _vendor,\t\t\t\t\t\\\n\t\t.model = _model,\t\t\t\t\t\\\n\t\t.friendly_name = _friendly_name,\t\t\t\\\n\t}\n\n#define SENSOR_INFO_DEFINE(name, ...)\t\t\t\t\t\\\n\tstatic const STRUCT_SECTION_ITERABLE(sensor_info, name) =\t\\\n\t\tSENSOR_INFO_INITIALIZER(__VA_ARGS__)\n\n#define SENSOR_INFO_DT_NAME(node_id)\t\t\t\t\t\\\n\t_CONCAT(__sensor_info, DEVICE_DT_NAME_GET(node_id))\n\n#define SENSOR_INFO_DT_DEFINE(node_id)\t\t\t\t\t\\\n\tSENSOR_INFO_DEFINE(SENSOR_INFO_DT_NAME(node_id),\t\t\\\n\t\t\t   DEVICE_DT_GET(node_id),\t\t\t\\\n\t\t\t   DT_NODE_VENDOR_OR(node_id, NULL),\t\t\\\n\t\t\t   DT_NODE_MODEL_OR(node_id, NULL),\t\t\\\n\t\t\t   DT_PROP_OR(node_id, friendly_name, NULL))\t\\\n\n#else\n\n#define SENSOR_INFO_DEFINE(name, ...)\n#define SENSOR_INFO_DT_DEFINE(node_id)\n\n#endif /* CONFIG_SENSOR_INFO */\n\n/**\n * @brief Like DEVICE_DT_DEFINE() with sensor specifics.\n *\n * @details Defines a device which implements the sensor API. May define an\n * element in the sensor info iterable section used to enumerate all sensor\n * devices.\n *\n * @param node_id The devicetree node identifier.\n *\n * @param init_fn Name of the init function of the driver.\n *\n * @param pm_device PM device resources reference (NULL if device does not use\n * PM).\n *\n * @param data_ptr Pointer to the device&#x27;s private data.\n *\n * @param cfg_ptr The address to the structure containing the configuration\n * information for this instance of the driver.\n *\n * @param level The initialization level. See SYS_INIT() for details.\n *\n * @param prio Priority within the selected initialization level. See\n * SYS_INIT() for details.\n *\n * @param api_ptr Provides an initial pointer to the API function struct used\n * by the driver. Can be NULL.\n */\n#define SENSOR_DEVICE_DT_DEFINE(node_id, init_fn, pm_device,\t\t\\\n\t\t\t\tdata_ptr, cfg_ptr, level, prio,\t\t\\\n\t\t\t\tapi_ptr, ...)\t\t\t\t\\\n\tDEVICE_DT_DEFINE(node_id, init_fn, pm_device,\t\t\t\\\n\t\t\t data_ptr, cfg_ptr, level, prio,\t\t\\\n\t\t\t api_ptr, __VA_ARGS__);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tSENSOR_INFO_DT_DEFINE(node_id);\n\n/**\n * @brief Like SENSOR_DEVICE_DT_DEFINE() for an instance of a DT_DRV_COMPAT\n * compatible\n *\n * @param inst instance number. This is replaced by\n * &lt;tt&gt;DT_DRV_COMPAT(inst)&lt;/tt&gt; in the call to SENSOR_DEVICE_DT_DEFINE().\n *\n * @param ... other parameters as expected by SENSOR_DEVICE_DT_DEFINE().\n */\n#define SENSOR_DEVICE_DT_INST_DEFINE(inst, ...)\t\t\t\t\\\n\tSENSOR_DEVICE_DT_DEFINE(DT_DRV_INST(inst), __VA_ARGS__)\n\n/**\n * @brief Helper function for converting struct sensor_value to integer deci units.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline int64_t sensor_value_to_deci(const struct sensor_value *val)\n{\n\treturn ((int64_t)val-&gt;val1 * 10) + val-&gt;val2 / 100000;\n}\n\n/**\n * @brief Helper function for converting struct sensor_value to integer centi units.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline int64_t sensor_value_to_centi(const struct sensor_value *val)\n{\n\treturn ((int64_t)val-&gt;val1 * 100) + val-&gt;val2 / 10000;\n}\n\n/**\n * @brief Helper function for converting struct sensor_value to integer milli units.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline int64_t sensor_value_to_milli(const struct sensor_value *val)\n{\n\treturn ((int64_t)val-&gt;val1 * 1000) + val-&gt;val2 / 1000;\n}\n\n/**\n * @brief Helper function for converting struct sensor_value to integer micro units.\n *\n * @param val A pointer to a sensor_value struct.\n * @return The converted value.\n */\nstatic inline int64_t sensor_value_to_micro(const struct sensor_value *val)\n{\n\treturn ((int64_t)val-&gt;val1 * 1000000) + val-&gt;val2;\n}\n\n/**\n * @brief Helper function for converting integer milli units to struct sensor_value.\n *\n * @param val A pointer to a sensor_value struct.\n * @param milli The converted value.\n * @return 0 if successful, negative errno code if failure.\n */\nstatic inline int sensor_value_from_milli(struct sensor_value *val, int64_t milli)\n{\n\tif (milli &lt; ((int64_t)INT32_MIN - 1) * 1000LL ||\n\t\t\tmilli &gt; ((int64_t)INT32_MAX + 1) * 1000LL) {\n\t\treturn -ERANGE;\n\t}\n\n\tval-&gt;val1 = (int32_t)(milli / 1000);\n\tval-&gt;val2 = (int32_t)(milli % 1000) * 1000;\n\n\treturn 0;\n}\n\n/**\n * @brief Helper function for converting integer micro units to struct sensor_value.\n *\n * @param val A pointer to a sensor_value struct.\n * @param micro The converted value.\n * @return 0 if successful, negative errno code if failure.\n */\nstatic inline int sensor_value_from_micro(struct sensor_value *val, int64_t micro)\n{\n\tif (micro &lt; ((int64_t)INT32_MIN - 1) * 1000000LL ||\n\t\t\tmicro &gt; ((int64_t)INT32_MAX + 1) * 1000000LL) {\n\t\treturn -ERANGE;\n\t}\n\n\tval-&gt;val1 = (int32_t)(micro / 1000000LL);\n\tval-&gt;val2 = (int32_t)(micro % 1000000LL);\n\n\treturn 0;\n}\n\n/**\n * @}\n */\n\n/**\n * @brief Get the decoder name for the current driver\n *\n * This function depends on `DT_DRV_COMPAT` being defined.\n */\n#define SENSOR_DECODER_NAME() UTIL_CAT(DT_DRV_COMPAT, __decoder_api)\n\n/**\n * @brief Statically get the decoder for a given node\n *\n * @code{.c}\n * static const sensor_decoder_api *decoder = SENSOR_DECODER_DT_GET(DT_ALIAS(accel));\n * @endcode\n */\n#define SENSOR_DECODER_DT_GET(node_id)                                                             \\\n\t&amp;UTIL_CAT(DT_STRING_TOKEN_BY_IDX(node_id, compatible, 0), __decoder_api)\n\n/**\n * @brief Define a decoder API\n *\n * This macro should be created once per compatible string of a sensor and will create a statically\n * referenceable decoder API.\n *\n * @code{.c}\n * SENSOR_DECODER_API_DT_DEFINE() = {\n *   .get_frame_count = my_driver_get_frame_count,\n *   .get_timestamp = my_driver_get_timestamp,\n *   .get_shift = my_driver_get_shift,\n *   .decode = my_driver_decode,\n * };\n * @endcode\n */\n#define SENSOR_DECODER_API_DT_DEFINE()                                                             \\\n\tCOND_CODE_1(DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT), (), (static))                        \\\n\tconst STRUCT_SECTION_ITERABLE(sensor_decoder_api, SENSOR_DECODER_NAME())\n\n#define Z_MAYBE_SENSOR_DECODER_DECLARE_INTERNAL_IDX(node_id, prop, idx)                            \\\n\textern const struct sensor_decoder_api UTIL_CAT(                                           \\\n\t\tDT_STRING_TOKEN_BY_IDX(node_id, prop, idx), __decoder_api);\n\n#define Z_MAYBE_SENSOR_DECODER_DECLARE_INTERNAL(node_id)                                           \\\n\tCOND_CODE_1(DT_NODE_HAS_PROP(node_id, compatible),                                         \\\n\t\t    (DT_FOREACH_PROP_ELEM(node_id, compatible,                                     \\\n\t\t\t\t\t  Z_MAYBE_SENSOR_DECODER_DECLARE_INTERNAL_IDX)),           \\\n\t\t    ())\n\nDT_FOREACH_STATUS_OKAY_NODE(Z_MAYBE_SENSOR_DECODER_DECLARE_INTERNAL)\n\n#ifdef __cplusplus\n}\n#endif\n\n#include &lt;zephyr/syscalls/sensor.h&gt;\n\n#endif /* ZEPHYR_INCLUDE_DRIVERS_SENSOR_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "content": "/*\n * Copyright (c) 2020 Intel Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_KERNEL_INTERNAL_MM_H\n#define ZEPHYR_INCLUDE_KERNEL_INTERNAL_MM_H\n\n#include &lt;zephyr/sys/util.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n\n/**\n * @defgroup kernel_mm_internal_apis Kernel Memory Management Internal APIs\n * @ingroup internal_api\n * @{\n */\n\n/**\n * @def K_MEM_VIRT_OFFSET\n * @brief Address offset of permanent virtual mapping from physical address.\n *\n * This is the offset to subtract from a virtual address mapped in the\n * kernel&#x27;s permanent mapping of RAM, to obtain its physical address.\n *\n *     virt_addr = phys_addr + K_MEM_VIRT_OFFSET\n *\n * This only works for virtual addresses within the interval\n * [CONFIG_KERNEL_VM_BASE, CONFIG_KERNEL_VM_BASE + (CONFIG_SRAM_SIZE * 1024)).\n *\n * These macros are intended for assembly, linker code, and static initializers.\n * Use with care.\n *\n * Note that when demand paging is active, these will only work with page\n * frames that are pinned to their virtual mapping at boot.\n *\n * TODO: This will likely need to move to an arch API or need additional\n * constraints defined.\n */\n#ifdef CONFIG_MMU\n#define K_MEM_VIRT_OFFSET\t((CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_OFFSET) - \\\n\t\t\t\t (CONFIG_SRAM_BASE_ADDRESS + CONFIG_SRAM_OFFSET))\n#else\n#define K_MEM_VIRT_OFFSET\t0\n#endif /* CONFIG_MMU */\n\n/**\n * @brief Get physical address from virtual address.\n *\n * This only works in the kernel&#x27;s permanent mapping of RAM.\n *\n * @param virt Virtual address\n *\n * @return Physical address.\n */\n#define K_MEM_PHYS_ADDR(virt)\t((virt) - K_MEM_VIRT_OFFSET)\n\n/**\n * @brief Get virtual address from physical address.\n *\n * This only works in the kernel&#x27;s permanent mapping of RAM.\n *\n * @param phys Physical address\n *\n * @return Virtual address.\n */\n#define K_MEM_VIRT_ADDR(phys)\t((phys) + K_MEM_VIRT_OFFSET)\n\n#if K_MEM_VIRT_OFFSET != 0\n/**\n * @brief Kernel is mapped in virtual memory if defined.\n */\n#define K_MEM_IS_VM_KERNEL 1\n#ifdef CONFIG_XIP\n#error &quot;XIP and a virtual memory kernel are not allowed&quot;\n#endif\n#endif\n\n#ifndef _ASMLANGUAGE\n#include &lt;stdint.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;zephyr/sys/__assert.h&gt;\n#include &lt;zephyr/sys/mem_manage.h&gt;\n\n/**\n * @brief Get physical address from virtual address.\n *\n * This only works in the kernel&#x27;s permanent mapping of RAM.\n *\n * Just like K_MEM_PHYS_ADDR() but with type safety and assertions.\n *\n * @param virt Virtual address\n *\n * @return Physical address.\n */\nstatic inline uintptr_t k_mem_phys_addr(void *virt)\n{\n\tuintptr_t addr = (uintptr_t)virt;\n\n#if defined(CONFIG_KERNEL_VM_USE_CUSTOM_MEM_RANGE_CHECK)\n\t__ASSERT(sys_mm_is_virt_addr_in_range(virt),\n\t\t &quot;address %p not in permanent mappings&quot;, virt);\n#elif defined(CONFIG_MMU)\n\t__ASSERT(\n#if CONFIG_KERNEL_VM_BASE != 0\n\t\t (addr &gt;= CONFIG_KERNEL_VM_BASE) &amp;&amp;\n#endif /* CONFIG_KERNEL_VM_BASE != 0 */\n#if (CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_SIZE) != 0\n\t\t (addr &lt; (CONFIG_KERNEL_VM_BASE +\n\t\t\t  (CONFIG_KERNEL_VM_SIZE))),\n#else\n\t\t false,\n#endif /* CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_SIZE != 0 */\n\t\t &quot;address %p not in permanent mappings&quot;, virt);\n#else\n\t/* Should be identity-mapped */\n\t__ASSERT(\n#if CONFIG_SRAM_BASE_ADDRESS != 0\n\t\t (addr &gt;= CONFIG_SRAM_BASE_ADDRESS) &amp;&amp;\n#endif /* CONFIG_SRAM_BASE_ADDRESS != 0 */\n#if (CONFIG_SRAM_BASE_ADDRESS + (CONFIG_SRAM_SIZE * 1024UL)) != 0\n\t\t (addr &lt; (CONFIG_SRAM_BASE_ADDRESS +\n\t\t\t  (CONFIG_SRAM_SIZE * 1024UL))),\n#else\n\t\t false,\n#endif /* (CONFIG_SRAM_BASE_ADDRESS + (CONFIG_SRAM_SIZE * 1024UL)) != 0 */\n\t\t &quot;physical address 0x%lx not in RAM&quot;,\n\t\t (unsigned long)addr);\n#endif /* CONFIG_MMU */\n\n\t/* TODO add assertion that this page is pinned to boot mapping,\n\t * the above checks won&#x27;t be sufficient with demand paging\n\t */\n\n\treturn K_MEM_PHYS_ADDR(addr);\n}\n\n/**\n * @brief Get virtual address from physical address.\n *\n * This only works in the kernel&#x27;s permanent mapping of RAM.\n *\n * Just like K_MEM_VIRT_ADDR() but with type safety and assertions.\n *\n * @param phys Physical address\n *\n * @return Virtual address.\n */\nstatic inline void *k_mem_virt_addr(uintptr_t phys)\n{\n#if defined(CONFIG_KERNEL_VM_USE_CUSTOM_MEM_RANGE_CHECK)\n\t__ASSERT(sys_mm_is_phys_addr_in_range(phys),\n\t\t&quot;physical address 0x%lx not in RAM&quot;, (unsigned long)phys);\n#else\n\t__ASSERT(\n#if CONFIG_SRAM_BASE_ADDRESS != 0\n\t\t (phys &gt;= CONFIG_SRAM_BASE_ADDRESS) &amp;&amp;\n#endif /* CONFIG_SRAM_BASE_ADDRESS != 0 */\n#if (CONFIG_SRAM_BASE_ADDRESS + (CONFIG_SRAM_SIZE * 1024UL)) != 0\n\t\t (phys &lt; (CONFIG_SRAM_BASE_ADDRESS +\n\t\t\t  (CONFIG_SRAM_SIZE * 1024UL))),\n#else\n\t\t false,\n#endif /* (CONFIG_SRAM_BASE_ADDRESS + (CONFIG_SRAM_SIZE * 1024UL)) != 0 */\n\t\t &quot;physical address 0x%lx not in RAM&quot;, (unsigned long)phys);\n#endif /* CONFIG_KERNEL_VM_USE_CUSTOM_MEM_RANGE_CHECK */\n\n\t/* TODO add assertion that this page frame is pinned to boot mapping,\n\t * the above check won&#x27;t be sufficient with demand paging\n\t */\n\n\treturn (void *)K_MEM_VIRT_ADDR(phys);\n}\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * Map a physical memory region into the kernel&#x27;s virtual address space\n *\n * This function is intended for mapping memory-mapped I/O regions into\n * the virtual address space. Given a physical address and a size, return a\n * linear address representing the base of where the physical region is mapped\n * in the virtual address space for the Zephyr kernel.\n *\n * The memory mapped via this function must be unmapped using\n * k_mem_unmap_phys_bare().\n *\n * This function alters the active page tables in the area reserved\n * for the kernel. This function will choose the virtual address\n * and return it to the caller.\n *\n * Portable code should never assume that phys_addr and linear_addr will\n * be equal.\n *\n * Caching and access properties are controlled by the &#x27;flags&#x27; parameter.\n * Unused bits in &#x27;flags&#x27; are reserved for future expansion.\n * A caching mode must be selected. By default, the region is read-only\n * with user access and code execution forbidden. This policy is changed\n * by passing K_MEM_CACHE_* and K_MEM_PERM_* macros into the &#x27;flags&#x27; parameter.\n *\n * If there is insufficient virtual address space for the mapping this will\n * generate a kernel panic.\n *\n * This API is only available if CONFIG_MMU is enabled.\n *\n * It is highly discouraged to use this function to map system RAM page\n * frames. It may conflict with anonymous memory mappings and demand paging\n * and produce undefined behavior.  Do not use this for RAM unless you know\n * exactly what you are doing. If you need a chunk of memory, use k_mem_map().\n * If you need a contiguous buffer of physical memory, statically declare it\n * and pin it at build time, it will be mapped when the system boots.\n *\n * This API is part of infrastructure still under development and may\n * change.\n *\n * @param[out] virt_ptr Output virtual address storage location\n * @param[in]  phys Physical address base of the memory region\n * @param[in]  size Size of the memory region\n * @param[in]  flags Caching mode and access flags, see K_MAP_* macros\n */\nvoid k_mem_map_phys_bare(uint8_t **virt_ptr, uintptr_t phys, size_t size,\n\t\t\t uint32_t flags);\n\n/**\n * Unmap a virtual memory region from kernel&#x27;s virtual address space.\n *\n * This function is intended to be used by drivers and early boot routines\n * where temporary memory mappings need to be made. This allows these\n * memory mappings to be discarded once they are no longer needed.\n *\n * This function alters the active page tables in the area reserved\n * for the kernel.\n *\n * This will align the input parameters to page boundaries so that\n * this can be used with the virtual address as returned by\n * k_mem_map_phys_bare().\n *\n * This API is only available if CONFIG_MMU is enabled.\n *\n * It is highly discouraged to use this function to unmap memory mappings.\n * It may conflict with anonymous memory mappings and demand paging and\n * produce undefined behavior. Do not use this unless you know exactly\n * what you are doing.\n *\n * This API is part of infrastructure still under development and may\n * change.\n *\n * @param virt Starting address of the virtual address region to be unmapped.\n * @param size Size of the virtual address region\n */\nvoid k_mem_unmap_phys_bare(uint8_t *virt, size_t size);\n\n/**\n * Map memory into virtual address space with guard pages.\n *\n * This maps memory into virtual address space with a preceding and\n * a succeeding guard pages. The memory mapped via this function must be\n * unmapped using k_mem_unmap_phys_guard().\n *\n * This function maps a contiguous physical memory region into kernel&#x27;s\n * virtual address space with a preceding and a succeeding guard pages.\n * Given a physical address and a size, return a linear address representing\n * the base of where the physical region is mapped in the virtual address\n * space for the Zephyr kernel.\n *\n * This function alters the active page tables in the area reserved\n * for the kernel. This function will choose the virtual address\n * and return it to the caller.\n *\n * If user thread access control needs to be managed in any way, do not enable\n * K_MEM_PERM_USER flags here; instead manage the region&#x27;s permissions\n * with memory domain APIs after the mapping has been established. Setting\n * K_MEM_PERM_USER here will allow all user threads to access this memory\n * which is usually undesirable.\n *\n * Unless K_MEM_MAP_UNINIT is used, the returned memory will be zeroed.\n *\n * The returned virtual memory pointer will be page-aligned. The size\n * parameter, and any base address for re-mapping purposes must be page-\n * aligned.\n *\n * Note that the allocation includes two guard pages immediately before\n * and after the requested region. The total size of the allocation will be\n * the requested size plus the size of these two guard pages.\n *\n * Many K_MEM_MAP_* flags have been implemented to alter the behavior of this\n * function, with details in the documentation for these flags.\n *\n * @see k_mem_map() for additional information if called via that.\n *\n * @param phys Physical address base of the memory region if not requesting\n *             anonymous memory. Must be page-aligned.\n * @param size Size of the memory mapping. This must be page-aligned.\n * @param flags K_MEM_PERM_*, K_MEM_MAP_* control flags.\n * @param is_anon True is requesting mapping with anonymous memory.\n *\n * @return The mapped memory location, or NULL if insufficient virtual address\n *         space, insufficient physical memory to establish the mapping,\n *         or insufficient memory for paging structures.\n */\nvoid *k_mem_map_phys_guard(uintptr_t phys, size_t size, uint32_t flags, bool is_anon);\n\n/**\n * Un-map memory mapped via k_mem_map_phys_guard().\n *\n * This removes the memory mappings for the provided page-aligned region,\n * and the two guard pages surrounding the region.\n *\n * This function alters the active page tables in the area reserved\n * for the kernel.\n *\n * @see k_mem_unmap() for additional information if called via that.\n *\n * @note Calling this function on a region which was not mapped via\n *       k_mem_map_phys_guard() to begin with is undefined behavior.\n *\n * @param addr Page-aligned memory region base virtual address\n * @param size Page-aligned memory region size\n * @param is_anon True if the mapped memory is from anonymous memory.\n */\nvoid k_mem_unmap_phys_guard(void *addr, size_t size, bool is_anon);\n\n#ifdef __cplusplus\n}\n#endif\n\n/** @} */\n\n#endif /* !_ASMLANGUAGE */\n#endif /* ZEPHYR_INCLUDE_KERNEL_INTERNAL_MM_H */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h", "content": "/*\n * Copyright (c) 2022 Intel Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file\n * @brief Real-Time IO device API for moving bytes with low effort\n *\n * RTIO is a context for asynchronous batch operations using a submission and completion queue.\n *\n * Asynchronous I/O operation are setup in a submission queue. Each entry in the queue describes\n * the operation it wishes to perform with some understood semantics.\n *\n * These operations may be chained in a such a way that only when the current\n * operation is complete the next will be executed. If the current operation fails\n * all chained operations will also fail.\n *\n * Operations may also be submitted as a transaction where a set of operations are considered\n * to be one operation.\n *\n * The completion of these operations typically provide one or more completion queue events.\n */\n\n#ifndef ZEPHYR_INCLUDE_RTIO_RTIO_H_\n#define ZEPHYR_INCLUDE_RTIO_RTIO_H_\n\n#include &lt;string.h&gt;\n\n#include &lt;zephyr/app_memory/app_memdomain.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/kernel_structs.h&gt;\n#include &lt;zephyr/sys/__assert.h&gt;\n#include &lt;zephyr/sys/atomic.h&gt;\n#include &lt;zephyr/sys/mem_blocks.h&gt;\n#include &lt;zephyr/sys/util.h&gt;\n#include &lt;zephyr/sys/iterable_sections.h&gt;\n#include &lt;zephyr/sys/mpsc_lockfree.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\n/**\n * @brief RTIO\n * @defgroup rtio RTIO\n * @since 3.2\n * @version 0.2.0\n * @ingroup os_services\n * @{\n */\n\n/**\n * @brief RTIO Predefined Priorities\n * @defgroup rtio_sqe_prio RTIO Priorities\n * @ingroup rtio\n * @{\n */\n\n/**\n * @brief Low priority\n */\n#define RTIO_PRIO_LOW 0U\n\n/**\n * @brief Normal priority\n */\n#define RTIO_PRIO_NORM 127U\n\n/**\n * @brief High priority\n */\n#define RTIO_PRIO_HIGH 255U\n\n/**\n * @}\n */\n\n\n/**\n * @brief RTIO SQE Flags\n * @defgroup rtio_sqe_flags RTIO SQE Flags\n * @ingroup rtio\n * @{\n */\n\n/**\n * @brief The next request in the queue should wait on this one.\n *\n * Chained SQEs are individual units of work describing patterns of\n * ordering and failure cascading. A chained SQE must be started only\n * after the one before it. They are given to the iodevs one after another.\n */\n#define RTIO_SQE_CHAINED BIT(0)\n\n/**\n * @brief The next request in the queue is part of a transaction.\n *\n * Transactional SQEs are sequential parts of a unit of work.\n * Only the first transactional SQE is submitted to an iodev, the\n * remaining SQEs are never individually submitted but instead considered\n * to be part of the transaction to the single iodev. The first sqe in the\n * sequence holds the iodev that will be used and the last holds the userdata\n * that will be returned in a single completion on failure/success.\n */\n#define RTIO_SQE_TRANSACTION BIT(1)\n\n\n/**\n * @brief The buffer should be allocated by the RTIO mempool\n *\n * This flag can only exist if the CONFIG_RTIO_SYS_MEM_BLOCKS Kconfig was\n * enabled and the RTIO context was created via the RTIO_DEFINE_WITH_MEMPOOL()\n * macro. If set, the buffer associated with the entry was allocated by the\n * internal memory pool and should be released as soon as it is no longer\n * needed via a call to rtio_release_mempool().\n */\n#define RTIO_SQE_MEMPOOL_BUFFER BIT(2)\n\n/**\n * @brief The SQE should not execute if possible\n *\n * If possible (not yet executed), the SQE should be canceled by flagging it as failed and returning\n * -ECANCELED as the result.\n */\n#define RTIO_SQE_CANCELED BIT(3)\n\n/**\n * @brief The SQE should continue producing CQEs until canceled\n *\n * This flag must exist along @ref RTIO_SQE_MEMPOOL_BUFFER and signals that when a read is\n * complete. It should be placed back in queue until canceled.\n */\n#define RTIO_SQE_MULTISHOT BIT(4)\n\n/**\n * @brief The SQE does not produce a CQE.\n */\n#define RTIO_SQE_NO_RESPONSE BIT(5)\n\n/**\n * @}\n */\n\n/**\n * @brief RTIO CQE Flags\n * @defgroup rtio_cqe_flags RTIO CQE Flags\n * @ingroup rtio\n * @{\n */\n\n/**\n * @brief The entry&#x27;s buffer was allocated from the RTIO&#x27;s mempool\n *\n * If this bit is set, the buffer was allocated from the memory pool and should be recycled as\n * soon as the application is done with it.\n */\n#define RTIO_CQE_FLAG_MEMPOOL_BUFFER BIT(0)\n\n#define RTIO_CQE_FLAG_GET(flags) FIELD_GET(GENMASK(7, 0), (flags))\n\n/**\n * @brief Get the block index of a mempool flags\n *\n * @param flags The CQE flags value\n * @return The block index portion of the flags field.\n */\n#define RTIO_CQE_FLAG_MEMPOOL_GET_BLK_IDX(flags) FIELD_GET(GENMASK(19, 8), (flags))\n\n/**\n * @brief Get the block count of a mempool flags\n *\n * @param flags The CQE flags value\n * @return The block count portion of the flags field.\n */\n#define RTIO_CQE_FLAG_MEMPOOL_GET_BLK_CNT(flags) FIELD_GET(GENMASK(31, 20), (flags))\n\n/**\n * @brief Prepare CQE flags for a mempool read.\n *\n * @param blk_idx The mempool block index\n * @param blk_cnt The mempool block count\n * @return A shifted and masked value that can be added to the flags field with an OR operator.\n */\n#define RTIO_CQE_FLAG_PREP_MEMPOOL(blk_idx, blk_cnt)                                               \\\n\t(FIELD_PREP(GENMASK(7, 0), RTIO_CQE_FLAG_MEMPOOL_BUFFER) |                                 \\\n\t FIELD_PREP(GENMASK(19, 8), blk_idx) | FIELD_PREP(GENMASK(31, 20), blk_cnt))\n\n/**\n * @}\n */\n\n/**\n * @brief Equivalent to the I2C_MSG_STOP flag\n */\n#define RTIO_IODEV_I2C_STOP BIT(1)\n\n/**\n * @brief Equivalent to the I2C_MSG_RESTART flag\n */\n#define RTIO_IODEV_I2C_RESTART BIT(2)\n\n/**\n * @brief Equivalent to the I2C_MSG_ADDR_10_BITS\n */\n#define RTIO_IODEV_I2C_10_BITS BIT(3)\n\n/**\n * @brief Equivalent to the I3C_MSG_STOP flag\n */\n#define RTIO_IODEV_I3C_STOP BIT(1)\n\n/**\n * @brief Equivalent to the I3C_MSG_RESTART flag\n */\n#define RTIO_IODEV_I3C_RESTART BIT(2)\n\n/**\n * @brief Equivalent to the I3C_MSG_HDR\n */\n#define RTIO_IODEV_I3C_HDR BIT(3)\n\n/**\n * @brief Equivalent to the I3C_MSG_NBCH\n */\n#define RTIO_IODEV_I3C_NBCH BIT(4)\n\n/**\n * @brief I3C HDR Mode Mask\n */\n#define RTIO_IODEV_I3C_HDR_MODE_MASK GENMASK(15, 8)\n\n/**\n * @brief I3C HDR Mode Mask\n */\n#define RTIO_IODEV_I3C_HDR_MODE_SET(flags) \\\n\tFIELD_PREP(RTIO_IODEV_I3C_HDR_MODE_MASK, flags)\n\n/**\n * @brief I3C HDR Mode Mask\n */\n#define RTIO_IODEV_I3C_HDR_MODE_GET(flags) \\\n\tFIELD_GET(RTIO_IODEV_I3C_HDR_MODE_MASK, flags)\n\n/**\n * @brief I3C HDR 7b Command Code\n */\n#define RTIO_IODEV_I3C_HDR_CMD_CODE_MASK GENMASK(22, 16)\n\n/**\n * @brief I3C HDR 7b Command Code\n */\n#define RTIO_IODEV_I3C_HDR_CMD_CODE_SET(flags) \\\n\tFIELD_PREP(RTIO_IODEV_I3C_HDR_CMD_CODE_MASK, flags)\n\n/**\n * @brief I3C HDR 7b Command Code\n */\n#define RTIO_IODEV_I3C_HDR_CMD_CODE_GET(flags) \\\n\tFIELD_GET(RTIO_IODEV_I3C_HDR_CMD_CODE_MASK, flags)\n\n/** @cond ignore */\nstruct rtio;\nstruct rtio_cqe;\nstruct rtio_sqe;\nstruct rtio_sqe_pool;\nstruct rtio_cqe_pool;\nstruct rtio_iodev;\nstruct rtio_iodev_sqe;\n/** @endcond */\n\n/**\n * @typedef rtio_callback_t\n * @brief Callback signature for RTIO_OP_CALLBACK\n * @param r RTIO context being used with the callback\n * @param sqe Submission for the callback op\n * @param arg0 Argument option as part of the sqe\n */\ntypedef void (*rtio_callback_t)(struct rtio *r, const struct rtio_sqe *sqe, void *arg0);\n\n/**\n * @typedef rtio_signaled_t\n * @brief Callback signature for RTIO_OP_AWAIT signaled\n * @param iodev_sqe IODEV submission for the await op\n * @param userdata Userdata\n */\ntypedef void (*rtio_signaled_t)(struct rtio_iodev_sqe *iodev_sqe, void *userdata);\n\n/**\n * @brief A submission queue event\n */\nstruct rtio_sqe {\n\tuint8_t op; /**&lt; Op code */\n\n\tuint8_t prio; /**&lt; Op priority */\n\n\tuint16_t flags; /**&lt; Op Flags */\n\n\tuint32_t iodev_flags; /**&lt; Op iodev flags */\n\n\tconst struct rtio_iodev *iodev; /**&lt; Device to operation on */\n\n\t/**\n\t * User provided data which is returned upon operation completion. Could be a pointer or\n\t * integer.\n\t *\n\t * If unique identification of completions is desired this should be\n\t * unique as well.\n\t */\n\tvoid *userdata;\n\n\tunion {\n\n\t\t/** OP_TX */\n\t\tstruct {\n\t\t\tuint32_t buf_len; /**&lt; Length of buffer */\n\t\t\tconst uint8_t *buf; /**&lt; Buffer to write from */\n\t\t} tx;\n\n\t\t/** OP_RX */\n\t\tstruct {\n\t\t\tuint32_t buf_len; /**&lt; Length of buffer */\n\t\t\tuint8_t *buf; /**&lt; Buffer to read into */\n\t\t} rx;\n\n\t\t/** OP_TINY_TX */\n\t\tstruct {\n\t\t\tuint8_t buf_len; /**&lt; Length of tiny buffer */\n\t\t\tuint8_t buf[7]; /**&lt; Tiny buffer */\n\t\t} tiny_tx;\n\n\t\t/** OP_CALLBACK */\n\t\tstruct {\n\t\t\trtio_callback_t callback;\n\t\t\tvoid *arg0; /**&lt; Last argument given to callback */\n\t\t} callback;\n\n\t\t/** OP_TXRX */\n\t\tstruct {\n\t\t\tuint32_t buf_len; /**&lt; Length of tx and rx buffers */\n\t\t\tconst uint8_t *tx_buf; /**&lt; Buffer to write from */\n\t\t\tuint8_t *rx_buf; /**&lt; Buffer to read into */\n\t\t} txrx;\n\n\t\t/** OP_DELAY */\n\t\tstruct {\n\t\t\tk_timeout_t timeout; /**&lt; Delay timeout. */\n\t\t\tstruct _timeout to; /**&lt; Timeout struct. Used internally. */\n\t\t} delay;\n\n\t\t/** OP_I2C_CONFIGURE */\n\t\tuint32_t i2c_config;\n\n\t\t/** OP_I3C_CONFIGURE */\n\t\tstruct {\n\t\t\t/* enum i3c_config_type type; */\n\t\t\tint type;\n\t\t\tvoid *config;\n\t\t} i3c_config;\n\n\t\t/** OP_I3C_CCC */\n\t\t/* struct i3c_ccc_payload *ccc_payload; */\n\t\tvoid *ccc_payload;\n\n\t\t/** OP_AWAIT */\n\t\tstruct {\n\t\t\tatomic_t ok;\n\t\t\trtio_signaled_t callback;\n\t\t\tvoid *userdata;\n\t\t} await;\n\t};\n};\n\n/** @cond ignore */\n/* Ensure the rtio_sqe never grows beyond a common cacheline size of 64 bytes */\nBUILD_ASSERT(sizeof(struct rtio_sqe) &lt;= 64);\n/** @endcond */\n\n/**\n * @brief A completion queue event\n */\nstruct rtio_cqe {\n\tstruct mpsc_node q;\n\n\tint32_t result; /**&lt; Result from operation */\n\tvoid *userdata; /**&lt; Associated userdata with operation */\n\tuint32_t flags; /**&lt; Flags associated with the operation */\n};\n\nstruct rtio_sqe_pool {\n\tstruct mpsc free_q;\n\tconst uint16_t pool_size;\n\tuint16_t pool_free;\n\tstruct rtio_iodev_sqe *pool;\n};\n\nstruct rtio_cqe_pool {\n\tstruct mpsc free_q;\n\tconst uint16_t pool_size;\n\tuint16_t pool_free;\n\tstruct rtio_cqe *pool;\n};\n\n/**\n * @brief An RTIO context containing what can be viewed as a pair of queues.\n *\n * A queue for submissions (available and in queue to be produced) as well as a queue\n * of completions (available and ready to be consumed).\n *\n * The rtio executor along with any objects implementing the rtio_iodev interface are\n * the consumers of submissions and producers of completions.\n *\n * No work is started until rtio_submit() is called.\n */\nstruct rtio {\n#ifdef CONFIG_RTIO_SUBMIT_SEM\n\t/* A wait semaphore which may suspend the calling thread\n\t * to wait for some number of completions when calling submit\n\t */\n\tstruct k_sem *submit_sem;\n\n\tuint32_t submit_count;\n#endif\n\n#ifdef CONFIG_RTIO_CONSUME_SEM\n\t/* A wait semaphore which may suspend the calling thread\n\t * to wait for some number of completions while consuming\n\t * them from the completion queue\n\t */\n\tstruct k_sem *consume_sem;\n#endif\n\n\t/* Total number of completions */\n\tatomic_t cq_count;\n\n\t/* Number of completions that were unable to be submitted with results\n\t * due to the cq spsc being full\n\t */\n\tatomic_t xcqcnt;\n\n\t/* Submission queue object pool with free list */\n\tstruct rtio_sqe_pool *sqe_pool;\n\n\t/* Complete queue object pool with free list */\n\tstruct rtio_cqe_pool *cqe_pool;\n\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\n\t/* Mem block pool */\n\tstruct sys_mem_blocks *block_pool;\n#endif\n\n\t/* Submission queue */\n\tstruct mpsc sq;\n\n\t/* Completion queue */\n\tstruct mpsc cq;\n};\n\n/** The memory partition associated with all RTIO context information */\nextern struct k_mem_partition rtio_partition;\n\n/**\n * @brief Get the mempool block size of the RTIO context\n *\n * @param[in] r The RTIO context\n * @return The size of each block in the context&#x27;s mempool\n * @return 0 if the context doesn&#x27;t have a mempool\n */\nstatic inline size_t rtio_mempool_block_size(const struct rtio *r)\n{\n#ifndef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tARG_UNUSED(r);\n\treturn 0;\n#else\n\tif (r == NULL || r-&gt;block_pool == NULL) {\n\t\treturn 0;\n\t}\n\treturn BIT(r-&gt;block_pool-&gt;info.blk_sz_shift);\n#endif\n}\n\n/**\n * @brief Compute the mempool block index for a given pointer\n *\n * @param[in] r RTIO context\n * @param[in] ptr Memory pointer in the mempool\n * @return Index of the mempool block associated with the pointer. Or UINT16_MAX if invalid.\n */\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\nstatic inline uint16_t __rtio_compute_mempool_block_index(const struct rtio *r, const void *ptr)\n{\n\tuintptr_t addr = (uintptr_t)ptr;\n\tstruct sys_mem_blocks *mem_pool = r-&gt;block_pool;\n\tuint32_t block_size = rtio_mempool_block_size(r);\n\n\tuintptr_t buff = (uintptr_t)mem_pool-&gt;buffer;\n\tuint32_t buff_size = mem_pool-&gt;info.num_blocks * block_size;\n\n\tif (addr &lt; buff || addr &gt;= buff + buff_size) {\n\t\treturn UINT16_MAX;\n\t}\n\treturn (addr - buff) / block_size;\n}\n#endif\n\n/**\n * @brief IO device submission queue entry\n *\n * May be cast safely to and from a rtio_sqe as they occupy the same memory provided by the pool\n */\nstruct rtio_iodev_sqe {\n\tstruct rtio_sqe sqe;\n\tstruct mpsc_node q;\n\tstruct rtio_iodev_sqe *next;\n\tstruct rtio *r;\n};\n\n/**\n * @brief API that an RTIO IO device should implement\n */\nstruct rtio_iodev_api {\n\t/**\n\t * @brief Submit to the iodev an entry to work on\n\t *\n\t * This call should be short in duration and most likely\n\t * either enqueue or kick off an entry with the hardware.\n\t *\n\t * @param iodev_sqe Submission queue entry\n\t */\n\tvoid (*submit)(struct rtio_iodev_sqe *iodev_sqe);\n};\n\n/**\n * @brief An IO device with a function table for submitting requests\n */\nstruct rtio_iodev {\n\t/* Function pointer table */\n\tconst struct rtio_iodev_api *api;\n\n\t/* Data associated with this iodev */\n\tvoid *data;\n};\n\n/** An operation that does nothing and will complete immediately */\n#define RTIO_OP_NOP 0\n\n/** An operation that receives (reads) */\n#define RTIO_OP_RX (RTIO_OP_NOP+1)\n\n/** An operation that transmits (writes) */\n#define RTIO_OP_TX (RTIO_OP_RX+1)\n\n/** An operation that transmits tiny writes by copying the data to write */\n#define RTIO_OP_TINY_TX (RTIO_OP_TX+1)\n\n/** An operation that calls a given function (callback) */\n#define RTIO_OP_CALLBACK (RTIO_OP_TINY_TX+1)\n\n/** An operation that transceives (reads and writes simultaneously) */\n#define RTIO_OP_TXRX (RTIO_OP_CALLBACK+1)\n\n/** An operation that takes a specified amount of time (asynchronously) before completing */\n#define RTIO_OP_DELAY (RTIO_OP_TXRX+1)\n\n/** An operation to recover I2C buses */\n#define RTIO_OP_I2C_RECOVER (RTIO_OP_DELAY+1)\n\n/** An operation to configure I2C buses */\n#define RTIO_OP_I2C_CONFIGURE (RTIO_OP_I2C_RECOVER+1)\n\n/** An operation to recover I3C buses */\n#define RTIO_OP_I3C_RECOVER (RTIO_OP_I2C_CONFIGURE+1)\n\n/** An operation to configure I3C buses */\n#define RTIO_OP_I3C_CONFIGURE (RTIO_OP_I3C_RECOVER+1)\n\n/** An operation to sends I3C CCC */\n#define RTIO_OP_I3C_CCC (RTIO_OP_I3C_CONFIGURE+1)\n\n/** An operation to suspend bus while awaiting signal */\n#define RTIO_OP_AWAIT (RTIO_OP_I3C_CCC+1)\n\n/**\n * @brief Prepare a nop (no op) submission\n */\nstatic inline void rtio_sqe_prep_nop(struct rtio_sqe *sqe,\n\t\t\t\tconst struct rtio_iodev *iodev,\n\t\t\t\tvoid *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_NOP;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;userdata = userdata;\n}\n\n/**\n * @brief Prepare a read op submission\n */\nstatic inline void rtio_sqe_prep_read(struct rtio_sqe *sqe,\n\t\t\t\t      const struct rtio_iodev *iodev,\n\t\t\t\t      int8_t prio,\n\t\t\t\t      uint8_t *buf,\n\t\t\t\t      uint32_t len,\n\t\t\t\t      void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_RX;\n\tsqe-&gt;prio = prio;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;rx.buf_len = len;\n\tsqe-&gt;rx.buf = buf;\n\tsqe-&gt;userdata = userdata;\n}\n\n/**\n * @brief Prepare a read op submission with context&#x27;s mempool\n *\n * @see rtio_sqe_prep_read()\n */\nstatic inline void rtio_sqe_prep_read_with_pool(struct rtio_sqe *sqe,\n\t\t\t\t\t\tconst struct rtio_iodev *iodev, int8_t prio,\n\t\t\t\t\t\tvoid *userdata)\n{\n\trtio_sqe_prep_read(sqe, iodev, prio, NULL, 0, userdata);\n\tsqe-&gt;flags = RTIO_SQE_MEMPOOL_BUFFER;\n}\n\nstatic inline void rtio_sqe_prep_read_multishot(struct rtio_sqe *sqe,\n\t\t\t\t\t\tconst struct rtio_iodev *iodev, int8_t prio,\n\t\t\t\t\t\tvoid *userdata)\n{\n\trtio_sqe_prep_read_with_pool(sqe, iodev, prio, userdata);\n\tsqe-&gt;flags |= RTIO_SQE_MULTISHOT;\n}\n\n/**\n * @brief Prepare a write op submission\n */\nstatic inline void rtio_sqe_prep_write(struct rtio_sqe *sqe,\n\t\t\t\t       const struct rtio_iodev *iodev,\n\t\t\t\t       int8_t prio,\n\t\t\t\t       const uint8_t *buf,\n\t\t\t\t       uint32_t len,\n\t\t\t\t       void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_TX;\n\tsqe-&gt;prio = prio;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;tx.buf_len = len;\n\tsqe-&gt;tx.buf = buf;\n\tsqe-&gt;userdata = userdata;\n}\n\n/**\n * @brief Prepare a tiny write op submission\n *\n * Unlike the normal write operation where the source buffer must outlive the call\n * the tiny write data in this case is copied to the sqe. It must be tiny to fit\n * within the specified size of a rtio_sqe.\n *\n * This is useful in many scenarios with RTL logic where a write of the register to\n * subsequently read must be done.\n */\nstatic inline void rtio_sqe_prep_tiny_write(struct rtio_sqe *sqe,\n\t\t\t\t\t    const struct rtio_iodev *iodev,\n\t\t\t\t\t    int8_t prio,\n\t\t\t\t\t    const uint8_t *tiny_write_data,\n\t\t\t\t\t    uint8_t tiny_write_len,\n\t\t\t\t\t    void *userdata)\n{\n\t__ASSERT_NO_MSG(tiny_write_len &lt;= sizeof(sqe-&gt;tiny_tx.buf));\n\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_TINY_TX;\n\tsqe-&gt;prio = prio;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;tiny_tx.buf_len = tiny_write_len;\n\tmemcpy(sqe-&gt;tiny_tx.buf, tiny_write_data, tiny_write_len);\n\tsqe-&gt;userdata = userdata;\n}\n\n/**\n * @brief Prepare a callback op submission\n *\n * A somewhat special operation in that it may only be done in kernel mode.\n *\n * Used where general purpose logic is required in a queue of io operations to do\n * transforms or logic.\n */\nstatic inline void rtio_sqe_prep_callback(struct rtio_sqe *sqe,\n\t\t\t\t\t  rtio_callback_t callback,\n\t\t\t\t\t  void *arg0,\n\t\t\t\t\t  void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_CALLBACK;\n\tsqe-&gt;prio = 0;\n\tsqe-&gt;iodev = NULL;\n\tsqe-&gt;callback.callback = callback;\n\tsqe-&gt;callback.arg0 = arg0;\n\tsqe-&gt;userdata = userdata;\n}\n\n/**\n * @brief Prepare a callback op submission that does not create a CQE\n *\n * Similar to @ref rtio_sqe_prep_callback, but the @ref RTIO_SQE_NO_RESPONSE\n * flag is set on the SQE to prevent the generation of a CQE upon completion.\n *\n * This can be useful when the callback is the last operation in a sequence\n * whose job is to clean up all the previous CQE&#x27;s. Without @ref RTIO_SQE_NO_RESPONSE\n * the completion itself will result in a CQE that cannot be consumed in the callback.\n */\nstatic inline void rtio_sqe_prep_callback_no_cqe(struct rtio_sqe *sqe,\n\t\t\t\t\t\t rtio_callback_t callback,\n\t\t\t\t\t\t void *arg0,\n\t\t\t\t\t\t void *userdata)\n{\n\trtio_sqe_prep_callback(sqe, callback, arg0, userdata);\n\tsqe-&gt;flags |= RTIO_SQE_NO_RESPONSE;\n}\n\n/**\n * @brief Prepare a transceive op submission\n */\nstatic inline void rtio_sqe_prep_transceive(struct rtio_sqe *sqe,\n\t\t\t\t\t    const struct rtio_iodev *iodev,\n\t\t\t\t\t    int8_t prio,\n\t\t\t\t\t    const uint8_t *tx_buf,\n\t\t\t\t\t    uint8_t *rx_buf,\n\t\t\t\t\t    uint32_t buf_len,\n\t\t\t\t\t    void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_TXRX;\n\tsqe-&gt;prio = prio;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;txrx.buf_len = buf_len;\n\tsqe-&gt;txrx.tx_buf = tx_buf;\n\tsqe-&gt;txrx.rx_buf = rx_buf;\n\tsqe-&gt;userdata = userdata;\n}\n\nstatic inline void rtio_sqe_prep_await(struct rtio_sqe *sqe,\n\t\t\t\t       const struct rtio_iodev *iodev,\n\t\t\t\t       int8_t prio,\n\t\t\t\t       void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_AWAIT;\n\tsqe-&gt;prio = prio;\n\tsqe-&gt;iodev = iodev;\n\tsqe-&gt;userdata = userdata;\n}\n\nstatic inline void rtio_sqe_prep_delay(struct rtio_sqe *sqe,\n\t\t\t\t       k_timeout_t timeout,\n\t\t\t\t       void *userdata)\n{\n\tmemset(sqe, 0, sizeof(struct rtio_sqe));\n\tsqe-&gt;op = RTIO_OP_DELAY;\n\tsqe-&gt;prio = 0;\n\tsqe-&gt;iodev = NULL;\n\tsqe-&gt;delay.timeout = timeout;\n\tsqe-&gt;userdata = userdata;\n}\n\nstatic inline struct rtio_iodev_sqe *rtio_sqe_pool_alloc(struct rtio_sqe_pool *pool)\n{\n\tstruct mpsc_node *node = mpsc_pop(&amp;pool-&gt;free_q);\n\n\tif (node == NULL) {\n\t\treturn NULL;\n\t}\n\n\tstruct rtio_iodev_sqe *iodev_sqe = CONTAINER_OF(node, struct rtio_iodev_sqe, q);\n\n\tpool-&gt;pool_free--;\n\n\treturn iodev_sqe;\n}\n\nstatic inline void rtio_sqe_pool_free(struct rtio_sqe_pool *pool, struct rtio_iodev_sqe *iodev_sqe)\n{\n\tmpsc_push(&amp;pool-&gt;free_q, &amp;iodev_sqe-&gt;q);\n\n\tpool-&gt;pool_free++;\n}\n\nstatic inline struct rtio_cqe *rtio_cqe_pool_alloc(struct rtio_cqe_pool *pool)\n{\n\tstruct mpsc_node *node = mpsc_pop(&amp;pool-&gt;free_q);\n\n\tif (node == NULL) {\n\t\treturn NULL;\n\t}\n\n\tstruct rtio_cqe *cqe = CONTAINER_OF(node, struct rtio_cqe, q);\n\n\tmemset(cqe, 0, sizeof(struct rtio_cqe));\n\n\tpool-&gt;pool_free--;\n\n\treturn cqe;\n}\n\nstatic inline void rtio_cqe_pool_free(struct rtio_cqe_pool *pool, struct rtio_cqe *cqe)\n{\n\tmpsc_push(&amp;pool-&gt;free_q, &amp;cqe-&gt;q);\n\n\tpool-&gt;pool_free++;\n}\n\nstatic inline int rtio_block_pool_alloc(struct rtio *r, size_t min_sz,\n\t\t\t\t\t  size_t max_sz, uint8_t **buf, uint32_t *buf_len)\n{\n#ifndef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tARG_UNUSED(r);\n\tARG_UNUSED(min_sz);\n\tARG_UNUSED(max_sz);\n\tARG_UNUSED(buf);\n\tARG_UNUSED(buf_len);\n\treturn -ENOTSUP;\n#else\n\tconst uint32_t block_size = rtio_mempool_block_size(r);\n\tuint32_t bytes = max_sz;\n\n\t/* Not every context has a block pool and the block size may return 0 in\n\t * that case\n\t */\n\tif (block_size == 0) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdo {\n\t\tsize_t num_blks = DIV_ROUND_UP(bytes, block_size);\n\t\tint rc = sys_mem_blocks_alloc_contiguous(r-&gt;block_pool, num_blks, (void **)buf);\n\n\t\tif (rc == 0) {\n\t\t\t*buf_len = num_blks * block_size;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (bytes &lt;= block_size) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes -= block_size;\n\t} while (bytes &gt;= min_sz);\n\n\treturn -ENOMEM;\n#endif\n}\n\nstatic inline void rtio_block_pool_free(struct rtio *r, void *buf, uint32_t buf_len)\n{\n#ifndef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tARG_UNUSED(r);\n\tARG_UNUSED(buf);\n\tARG_UNUSED(buf_len);\n#else\n\tsize_t num_blks = buf_len &gt;&gt; r-&gt;block_pool-&gt;info.blk_sz_shift;\n\n\tsys_mem_blocks_free_contiguous(r-&gt;block_pool, buf, num_blks);\n#endif\n}\n\n/* Do not try and reformat the macros */\n/* clang-format off */\n\n/**\n * @brief Statically define and initialize an RTIO IODev\n *\n * @param name Name of the iodev\n * @param iodev_api Pointer to struct rtio_iodev_api\n * @param iodev_data Data pointer\n */\n#define RTIO_IODEV_DEFINE(name, iodev_api, iodev_data)\t\t\\\n\tSTRUCT_SECTION_ITERABLE(rtio_iodev, name) = {\t\t\\\n\t\t.api = (iodev_api),\t\t\t\t\\\n\t\t.data = (iodev_data),\t\t\t\t\\\n\t}\n\n#define Z_RTIO_SQE_POOL_DEFINE(name, sz)\t\t\t\\\n\tstatic struct rtio_iodev_sqe CONCAT(_sqe_pool_, name)[sz];\t\\\n\tSTRUCT_SECTION_ITERABLE(rtio_sqe_pool, name) = {\t\\\n\t\t.free_q = MPSC_INIT((name.free_q)),\t\\\n\t\t.pool_size = sz,\t\t\t\t\\\n\t\t.pool_free = sz,\t\t\t\t\\\n\t\t.pool = CONCAT(_sqe_pool_, name),\t\t\\\n\t}\n\n\n#define Z_RTIO_CQE_POOL_DEFINE(name, sz)\t\t\t\\\n\tstatic struct rtio_cqe CONCAT(_cqe_pool_, name)[sz];\t\\\n\tSTRUCT_SECTION_ITERABLE(rtio_cqe_pool, name) = {\t\\\n\t\t.free_q = MPSC_INIT((name.free_q)),\t\\\n\t\t.pool_size = sz,\t\t\t\t\\\n\t\t.pool_free = sz,\t\t\t\t\\\n\t\t.pool = CONCAT(_cqe_pool_, name),\t\t\\\n\t}\n\n/**\n * @brief Allocate to bss if available\n *\n * If CONFIG_USERSPACE is selected, allocate to the rtio_partition bss. Maps to:\n *   K_APP_BMEM(rtio_partition) static\n *\n * If CONFIG_USERSPACE is disabled, allocate as plain static:\n *   static\n */\n#define RTIO_BMEM COND_CODE_1(CONFIG_USERSPACE, (K_APP_BMEM(rtio_partition) static), (static))\n\n/**\n * @brief Allocate as initialized memory if available\n *\n * If CONFIG_USERSPACE is selected, allocate to the rtio_partition init. Maps to:\n *   K_APP_DMEM(rtio_partition) static\n *\n * If CONFIG_USERSPACE is disabled, allocate as plain static:\n *   static\n */\n#define RTIO_DMEM COND_CODE_1(CONFIG_USERSPACE, (K_APP_DMEM(rtio_partition) static), (static))\n\n#define Z_RTIO_BLOCK_POOL_DEFINE(name, blk_sz, blk_cnt, blk_align)                                 \\\n\tRTIO_BMEM uint8_t __aligned(WB_UP(blk_align))                                              \\\n\tCONCAT(_block_pool_, name)[blk_cnt*WB_UP(blk_sz)];                                         \\\n\t_SYS_MEM_BLOCKS_DEFINE_WITH_EXT_BUF(name, WB_UP(blk_sz), blk_cnt,                          \\\n\t\t\t\t\t    CONCAT(_block_pool_, name),\tRTIO_DMEM)\n\n#define Z_RTIO_DEFINE(name, _sqe_pool, _cqe_pool, _block_pool)                                     \\\n\tIF_ENABLED(CONFIG_RTIO_SUBMIT_SEM,                                                         \\\n\t\t   (static K_SEM_DEFINE(CONCAT(_submit_sem_, name), 0, K_SEM_MAX_LIMIT)))          \\\n\tIF_ENABLED(CONFIG_RTIO_CONSUME_SEM,                                                        \\\n\t\t   (static K_SEM_DEFINE(CONCAT(_consume_sem_, name), 0, K_SEM_MAX_LIMIT)))         \\\n\tSTRUCT_SECTION_ITERABLE(rtio, name) = {                                                    \\\n\t\tIF_ENABLED(CONFIG_RTIO_SUBMIT_SEM, (.submit_sem = &amp;CONCAT(_submit_sem_, name),))   \\\n\t\tIF_ENABLED(CONFIG_RTIO_SUBMIT_SEM, (.submit_count = 0,))                           \\\n\t\tIF_ENABLED(CONFIG_RTIO_CONSUME_SEM, (.consume_sem = &amp;CONCAT(_consume_sem_, name),))\\\n\t\t.cq_count = ATOMIC_INIT(0),                                                        \\\n\t\t.xcqcnt = ATOMIC_INIT(0),                                                          \\\n\t\t.sqe_pool = _sqe_pool,                                                             \\\n\t\t.cqe_pool = _cqe_pool,                                                             \\\n\t\tIF_ENABLED(CONFIG_RTIO_SYS_MEM_BLOCKS, (.block_pool = _block_pool,))               \\\n\t\t.sq = MPSC_INIT((name.sq)),                                                        \\\n\t\t.cq = MPSC_INIT((name.cq)),                                                        \\\n\t}\n\n/**\n * @brief Statically define and initialize an RTIO context\n *\n * @param name Name of the RTIO\n * @param sq_sz Size of the submission queue entry pool\n * @param cq_sz Size of the completion queue entry pool\n */\n#define RTIO_DEFINE(name, sq_sz, cq_sz)\t\t\t\t\t\t\\\n\tZ_RTIO_SQE_POOL_DEFINE(CONCAT(name, _sqe_pool), sq_sz);\t\t\t\\\n\tZ_RTIO_CQE_POOL_DEFINE(CONCAT(name, _cqe_pool), cq_sz);\t\t\t\\\n\tZ_RTIO_DEFINE(name, &amp;CONCAT(name, _sqe_pool),\t\t\t\t\\\n\t\t      &amp;CONCAT(name, _cqe_pool), NULL)\n\n/* clang-format on */\n\n/**\n * @brief Statically define and initialize an RTIO context\n *\n * @param name Name of the RTIO\n * @param sq_sz Size of the submission queue, must be power of 2\n * @param cq_sz Size of the completion queue, must be power of 2\n * @param num_blks Number of blocks in the memory pool\n * @param blk_size The number of bytes in each block\n * @param balign The block alignment\n */\n#define RTIO_DEFINE_WITH_MEMPOOL(name, sq_sz, cq_sz, num_blks, blk_size, balign) \\\n\tZ_RTIO_SQE_POOL_DEFINE(name##_sqe_pool, sq_sz);\t\t\\\n\tZ_RTIO_CQE_POOL_DEFINE(name##_cqe_pool, cq_sz);\t\t\t\\\n\tZ_RTIO_BLOCK_POOL_DEFINE(name##_block_pool, blk_size, num_blks, balign); \\\n\tZ_RTIO_DEFINE(name, &amp;name##_sqe_pool, &amp;name##_cqe_pool, &amp;name##_block_pool)\n\n/* clang-format on */\n\n/**\n * @brief Count of acquirable submission queue events\n *\n * @param r RTIO context\n *\n * @return Count of acquirable submission queue events\n */\nstatic inline uint32_t rtio_sqe_acquirable(struct rtio *r)\n{\n\treturn r-&gt;sqe_pool-&gt;pool_free;\n}\n\n/**\n * @brief Get the next sqe in the transaction\n *\n * @param iodev_sqe Submission queue entry\n *\n * @retval NULL if current sqe is last in transaction\n * @retval struct rtio_sqe * if available\n */\nstatic inline struct rtio_iodev_sqe *rtio_txn_next(const struct rtio_iodev_sqe *iodev_sqe)\n{\n\tif (iodev_sqe-&gt;sqe.flags &amp; RTIO_SQE_TRANSACTION) {\n\t\treturn iodev_sqe-&gt;next;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n\n/**\n * @brief Get the next sqe in the chain\n *\n * @param iodev_sqe Submission queue entry\n *\n * @retval NULL if current sqe is last in chain\n * @retval struct rtio_sqe * if available\n */\nstatic inline struct rtio_iodev_sqe *rtio_chain_next(const struct rtio_iodev_sqe *iodev_sqe)\n{\n\tif (iodev_sqe-&gt;sqe.flags &amp; RTIO_SQE_CHAINED) {\n\t\treturn iodev_sqe-&gt;next;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * @brief Get the next sqe in the chain or transaction\n *\n * @param iodev_sqe Submission queue entry\n *\n * @retval NULL if current sqe is last in chain\n * @retval struct rtio_iodev_sqe * if available\n */\nstatic inline struct rtio_iodev_sqe *rtio_iodev_sqe_next(const struct rtio_iodev_sqe *iodev_sqe)\n{\n\treturn iodev_sqe-&gt;next;\n}\n\n/**\n * @brief Acquire a single submission queue event if available\n *\n * @param r RTIO context\n *\n * @retval sqe A valid submission queue event acquired from the submission queue\n * @retval NULL No subsmission queue event available\n */\nstatic inline struct rtio_sqe *rtio_sqe_acquire(struct rtio *r)\n{\n\tstruct rtio_iodev_sqe *iodev_sqe = rtio_sqe_pool_alloc(r-&gt;sqe_pool);\n\n\tif (iodev_sqe == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmpsc_push(&amp;r-&gt;sq, &amp;iodev_sqe-&gt;q);\n\n\treturn &amp;iodev_sqe-&gt;sqe;\n}\n\n/**\n * @brief Drop all previously acquired sqe\n *\n * @param r RTIO context\n */\nstatic inline void rtio_sqe_drop_all(struct rtio *r)\n{\n\tstruct rtio_iodev_sqe *iodev_sqe;\n\tstruct mpsc_node *node = mpsc_pop(&amp;r-&gt;sq);\n\n\twhile (node != NULL) {\n\t\tiodev_sqe = CONTAINER_OF(node, struct rtio_iodev_sqe, q);\n\t\trtio_sqe_pool_free(r-&gt;sqe_pool, iodev_sqe);\n\t\tnode = mpsc_pop(&amp;r-&gt;sq);\n\t}\n}\n\n/**\n * @brief Acquire a complete queue event if available\n */\nstatic inline struct rtio_cqe *rtio_cqe_acquire(struct rtio *r)\n{\n\tstruct rtio_cqe *cqe = rtio_cqe_pool_alloc(r-&gt;cqe_pool);\n\n\tif (cqe == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemset(cqe, 0, sizeof(struct rtio_cqe));\n\n\treturn cqe;\n}\n\n/**\n * @brief Produce a complete queue event if available\n */\nstatic inline void rtio_cqe_produce(struct rtio *r, struct rtio_cqe *cqe)\n{\n\tmpsc_push(&amp;r-&gt;cq, &amp;cqe-&gt;q);\n}\n\n/**\n * @brief Consume a single completion queue event if available\n *\n * If a completion queue event is returned rtio_cq_release(r) must be called\n * at some point to release the cqe spot for the cqe producer.\n *\n * @param r RTIO context\n *\n * @retval cqe A valid completion queue event consumed from the completion queue\n * @retval NULL No completion queue event available\n */\nstatic inline struct rtio_cqe *rtio_cqe_consume(struct rtio *r)\n{\n\tstruct mpsc_node *node;\n\tstruct rtio_cqe *cqe = NULL;\n\n#ifdef CONFIG_RTIO_CONSUME_SEM\n\tif (k_sem_take(r-&gt;consume_sem, K_NO_WAIT) != 0) {\n\t\treturn NULL;\n\t}\n#endif\n\n\tnode = mpsc_pop(&amp;r-&gt;cq);\n\tif (node == NULL) {\n\t\treturn NULL;\n\t}\n\tcqe = CONTAINER_OF(node, struct rtio_cqe, q);\n\n\treturn cqe;\n}\n\n/**\n * @brief Wait for and consume a single completion queue event\n *\n * If a completion queue event is returned rtio_cq_release(r) must be called\n * at some point to release the cqe spot for the cqe producer.\n *\n * @param r RTIO context\n *\n * @retval cqe A valid completion queue event consumed from the completion queue\n */\nstatic inline struct rtio_cqe *rtio_cqe_consume_block(struct rtio *r)\n{\n\tstruct mpsc_node *node;\n\tstruct rtio_cqe *cqe;\n\n#ifdef CONFIG_RTIO_CONSUME_SEM\n\tk_sem_take(r-&gt;consume_sem, K_FOREVER);\n#endif\n\tnode = mpsc_pop(&amp;r-&gt;cq);\n\twhile (node == NULL) {\n\t\tZ_SPIN_DELAY(1);\n\t\tnode = mpsc_pop(&amp;r-&gt;cq);\n\t}\n\tcqe = CONTAINER_OF(node, struct rtio_cqe, q);\n\n\treturn cqe;\n}\n\n/**\n * @brief Release consumed completion queue event\n *\n * @param r RTIO context\n * @param cqe Completion queue entry\n */\nstatic inline void rtio_cqe_release(struct rtio *r, struct rtio_cqe *cqe)\n{\n\trtio_cqe_pool_free(r-&gt;cqe_pool, cqe);\n}\n\n/**\n * @brief Compute the CQE flags from the rtio_iodev_sqe entry\n *\n * @param iodev_sqe The SQE entry in question.\n * @return The value that should be set for the CQE&#x27;s flags field.\n */\nstatic inline uint32_t rtio_cqe_compute_flags(struct rtio_iodev_sqe *iodev_sqe)\n{\n\tuint32_t flags = 0;\n\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tif (iodev_sqe-&gt;sqe.op == RTIO_OP_RX &amp;&amp; iodev_sqe-&gt;sqe.flags &amp; RTIO_SQE_MEMPOOL_BUFFER) {\n\t\tstruct rtio *r = iodev_sqe-&gt;r;\n\t\tstruct sys_mem_blocks *mem_pool = r-&gt;block_pool;\n\t\tunsigned int blk_index = 0;\n\t\tunsigned int blk_count = 0;\n\n\t\tif (iodev_sqe-&gt;sqe.rx.buf) {\n\t\t\tblk_index = (iodev_sqe-&gt;sqe.rx.buf - mem_pool-&gt;buffer) &gt;&gt;\n\t\t\t\t    mem_pool-&gt;info.blk_sz_shift;\n\t\t\tblk_count = iodev_sqe-&gt;sqe.rx.buf_len &gt;&gt; mem_pool-&gt;info.blk_sz_shift;\n\t\t}\n\t\tflags = RTIO_CQE_FLAG_PREP_MEMPOOL(blk_index, blk_count);\n\t}\n#else\n\tARG_UNUSED(iodev_sqe);\n#endif\n\n\treturn flags;\n}\n\n/**\n * @brief Retrieve the mempool buffer that was allocated for the CQE.\n *\n * If the RTIO context contains a memory pool, and the SQE was created by calling\n * rtio_sqe_read_with_pool(), this function can be used to retrieve the memory associated with the\n * read. Once processing is done, it should be released by calling rtio_release_buffer().\n *\n * @param[in] r RTIO context\n * @param[in] cqe The CQE handling the event.\n * @param[out] buff Pointer to the mempool buffer\n * @param[out] buff_len Length of the allocated buffer\n * @return 0 on success\n * @return -EINVAL if the buffer wasn&#x27;t allocated for this cqe\n * @return -ENOTSUP if memory blocks are disabled\n */\n__syscall int rtio_cqe_get_mempool_buffer(const struct rtio *r, struct rtio_cqe *cqe,\n\t\t\t\t\t  uint8_t **buff, uint32_t *buff_len);\n\nstatic inline int z_impl_rtio_cqe_get_mempool_buffer(const struct rtio *r, struct rtio_cqe *cqe,\n\t\t\t\t\t\t     uint8_t **buff, uint32_t *buff_len)\n{\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tif (RTIO_CQE_FLAG_GET(cqe-&gt;flags) == RTIO_CQE_FLAG_MEMPOOL_BUFFER) {\n\t\tunsigned int blk_idx = RTIO_CQE_FLAG_MEMPOOL_GET_BLK_IDX(cqe-&gt;flags);\n\t\tunsigned int blk_count = RTIO_CQE_FLAG_MEMPOOL_GET_BLK_CNT(cqe-&gt;flags);\n\t\tuint32_t blk_size = rtio_mempool_block_size(r);\n\n\t\t*buff_len = blk_count * blk_size;\n\n\t\tif (blk_count &gt; 0) {\n\t\t\t*buff = r-&gt;block_pool-&gt;buffer + blk_idx * blk_size;\n\n\t\t\t__ASSERT_NO_MSG(*buff &gt;= r-&gt;block_pool-&gt;buffer);\n\t\t\t__ASSERT_NO_MSG(*buff &lt;\n\t\t\t\tr-&gt;block_pool-&gt;buffer + blk_size * r-&gt;block_pool-&gt;info.num_blocks);\n\t\t} else {\n\t\t\t*buff = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n#else\n\tARG_UNUSED(r);\n\tARG_UNUSED(cqe);\n\tARG_UNUSED(buff);\n\tARG_UNUSED(buff_len);\n\n\treturn -ENOTSUP;\n#endif\n}\n\nvoid rtio_executor_submit(struct rtio *r);\nvoid rtio_executor_ok(struct rtio_iodev_sqe *iodev_sqe, int result);\nvoid rtio_executor_err(struct rtio_iodev_sqe *iodev_sqe, int result);\n\n/**\n * @brief Inform the executor of a submission completion with success\n *\n * This may start the next asynchronous request if one is available.\n *\n * @param iodev_sqe IODev Submission that has succeeded\n * @param result Result of the request\n */\nstatic inline void rtio_iodev_sqe_ok(struct rtio_iodev_sqe *iodev_sqe, int result)\n{\n\trtio_executor_ok(iodev_sqe, result);\n}\n\n/**\n * @brief Inform the executor of a submissions completion with error\n *\n * This SHALL fail the remaining submissions in the chain.\n *\n * @param iodev_sqe Submission that has failed\n * @param result Result of the request\n */\nstatic inline void rtio_iodev_sqe_err(struct rtio_iodev_sqe *iodev_sqe, int result)\n{\n\trtio_executor_err(iodev_sqe, result);\n}\n\n/**\n * Submit a completion queue event with a given result and userdata\n *\n * Called by the executor to produce a completion queue event, no inherent\n * locking is performed and this is not safe to do from multiple callers.\n *\n * @param r RTIO context\n * @param result Integer result code (could be -errno)\n * @param userdata Userdata to pass along to completion\n * @param flags Flags to use for the CEQ see RTIO_CQE_FLAG_*\n */\nstatic inline void rtio_cqe_submit(struct rtio *r, int result, void *userdata, uint32_t flags)\n{\n\tstruct rtio_cqe *cqe = rtio_cqe_acquire(r);\n\n\tif (cqe == NULL) {\n\t\tatomic_inc(&amp;r-&gt;xcqcnt);\n\t} else {\n\t\tcqe-&gt;result = result;\n\t\tcqe-&gt;userdata = userdata;\n\t\tcqe-&gt;flags = flags;\n\t\trtio_cqe_produce(r, cqe);\n\t}\n\n\t/* atomic_t isn&#x27;t guaranteed to wrap correctly as it could be signed, so\n\t * we must resort to a cas loop.\n\t */\n\tatomic_t val, new_val;\n\n\tdo {\n\t\tval = atomic_get(&amp;r-&gt;cq_count);\n\t\tnew_val = (atomic_t)((uintptr_t)val + 1);\n\t} while (!atomic_cas(&amp;r-&gt;cq_count, val, new_val));\n\n#ifdef CONFIG_RTIO_SUBMIT_SEM\n\tif (r-&gt;submit_count &gt; 0) {\n\t\tr-&gt;submit_count--;\n\t\tif (r-&gt;submit_count == 0) {\n\t\t\tk_sem_give(r-&gt;submit_sem);\n\t\t}\n\t}\n#endif\n#ifdef CONFIG_RTIO_CONSUME_SEM\n\tk_sem_give(r-&gt;consume_sem);\n#endif\n}\n\n#define __RTIO_MEMPOOL_GET_NUM_BLKS(num_bytes, blk_size) (((num_bytes) + (blk_size)-1) / (blk_size))\n\n/**\n * @brief Get the buffer associate with the RX submission\n *\n * @param[in] iodev_sqe   The submission to probe\n * @param[in] min_buf_len The minimum number of bytes needed for the operation\n * @param[in] max_buf_len The maximum number of bytes needed for the operation\n * @param[out] buf        Where to store the pointer to the buffer\n * @param[out] buf_len    Where to store the size of the buffer\n *\n * @return 0 if @p buf and @p buf_len were successfully filled\n * @return -ENOMEM Not enough memory for @p min_buf_len\n */\nstatic inline int rtio_sqe_rx_buf(const struct rtio_iodev_sqe *iodev_sqe, uint32_t min_buf_len,\n\t\t\t\t  uint32_t max_buf_len, uint8_t **buf, uint32_t *buf_len)\n{\n\tstruct rtio_sqe *sqe = (struct rtio_sqe *)&amp;iodev_sqe-&gt;sqe;\n\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tif (sqe-&gt;op == RTIO_OP_RX &amp;&amp; sqe-&gt;flags &amp; RTIO_SQE_MEMPOOL_BUFFER) {\n\t\tstruct rtio *r = iodev_sqe-&gt;r;\n\n\t\tif (sqe-&gt;rx.buf != NULL) {\n\t\t\tif (sqe-&gt;rx.buf_len &lt; min_buf_len) {\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\t*buf = sqe-&gt;rx.buf;\n\t\t\t*buf_len = sqe-&gt;rx.buf_len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tint rc = rtio_block_pool_alloc(r, min_buf_len, max_buf_len, buf, buf_len);\n\t\tif (rc == 0) {\n\t\t\tsqe-&gt;rx.buf = *buf;\n\t\t\tsqe-&gt;rx.buf_len = *buf_len;\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn -ENOMEM;\n\t}\n#else\n\tARG_UNUSED(max_buf_len);\n#endif\n\n\tif (sqe-&gt;rx.buf_len &lt; min_buf_len) {\n\t\treturn -ENOMEM;\n\t}\n\n\t*buf = sqe-&gt;rx.buf;\n\t*buf_len = sqe-&gt;rx.buf_len;\n\treturn 0;\n}\n\n/**\n * @brief Release memory that was allocated by the RTIO&#x27;s memory pool\n *\n * If the RTIO context was created by a call to RTIO_DEFINE_WITH_MEMPOOL(), then the cqe data might\n * contain a buffer that&#x27;s owned by the RTIO context. In those cases (if the read request was\n * configured via rtio_sqe_read_with_pool()) the buffer must be returned back to the pool.\n *\n * Call this function when processing is complete. This function will validate that the memory\n * actually belongs to the RTIO context and will ignore invalid arguments.\n *\n * @param r RTIO context\n * @param buff Pointer to the buffer to be released.\n * @param buff_len Number of bytes to free (will be rounded up to nearest memory block).\n */\n__syscall void rtio_release_buffer(struct rtio *r, void *buff, uint32_t buff_len);\n\nstatic inline void z_impl_rtio_release_buffer(struct rtio *r, void *buff, uint32_t buff_len)\n{\n#ifdef CONFIG_RTIO_SYS_MEM_BLOCKS\n\tif (r == NULL || buff == NULL || r-&gt;block_pool == NULL || buff_len == 0) {\n\t\treturn;\n\t}\n\n\trtio_block_pool_free(r, buff, buff_len);\n#else\n\tARG_UNUSED(r);\n\tARG_UNUSED(buff);\n\tARG_UNUSED(buff_len);\n#endif\n}\n\n/**\n * Grant access to an RTIO context to a user thread\n */\nstatic inline void rtio_access_grant(struct rtio *r, struct k_thread *t)\n{\n\tk_object_access_grant(r, t);\n\n#ifdef CONFIG_RTIO_SUBMIT_SEM\n\tk_object_access_grant(r-&gt;submit_sem, t);\n#endif\n\n#ifdef CONFIG_RTIO_CONSUME_SEM\n\tk_object_access_grant(r-&gt;consume_sem, t);\n#endif\n}\n\n/**\n * @brief Attempt to cancel an SQE\n *\n * If possible (not currently executing), cancel an SQE and generate a failure with -ECANCELED\n * result.\n *\n * @param[in] sqe The SQE to cancel\n * @return 0 if the SQE was flagged for cancellation\n * @return &lt;0 on error\n */\n__syscall int rtio_sqe_cancel(struct rtio_sqe *sqe);\n\nstatic inline int z_impl_rtio_sqe_cancel(struct rtio_sqe *sqe)\n{\n\tstruct rtio_iodev_sqe *iodev_sqe = CONTAINER_OF(sqe, struct rtio_iodev_sqe, sqe);\n\n\tdo {\n\t\tiodev_sqe-&gt;sqe.flags |= RTIO_SQE_CANCELED;\n\t\tiodev_sqe = rtio_iodev_sqe_next(iodev_sqe);\n\t} while (iodev_sqe != NULL);\n\n\treturn 0;\n}\n\n/**\n * @brief Signal an AWAIT SQE\n *\n * If the SQE is currently blocking execution, execution is unblocked. If the SQE is not\n * currently blocking execution, The SQE will be skipped.\n *\n * @note To await the AWAIT SQE blocking execution, chain a nop or callback SQE before\n * the await SQE.\n *\n * @param[in] sqe The SQE to signal\n */\n__syscall void rtio_sqe_signal(struct rtio_sqe *sqe);\n\nstatic inline void z_impl_rtio_sqe_signal(struct rtio_sqe *sqe)\n{\n\tstruct rtio_iodev_sqe *iodev_sqe = CONTAINER_OF(sqe, struct rtio_iodev_sqe, sqe);\n\n\tif (!atomic_cas(&amp;iodev_sqe-&gt;sqe.await.ok, 0, 1)) {\n\t\tiodev_sqe-&gt;sqe.await.callback(iodev_sqe, iodev_sqe-&gt;sqe.await.userdata);\n\t}\n}\n\n/**\n * @brief Await an AWAIT SQE signal from RTIO IODEV\n *\n * If the SQE is already signaled, the callback is called immediately. Otherwise the\n * callback will be called once the AWAIT SQE is signaled.\n *\n * @param[in] iodev_sqe The IODEV SQE to await signaled\n * @param[in] callback Callback called when SQE is signaled\n * @param[in] userdata User data passed to callback\n */\nstatic inline void rtio_iodev_sqe_await_signal(struct rtio_iodev_sqe *iodev_sqe,\n\t\t\t\t\t       rtio_signaled_t callback,\n\t\t\t\t\t       void *userdata)\n{\n\tiodev_sqe-&gt;sqe.await.callback = callback;\n\tiodev_sqe-&gt;sqe.await.userdata = userdata;\n\n\tif (!atomic_cas(&amp;iodev_sqe-&gt;sqe.await.ok, 0, 1)) {\n\t\tcallback(iodev_sqe, userdata);\n\t}\n}\n\n/**\n * @brief Copy an array of SQEs into the queue and get resulting handles back\n *\n * Copies one or more SQEs into the RTIO context and optionally returns their generated SQE handles.\n * Handles can be used to cancel events via the rtio_sqe_cancel() call.\n *\n * @param[in]  r RTIO context\n * @param[in]  sqes Pointer to an array of SQEs\n * @param[out] handle Optional pointer to @ref rtio_sqe pointer to store the handle of the\n *             first generated SQE. Use NULL to ignore.\n * @param[in]  sqe_count Count of sqes in array\n *\n * @retval 0 success\n * @retval -ENOMEM not enough room in the queue\n */\n__syscall int rtio_sqe_copy_in_get_handles(struct rtio *r, const struct rtio_sqe *sqes,\n\t\t\t\t\t   struct rtio_sqe **handle, size_t sqe_count);\n\nstatic inline int z_impl_rtio_sqe_copy_in_get_handles(struct rtio *r, const struct rtio_sqe *sqes,\n\t\t\t\t\t\t      struct rtio_sqe **handle,\n\t\t\t\t\t\t      size_t sqe_count)\n{\n\tstruct rtio_sqe *sqe;\n\tuint32_t acquirable = rtio_sqe_acquirable(r);\n\n\tif (acquirable &lt; sqe_count) {\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (unsigned long i = 0; i &lt; sqe_count; i++) {\n\t\tsqe = rtio_sqe_acquire(r);\n\t\t__ASSERT_NO_MSG(sqe != NULL);\n\t\tif (handle != NULL &amp;&amp; i == 0) {\n\t\t\t*handle = sqe;\n\t\t}\n\t\t*sqe = sqes[i];\n\t}\n\n\treturn 0;\n}\n\n/**\n * @brief Copy an array of SQEs into the queue\n *\n * Useful if a batch of submissions is stored in ROM or\n * RTIO is used from user mode where a copy must be made.\n *\n * Partial copying is not done as chained SQEs need to be submitted\n * as a whole set.\n *\n * @param r RTIO context\n * @param sqes Pointer to an array of SQEs\n * @param sqe_count Count of sqes in array\n *\n * @retval 0 success\n * @retval -ENOMEM not enough room in the queue\n */\nstatic inline int rtio_sqe_copy_in(struct rtio *r, const struct rtio_sqe *sqes, size_t sqe_count)\n{\n\treturn rtio_sqe_copy_in_get_handles(r, sqes, NULL, sqe_count);\n}\n\n/**\n * @brief Copy an array of CQEs from the queue\n *\n * Copies from the RTIO context and its queue completion queue\n * events, waiting for the given time period to gather the number\n * of completions requested.\n *\n * @param r RTIO context\n * @param cqes Pointer to an array of SQEs\n * @param cqe_count Count of sqes in array\n * @param timeout Timeout to wait for each completion event. Total wait time is\n *                potentially timeout*cqe_count at maximum.\n *\n * @retval copy_count Count of copied CQEs (0 to cqe_count)\n */\n__syscall int rtio_cqe_copy_out(struct rtio *r,\n\t\t\t\tstruct rtio_cqe *cqes,\n\t\t\t\tsize_t cqe_count,\n\t\t\t\tk_timeout_t timeout);\nstatic inline int z_impl_rtio_cqe_copy_out(struct rtio *r,\n\t\t\t\t\t   struct rtio_cqe *cqes,\n\t\t\t\t\t   size_t cqe_count,\n\t\t\t\t\t   k_timeout_t timeout)\n{\n\tsize_t copied = 0;\n\tstruct rtio_cqe *cqe;\n\tk_timepoint_t end = sys_timepoint_calc(timeout);\n\n\tdo {\n\t\tcqe = K_TIMEOUT_EQ(timeout, K_FOREVER) ? rtio_cqe_consume_block(r)\n\t\t\t\t\t\t       : rtio_cqe_consume(r);\n\t\tif (cqe == NULL) {\n\t\t\tZ_SPIN_DELAY(25);\n\t\t\tcontinue;\n\t\t}\n\t\tcqes[copied++] = *cqe;\n\t\trtio_cqe_release(r, cqe);\n\t} while (copied &lt; cqe_count &amp;&amp; !sys_timepoint_expired(end));\n\n\treturn copied;\n}\n\n/**\n * @brief Submit I/O requests to the underlying executor\n *\n * Submits the queue of submission queue events to the executor.\n * The executor will do the work of managing tasks representing each\n * submission chain, freeing submission queue events when done, and\n * producing completion queue events as submissions are completed.\n *\n * @warning It is undefined behavior to have re-entrant calls to submit\n *\n * @param r RTIO context\n * @param wait_count Number of submissions to wait for completion of.\n *\n * @retval 0 On success\n */\n__syscall int rtio_submit(struct rtio *r, uint32_t wait_count);\n\n#ifdef CONFIG_RTIO_SUBMIT_SEM\nstatic inline int z_impl_rtio_submit(struct rtio *r, uint32_t wait_count)\n{\n\tint res = 0;\n\n\tif (wait_count &gt; 0) {\n\t\t__ASSERT(!k_is_in_isr(),\n\t\t\t &quot;expected rtio submit with wait count to be called from a thread&quot;);\n\n\t\tk_sem_reset(r-&gt;submit_sem);\n\t\tr-&gt;submit_count = wait_count;\n\t}\n\n\trtio_executor_submit(r);\n\n\tif (wait_count &gt; 0) {\n\t\tres = k_sem_take(r-&gt;submit_sem, K_FOREVER);\n\t\t__ASSERT(res == 0,\n\t\t\t &quot;semaphore was reset or timed out while waiting on completions!&quot;);\n\t}\n\n\treturn res;\n}\n#else\nstatic inline int z_impl_rtio_submit(struct rtio *r, uint32_t wait_count)\n{\n\n\tint res = 0;\n\tuintptr_t cq_count = (uintptr_t)atomic_get(&amp;r-&gt;cq_count);\n\tuintptr_t cq_complete_count = cq_count + wait_count;\n\tbool wraps = cq_complete_count &lt; cq_count;\n\n\trtio_executor_submit(r);\n\n\tif (wraps) {\n\t\twhile ((uintptr_t)atomic_get(&amp;r-&gt;cq_count) &gt;= cq_count) {\n\t\t\tZ_SPIN_DELAY(10);\n\t\t\tk_yield();\n\t\t}\n\t}\n\n\twhile ((uintptr_t)atomic_get(&amp;r-&gt;cq_count) &lt; cq_complete_count) {\n\t\tZ_SPIN_DELAY(10);\n\t\tk_yield();\n\t}\n\n\treturn res;\n}\n#endif /* CONFIG_RTIO_SUBMIT_SEM */\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#include &lt;zephyr/syscalls/rtio.h&gt;\n\n#endif /* ZEPHYR_INCLUDE_RTIO_RTIO_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "content": "/*\n * Copyright (c) 2018 Intel Corporation.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file\n * @brief Public interface for spinlocks\n */\n\n#ifndef ZEPHYR_INCLUDE_SPINLOCK_H_\n#define ZEPHYR_INCLUDE_SPINLOCK_H_\n\n#include &lt;errno.h&gt;\n#include &lt;stdbool.h&gt;\n\n#include &lt;zephyr/arch/cpu.h&gt;\n#include &lt;zephyr/sys/atomic.h&gt;\n#include &lt;zephyr/sys/__assert.h&gt;\n#include &lt;zephyr/sys/time_units.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @brief Spinlock APIs\n * @defgroup spinlock_apis Spinlock APIs\n * @ingroup kernel_apis\n * @{\n */\n\nstruct z_spinlock_key {\n\tint key;\n};\n\n/**\n * @brief Kernel Spin Lock\n *\n * This struct defines a spin lock record on which CPUs can wait with\n * k_spin_lock().  Any number of spinlocks may be defined in\n * application code.\n */\nstruct k_spinlock {\n/**\n * @cond INTERNAL_HIDDEN\n */\n#ifdef CONFIG_SMP\n#ifdef CONFIG_TICKET_SPINLOCKS\n\t/*\n\t * Ticket spinlocks are conceptually two atomic variables,\n\t * one indicating the current FIFO head (spinlock owner),\n\t * and the other indicating the current FIFO tail.\n\t * Spinlock is acquired in the following manner:\n\t * - current FIFO tail value is atomically incremented while it&#x27;s\n\t *   original value is saved as a &quot;ticket&quot;\n\t * - we spin until the FIFO head becomes equal to the ticket value\n\t *\n\t * Spinlock is released by atomic increment of the FIFO head\n\t */\n\tatomic_t owner;\n\tatomic_t tail;\n#else\n\tatomic_t locked;\n#endif /* CONFIG_TICKET_SPINLOCKS */\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_SPIN_VALIDATE\n\t/* Stores the thread that holds the lock with the locking CPU\n\t * ID in the bottom two bits.\n\t */\n\tuintptr_t thread_cpu;\n#ifdef CONFIG_SPIN_LOCK_TIME_LIMIT\n\t/* Stores the time (in cycles) when a lock was taken\n\t */\n\tuint32_t lock_time;\n#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */\n#endif /* CONFIG_SPIN_VALIDATE */\n\n#if defined(CONFIG_CPP) &amp;&amp; !defined(CONFIG_SMP) &amp;&amp; \\\n\t!defined(CONFIG_SPIN_VALIDATE)\n\t/* If CONFIG_SMP and CONFIG_SPIN_VALIDATE are both not defined\n\t * the k_spinlock struct will have no members. The result\n\t * is that in C sizeof(k_spinlock) is 0 and in C++ it is 1.\n\t *\n\t * This size difference causes problems when the k_spinlock\n\t * is embedded into another struct like k_msgq, because C and\n\t * C++ will have different ideas on the offsets of the members\n\t * that come after the k_spinlock member.\n\t *\n\t * To prevent this we add a 1 byte dummy member to k_spinlock\n\t * when the user selects C++ support and k_spinlock would\n\t * otherwise be empty.\n\t */\n\tchar dummy;\n#endif\n/**\n * INTERNAL_HIDDEN @endcond\n */\n};\n\n/* There&#x27;s a spinlock validation framework available when asserts are\n * enabled.  It adds a relatively hefty overhead (about 3k or so) to\n * kernel code size, don&#x27;t use on platforms known to be small.\n */\n#ifdef CONFIG_SPIN_VALIDATE\nbool z_spin_lock_valid(struct k_spinlock *l);\nbool z_spin_unlock_valid(struct k_spinlock *l);\nvoid z_spin_lock_set_owner(struct k_spinlock *l);\nBUILD_ASSERT(CONFIG_MP_MAX_NUM_CPUS &lt;= 4, &quot;Too many CPUs for mask&quot;);\n\n# ifdef CONFIG_KERNEL_COHERENCE\nbool z_spin_lock_mem_coherent(struct k_spinlock *l);\n# endif /* CONFIG_KERNEL_COHERENCE */\n\n#endif /* CONFIG_SPIN_VALIDATE */\n\n/**\n * @brief Spinlock key type\n *\n * This type defines a &quot;key&quot; value used by a spinlock implementation\n * to store the system interrupt state at the time of a call to\n * k_spin_lock().  It is expected to be passed to a matching\n * k_spin_unlock().\n *\n * This type is opaque and should not be inspected by application\n * code.\n */\ntypedef struct z_spinlock_key k_spinlock_key_t;\n\nstatic ALWAYS_INLINE void z_spinlock_validate_pre(struct k_spinlock *l)\n{\n\tARG_UNUSED(l);\n#ifdef CONFIG_SPIN_VALIDATE\n\t__ASSERT(z_spin_lock_valid(l), &quot;Invalid spinlock %p&quot;, l);\n#ifdef CONFIG_KERNEL_COHERENCE\n\t__ASSERT_NO_MSG(z_spin_lock_mem_coherent(l));\n#endif\n#endif\n}\n\nstatic ALWAYS_INLINE void z_spinlock_validate_post(struct k_spinlock *l)\n{\n\tARG_UNUSED(l);\n#ifdef CONFIG_SPIN_VALIDATE\n\tz_spin_lock_set_owner(l);\n#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) &amp;&amp; (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)\n\tl-&gt;lock_time = sys_clock_cycle_get_32();\n#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */\n#endif /* CONFIG_SPIN_VALIDATE */\n}\n\n/**\n * @brief Lock a spinlock\n *\n * This routine locks the specified spinlock, returning a key handle\n * representing interrupt state needed at unlock time.  Upon\n * returning, the calling thread is guaranteed not to be suspended or\n * interrupted on its current CPU until it calls k_spin_unlock().  The\n * implementation guarantees mutual exclusion: exactly one thread on\n * one CPU will return from k_spin_lock() at a time.  Other CPUs\n * trying to acquire a lock already held by another CPU will enter an\n * implementation-defined busy loop (&quot;spinning&quot;) until the lock is\n * released.\n *\n * Separate spin locks may be nested. It is legal to lock an\n * (unlocked) spin lock while holding a different lock.  Spin locks\n * are not recursive, however: an attempt to acquire a spin lock that\n * the CPU already holds will deadlock.\n *\n * In circumstances where only one CPU exists, the behavior of\n * k_spin_lock() remains as specified above, though obviously no\n * spinning will take place.  Implementations may be free to optimize\n * in uniprocessor contexts such that the locking reduces to an\n * interrupt mask operation.\n *\n * @param l A pointer to the spinlock to lock\n * @return A key value that must be passed to k_spin_unlock() when the\n *         lock is released.\n */\nstatic ALWAYS_INLINE k_spinlock_key_t k_spin_lock(struct k_spinlock *l)\n{\n\tARG_UNUSED(l);\n\tk_spinlock_key_t k;\n\n\t/* Note that we need to use the underlying arch-specific lock\n\t * implementation.  The &quot;irq_lock()&quot; API in SMP context is\n\t * actually a wrapper for a global spinlock!\n\t */\n\tk.key = arch_irq_lock();\n\n\tz_spinlock_validate_pre(l);\n#ifdef CONFIG_SMP\n#ifdef CONFIG_TICKET_SPINLOCKS\n\t/*\n\t * Enqueue ourselves to the end of a spinlock waiters queue\n\t * receiving a ticket\n\t */\n\tatomic_val_t ticket = atomic_inc(&amp;l-&gt;tail);\n\t/* Spin until our ticket is served */\n\twhile (atomic_get(&amp;l-&gt;owner) != ticket) {\n\t\tarch_spin_relax();\n\t}\n#else\n\twhile (!atomic_cas(&amp;l-&gt;locked, 0, 1)) {\n\t\tarch_spin_relax();\n\t}\n#endif /* CONFIG_TICKET_SPINLOCKS */\n#endif /* CONFIG_SMP */\n\tz_spinlock_validate_post(l);\n\n\treturn k;\n}\n\n/**\n * @brief Attempt to lock a spinlock\n *\n * This routine makes one attempt to lock @p l. If it is successful, then\n * it will store the key into @p k.\n *\n * @param[in] l A pointer to the spinlock to lock\n * @param[out] k A pointer to the spinlock key\n * @retval 0 on success\n * @retval -EBUSY if another thread holds the lock\n *\n * @see k_spin_lock\n * @see k_spin_unlock\n */\nstatic ALWAYS_INLINE int k_spin_trylock(struct k_spinlock *l, k_spinlock_key_t *k)\n{\n\tint key = arch_irq_lock();\n\n\tz_spinlock_validate_pre(l);\n#ifdef CONFIG_SMP\n#ifdef CONFIG_TICKET_SPINLOCKS\n\t/*\n\t * atomic_get and atomic_cas operations below are not executed\n\t * simultaneously.\n\t * So in theory k_spin_trylock can lock an already locked spinlock.\n\t * To reproduce this the following conditions should be met after we\n\t * executed atomic_get and before we executed atomic_cas:\n\t *\n\t * - spinlock needs to be taken 0xffff_..._ffff + 1 times\n\t * (which requires 0xffff_..._ffff number of CPUs, as k_spin_lock call\n\t * is blocking) or\n\t * - spinlock needs to be taken and released 0xffff_..._ffff times and\n\t * then taken again\n\t *\n\t * In real-life systems this is considered non-reproducible given that\n\t * required actions need to be done during this tiny window of several\n\t * CPU instructions (which execute with interrupt locked,\n\t * so no preemption can happen here)\n\t */\n\tatomic_val_t ticket_val = atomic_get(&amp;l-&gt;owner);\n\n\tif (!atomic_cas(&amp;l-&gt;tail, ticket_val, ticket_val + 1)) {\n\t\tgoto busy;\n\t}\n#else\n\tif (!atomic_cas(&amp;l-&gt;locked, 0, 1)) {\n\t\tgoto busy;\n\t}\n#endif /* CONFIG_TICKET_SPINLOCKS */\n#endif /* CONFIG_SMP */\n\tz_spinlock_validate_post(l);\n\n\tk-&gt;key = key;\n\n\treturn 0;\n\n#ifdef CONFIG_SMP\nbusy:\n\tarch_irq_unlock(key);\n\treturn -EBUSY;\n#endif /* CONFIG_SMP */\n}\n\n/**\n * @brief Unlock a spin lock\n *\n * This releases a lock acquired by k_spin_lock().  After this\n * function is called, any CPU will be able to acquire the lock.  If\n * other CPUs are currently spinning inside k_spin_lock() waiting for\n * this lock, exactly one of them will return synchronously with the\n * lock held.\n *\n * Spin locks must be properly nested.  A call to k_spin_unlock() must\n * be made on the lock object most recently locked using\n * k_spin_lock(), using the key value that it returned.  Attempts to\n * unlock mis-nested locks, or to unlock locks that are not held, or\n * to passing a key parameter other than the one returned from\n * k_spin_lock(), are illegal.  When CONFIG_SPIN_VALIDATE is set, some\n * of these errors can be detected by the framework.\n *\n * @param l A pointer to the spinlock to release\n * @param key The value returned from k_spin_lock() when this lock was\n *        acquired\n */\nstatic ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,\n\t\t\t\t\tk_spinlock_key_t key)\n{\n\tARG_UNUSED(l);\n#ifdef CONFIG_SPIN_VALIDATE\n\t__ASSERT(z_spin_unlock_valid(l), &quot;Not my spinlock %p&quot;, l);\n\n#if defined(CONFIG_SPIN_LOCK_TIME_LIMIT) &amp;&amp; (CONFIG_SPIN_LOCK_TIME_LIMIT != 0)\n\tuint32_t delta = sys_clock_cycle_get_32() - l-&gt;lock_time;\n\n\t__ASSERT(delta &lt; CONFIG_SPIN_LOCK_TIME_LIMIT,\n\t\t &quot;Spin lock %p held %u cycles, longer than limit of %u cycles&quot;,\n\t\t l, delta, CONFIG_SPIN_LOCK_TIME_LIMIT);\n#endif /* CONFIG_SPIN_LOCK_TIME_LIMIT */\n#endif /* CONFIG_SPIN_VALIDATE */\n\n#ifdef CONFIG_SMP\n#ifdef CONFIG_TICKET_SPINLOCKS\n\t/* Give the spinlock to the next CPU in a FIFO */\n\t(void)atomic_inc(&amp;l-&gt;owner);\n#else\n\t/* Strictly we don&#x27;t need atomic_clear() here (which is an\n\t * exchange operation that returns the old value).  We are always\n\t * setting a zero and (because we hold the lock) know the existing\n\t * state won&#x27;t change due to a race.  But some architectures need\n\t * a memory barrier when used like this, and we don&#x27;t have a\n\t * Zephyr framework for that.\n\t */\n\t(void)atomic_clear(&amp;l-&gt;locked);\n#endif /* CONFIG_TICKET_SPINLOCKS */\n#endif /* CONFIG_SMP */\n\tarch_irq_unlock(key.key);\n}\n\n/**\n * @cond INTERNAL_HIDDEN\n */\n\n#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_TEST)\n/*\n * @brief Checks if spinlock is held by some CPU, including the local CPU.\n *\t\tThis API shouldn&#x27;t be used outside the tests for spinlock\n *\n * @param l A pointer to the spinlock\n * @retval true - if spinlock is held by some CPU; false - otherwise\n */\nstatic ALWAYS_INLINE bool z_spin_is_locked(struct k_spinlock *l)\n{\n#ifdef CONFIG_TICKET_SPINLOCKS\n\tatomic_val_t ticket_val = atomic_get(&amp;l-&gt;owner);\n\n\treturn !atomic_cas(&amp;l-&gt;tail, ticket_val, ticket_val);\n#else\n\treturn l-&gt;locked;\n#endif /* CONFIG_TICKET_SPINLOCKS */\n}\n#endif /* defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_TEST) */\n\n/* Internal function: releases the lock, but leaves local interrupts disabled */\nstatic ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)\n{\n\tARG_UNUSED(l);\n#ifdef CONFIG_SPIN_VALIDATE\n\t__ASSERT(z_spin_unlock_valid(l), &quot;Not my spinlock %p&quot;, l);\n#endif\n#ifdef CONFIG_SMP\n#ifdef CONFIG_TICKET_SPINLOCKS\n\t(void)atomic_inc(&amp;l-&gt;owner);\n#else\n\t(void)atomic_clear(&amp;l-&gt;locked);\n#endif /* CONFIG_TICKET_SPINLOCKS */\n#endif /* CONFIG_SMP */\n}\n\n#if defined(CONFIG_SPIN_VALIDATE) &amp;&amp; defined(__GNUC__)\nstatic ALWAYS_INLINE void z_spin_onexit(__maybe_unused k_spinlock_key_t *k)\n{\n\t__ASSERT(k-&gt;key, &quot;K_SPINLOCK exited with goto, break or return, &quot;\n\t\t\t &quot;use K_SPINLOCK_BREAK instead.&quot;);\n}\n#define K_SPINLOCK_ONEXIT __attribute__((__cleanup__(z_spin_onexit)))\n#else\n#define K_SPINLOCK_ONEXIT\n#endif\n\n/**\n * INTERNAL_HIDDEN @endcond\n */\n\n/**\n * @brief Leaves a code block guarded with @ref K_SPINLOCK after releasing the\n * lock.\n *\n * See @ref K_SPINLOCK for details.\n */\n#define K_SPINLOCK_BREAK continue\n\n/**\n * @brief Guards a code block with the given spinlock, automatically acquiring\n * the lock before executing the code block. The lock will be released either\n * when reaching the end of the code block or when leaving the block with\n * @ref K_SPINLOCK_BREAK.\n *\n * @details Example usage:\n *\n * @code{.c}\n * K_SPINLOCK(&amp;mylock) {\n *\n *   ...execute statements with the lock held...\n *\n *   if (some_condition) {\n *     ...release the lock and leave the guarded section prematurely:\n *     K_SPINLOCK_BREAK;\n *   }\n *\n *   ...execute statements with the lock held...\n *\n * }\n * @endcode\n *\n * Behind the scenes this pattern expands to a for-loop whose body is executed\n * exactly once:\n *\n * @code{.c}\n * for (k_spinlock_key_t key = k_spin_lock(&amp;mylock); ...; k_spin_unlock(&amp;mylock, key)) {\n *     ...\n * }\n * @endcode\n *\n * @warning The code block must execute to its end or be left by calling\n * @ref K_SPINLOCK_BREAK. Otherwise, e.g. if exiting the block with a break,\n * goto or return statement, the spinlock will not be released on exit.\n *\n * @note In user mode the spinlock must be placed in memory accessible to the\n * application, see @ref K_APP_DMEM and @ref K_APP_BMEM macros for details.\n *\n * @param lck Spinlock used to guard the enclosed code block.\n */\n#define K_SPINLOCK(lck)                                                                            \\\n\tfor (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key;      \\\n\t     k_spin_unlock((lck), __key), __i.key = 1)\n\n/** @} */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZEPHYR_INCLUDE_SPINLOCK_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h", "content": "/*\n * Copyright (c) 2020 Nordic Semiconductor ASA\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_INCLUDE_SYS_CBPRINTF_H_\n#define ZEPHYR_INCLUDE_SYS_CBPRINTF_H_\n\n#include &lt;stdarg.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;zephyr/toolchain.h&gt;\n#include &lt;string.h&gt;\n\n#ifdef CONFIG_CBPRINTF_LIBC_SUBSTS\n#include &lt;stdio.h&gt;\n#endif /* CONFIG_CBPRINTF_LIBC_SUBSTS */\n\n/* Determine if _Generic is supported using macro from toolchain.h.\n *\n * @note Z_C_GENERIC is also set for C++ where functionality is implemented\n * using overloading and templates.\n */\n#ifndef Z_C_GENERIC\n#if defined(__cplusplus) || TOOLCHAIN_HAS_C_GENERIC\n#define Z_C_GENERIC 1\n#else\n#define Z_C_GENERIC 0\n#endif\n#endif\n\n#ifdef __xtensa__\n#define Z_PKG_HDR_EXT_XTENSA_ALIGNMENT 8\n#ifdef CONFIG_CBPRINTF_PACKAGE_HEADER_STORE_CREATION_FLAGS\n#define Z_PKG_DESC_XTENSA_PADDING 1\n#else\n#define Z_PKG_DESC_XTENSA_PADDING 0\n#endif\n#endif /* __xtensa__ */\n\n/**\n * @brief cbprintf package descriptor.\n */\nstruct cbprintf_package_desc {\n\t/** Package length (in 32 bit words) */\n\tuint8_t len;\n\n\t/** Number of appended strings in the package. */\n\tuint8_t str_cnt;\n\n\t/** Number of read-only strings, indexes appended to the package */\n\tuint8_t ro_str_cnt;\n\n\t/** Number of read-write strings, indexes appended to the package */\n\tuint8_t rw_str_cnt;\n\n#ifdef CONFIG_CBPRINTF_PACKAGE_HEADER_STORE_CREATION_FLAGS\n\t/** Flags used to create the package */\n\tuint32_t pkg_flags;\n#endif\n#ifdef __xtensa__\n\t/*\n\t * On Xtensa, the first argument needs to be aligned to 8-byte.\n\t * With 32-bit pointers, we need another 4 bytes padding so\n\t * that whole struct cbprintf_package_hdr_ext is of multiple of\n\t * 8 bytes.\n\t */\n\tuint32_t xtensa_padding[Z_PKG_DESC_XTENSA_PADDING];\n#endif\n\n} __packed;\n\n/** @brief cbprintf package header\n *\n * cbprintf package header, without the format string pointer.\n */\nunion cbprintf_package_hdr {\n\t/** Header description */\n\tstruct cbprintf_package_desc desc;\n\n\tvoid *raw;\n\n#if defined(CONFIG_CBPRINTF_PACKAGE_HEADER_STORE_CREATION_FLAGS) &amp;&amp; !defined(CONFIG_64BIT)\n\tvoid *raw2[2];\n#endif\n\n} __packed;\n\n\n\n/** @brief cbprintf package header with format string pointer.\n *\n * cbprintf package header with format string pointer.\n */\nstruct cbprintf_package_hdr_ext {\n\t/** Header of package */\n\tunion cbprintf_package_hdr hdr;\n\n\t/** Pointer to format string */\n\tchar *fmt;\n\n\t/*\n\t * When extending this struct, make sure this align\n\t * to pointer size.\n\t */\n} __packed;\n\n\n/**\n * @cond INTERNAL_HIDDEN\n *\n * Assert that the package hdr does indeed align properly.\n */\n#ifdef __xtensa__\nBUILD_ASSERT(sizeof(struct cbprintf_package_hdr_ext) % Z_PKG_HDR_EXT_XTENSA_ALIGNMENT == 0,\n\t     &quot;Package header size on Xtensa must be aligned&quot;);\n#endif\n/**\n * @endcond\n */\n\n/* Z_C_GENERIC is used there */\n#include &lt;zephyr/sys/cbprintf_internal.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @defgroup cbprintf_apis Formatted Output APIs\n * @ingroup utilities\n * @{\n */\n\n/** @brief Required alignment of the buffer used for packaging. */\n#ifdef __xtensa__\n#define CBPRINTF_PACKAGE_ALIGNMENT 16\n#else\n#define CBPRINTF_PACKAGE_ALIGNMENT \\\n\tZ_POW2_CEIL(COND_CODE_1(CONFIG_CBPRINTF_PACKAGE_LONGDOUBLE, \\\n\t\t(sizeof(long double)), (MAX(sizeof(double), sizeof(long long)))))\n#endif\n\nBUILD_ASSERT(Z_IS_POW2(CBPRINTF_PACKAGE_ALIGNMENT));\n\n\n/**@defgroup CBPRINTF_PACKAGE_FLAGS Package flags\n * @{\n */\n\n/** @brief Assume that const char pointer is pointing to read only (constant) strings.\n *\n * Flag is valid only for @ref CBPRINTF_STATIC_PACKAGE.\n */\n#define CBPRINTF_PACKAGE_CONST_CHAR_RO BIT(0)\n\n/** @brief Append locations (within the package) of read-only string pointers. */\n#define CBPRINTF_PACKAGE_ADD_RO_STR_POS BIT(1)\n\n/** @brief Append locations (within the package) of read-write string pointers.\n *\n * When this flag is not used then read-write strings are appended to the package.\n */\n#define CBPRINTF_PACKAGE_ADD_RW_STR_POS BIT(2)\n\n#define Z_CBPRINTF_PACKAGE_FIRST_RO_STR_BITS 3\n#define Z_CBPRINTF_PACKAGE_FIRST_RO_STR_OFFSET 3\n#define Z_CBPRINTF_PACKAGE_FIRST_RO_STR_MASK BIT_MASK(Z_CBPRINTF_PACKAGE_FIRST_RO_STR_BITS)\n\n/** @brief Indicate that @p n first string format arguments are char pointers to\n * read-only location.\n *\n * Runtime algorithm (address analysis) is skipped for those strings.\n *\n * @param n Number of string arguments considered as read-only.\n */\n#define CBPRINTF_PACKAGE_FIRST_RO_STR_CNT(n) \\\n\t(n &lt;&lt; Z_CBPRINTF_PACKAGE_FIRST_RO_STR_OFFSET)\n\n/** @brief Get number of first format string arguments which are known to be read-only\n * string.\n */\n#define Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags) \\\n\t(((flags) &gt;&gt; Z_CBPRINTF_PACKAGE_FIRST_RO_STR_OFFSET) &amp; Z_CBPRINTF_PACKAGE_FIRST_RO_STR_MASK)\n\n/** @brief Append indexes of read-only string arguments in the package.\n *\n * When used, package contains locations of read-only string arguments. Package\n * with that information can be converted to fully self-contain package using\n * @ref cbprintf_fsc_package.\n */\n#define CBPRINTF_PACKAGE_ADD_STRING_IDXS \\\n\t(CBPRINTF_PACKAGE_ADD_RO_STR_POS | CBPRINTF_PACKAGE_CONST_CHAR_RO)\n\n/** @brief Indicate the incoming arguments are tagged.\n *\n * When set, this indicates that the incoming arguments are tagged, and\n * need to be processed accordingly.\n */\n#define CBPRINTF_PACKAGE_ARGS_ARE_TAGGED BIT(6)\n\n/**@} */\n\n/**\n * @defgroup CBPRINTF_PACKAGE_CONVERT_FLAGS Package convert flags\n * @{\n */\n\n/** @brief Append read-only strings from source package to destination package.\n *\n * If package was created with @ref CBPRINTF_PACKAGE_ADD_RO_STR_POS\n * or @ref CBPRINTF_PACKAGE_ADD_RW_STR_POS it contains arrays of indexes where\n * string address can be found in the package. When flag is set, read-only strings\n * are copied into destination package. Address of strings indicated as read-write\n * are also checked and if determined to be read-only they are also copied.\n */\n#define CBPRINTF_PACKAGE_CONVERT_RO_STR BIT(0)\n\n/** @brief Append read-write strings from source package to destination package.\n *\n * If package was created with @ref CBPRINTF_PACKAGE_ADD_RW_STR_POS it contains\n * arrays of indexes where string address can be found in the package. When flag\n * is set, list of read-write strings is examined and if they are not determined\n * to be read-only, they are copied into the destination package.\n * If @ref CBPRINTF_PACKAGE_CONVERT_RO_STR is not set, remaining string locations\n * are considered as pointing to read-only location and they are copy to the\n * package if @ref CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR is set.\n */\n#define CBPRINTF_PACKAGE_CONVERT_RW_STR BIT(1)\n\n/** @brief Keep read-only location indexes in the package.\n *\n * If it is set read-only string pointers are kept in the package after copy. If\n * not set they are discarded.\n */\n#define CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR BIT(2)\n\n/** @brief Check format string if %p argument was treated as %s in the package.\n *\n * Static packaging is done based only on types of arguments used for a format\n * string. Without looking into format specifiers present in the string. Because\n * of that if (unsigned) char pointer is used for %p it will be considered as\n * a string location and during conversion an attempt to append a string to a\n * package may be performed. This can lead to misbehavior, in the best case\n * package will be bigger and in the worst case memory fault or security violation\n * may occur.\n *\n * When this flag is set, format string will be checked to detect cases when\n * string candidate is a pointer used for %p and string appending from unexpected\n * location is avoided. Additionally, an log warning is generated to encourage\n * user to cast such argument to void *. It is recommended because there are\n * configurations where string is not accessible and inspection cannot be done.\n * In those cases there are no means to detect such cases.\n */\n#define CBPRINTF_PACKAGE_CONVERT_PTR_CHECK BIT(3)\n\n/**@} */\n\n/**\n * @defgroup Z_CBVPRINTF_PROCESS_FLAGS cbvprintf processing flags.\n * @{\n */\n\n/** @brief Indicates the arguments are tagged.\n *\n * This tells z_cbvprintf_impl() that the incoming arguments are\n * tagged, and should be processed accordingly.\n */\n#define Z_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS BIT(0)\n\n/**@} */\n\n#include &lt;zephyr/sys/cbprintf_enums.h&gt;\n\n/** @brief Signature for a cbprintf callback function.\n *\n * This function expects two parameters:\n *\n * * @p c a character to output.  The output behavior should be as if\n *   this was cast to an unsigned char.\n * * @p ctx a pointer to an object that provides context for the\n *   output operation.\n *\n * The declaration does not specify the parameter types.  This allows a\n * function like @c fputc to be used without requiring all context pointers to\n * be to a @c FILE object.\n *\n * @return the value of @p c cast to an unsigned char then back to\n * int, or a negative error code that will be returned from\n * cbprintf().\n */\n#ifdef __CHECKER__\ntypedef int (*cbprintf_cb)(int c, void *ctx);\n#else\ntypedef int (*cbprintf_cb)(/* int c, void *ctx */);\n#endif\n\n/* Create local cbprintf_cb type to make calng-based compilers happy when handles\n * OUTC() macro (see below). With strict rules (Wincompatible-function-pointer-types-strict)\n * it&#x27;s prohibited to pass arguments with mismatched types.\n */\ntypedef int (*cbprintf_cb_local)(int c, void *ctx);\n\n/** @brief Signature for a cbprintf multibyte callback function.\n *\n * @param buf data.\n * @param len data length.\n * @param ctx a pointer to an object that provides context for the operation.\n *\n * return Amount of copied data or negative error code.\n */\ntypedef int (*cbprintf_convert_cb)(const void *buf, size_t len, void *ctx);\n\n/** @brief Signature for a external formatter function identical to cbvprintf.\n *\n * This function expects the following parameters:\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx a pointer to an object that provides context for the\n * external formatter.\n *\n * @param fmt a standard ISO C format string with characters and\n * conversion specifications.\n *\n * @param ap captured stack arguments corresponding to the conversion\n * specifications found within @p fmt.\n *\n * @return vprintf like return values: the number of characters printed,\n * or a negative error value returned from external formatter.\n */\ntypedef int (*cbvprintf_external_formatter_func)(cbprintf_cb out, void *ctx,\n\t\t\t\t\t\t const char *fmt, va_list ap);\n\n/** @brief Determine if string must be packaged in run time.\n *\n * Static packaging can be applied if size of the package can be determined\n * at compile time. In general, package size can be determined at compile time\n * if there are no string arguments which might be copied into package body if\n * they are considered transient.\n *\n * @note By default any char pointers are considered to be pointing at transient\n * strings. This can be narrowed down to non const pointers by using\n * @ref CBPRINTF_PACKAGE_CONST_CHAR_RO.\n *\n * @param ... String with arguments.\n * @param flags option flags. See @ref CBPRINTF_PACKAGE_FLAGS.\n *\n * @retval 1 if string must be packaged in run time.\n * @retval 0 string can be statically packaged.\n */\n#define CBPRINTF_MUST_RUNTIME_PACKAGE(flags, ... /* fmt, ... */) \\\n\tZ_CBPRINTF_MUST_RUNTIME_PACKAGE(flags, __VA_ARGS__)\n\n/** @brief Statically package string.\n *\n * Build string package from formatted string. It assumes that formatted\n * string is in the read only memory.\n *\n * If _Generic is not supported then runtime packaging is performed.\n *\n * @param packaged pointer to where the packaged data can be stored. Pass a null\n * pointer to skip packaging but still calculate the total space required.\n * The data stored here is relocatable, that is it can be moved to another\n * contiguous block of memory. It must be aligned to the size of the longest\n * argument. It is recommended to use CBPRINTF_PACKAGE_ALIGNMENT for alignment.\n *\n * @param inlen set to the number of bytes available at @p packaged. If\n * @p packaged is NULL the value is ignored.\n *\n * @param outlen variable updated to the number of bytes required to completely\n * store the packed information. If input buffer was too small it is set to\n * -ENOSPC.\n *\n * @param align_offset input buffer alignment offset in bytes. Where offset 0\n * means that buffer is aligned to CBPRINTF_PACKAGE_ALIGNMENT. Xtensa requires\n * that @p packaged is aligned to CBPRINTF_PACKAGE_ALIGNMENT so it must be\n * multiply of CBPRINTF_PACKAGE_ALIGNMENT or 0.\n *\n * @param flags option flags. See @ref CBPRINTF_PACKAGE_FLAGS.\n *\n * @param ... formatted string with arguments. Format string must be constant.\n */\n#define CBPRINTF_STATIC_PACKAGE(packaged, inlen, outlen, align_offset, flags, \\\n\t\t\t\t... /* fmt, ... */) \\\n\tZ_CBPRINTF_STATIC_PACKAGE(packaged, inlen, outlen, \\\n\t\t\t\t  align_offset, flags, __VA_ARGS__)\n\n/** @brief Capture state required to output formatted data later.\n *\n * Like cbprintf() but instead of processing the arguments and emitting the\n * formatted results immediately all arguments are captured so this can be\n * done in a different context, e.g. when the output function can block.\n *\n * In addition to the values extracted from arguments this will ensure that\n * copies are made of the necessary portions of any string parameters that are\n * not confirmed to be stored in read-only memory (hence assumed to be safe to\n * refer to directly later).\n *\n * @param packaged pointer to where the packaged data can be stored.  Pass a\n * null pointer to store nothing but still calculate the total space required.\n * The data stored here is relocatable, that is it can be moved to another\n * contiguous block of memory. However, under condition that alignment is\n * maintained. It must be aligned to at least the size of a pointer.\n *\n * @param len this must be set to the number of bytes available at @p packaged\n * if it is not null. If @p packaged is null then it indicates hypothetical\n * buffer alignment offset in bytes compared to CBPRINTF_PACKAGE_ALIGNMENT\n * alignment. Buffer alignment offset impacts returned size of the package.\n * Xtensa requires that buffer is always aligned to CBPRINTF_PACKAGE_ALIGNMENT\n * so it must be multiply of CBPRINTF_PACKAGE_ALIGNMENT or 0 when @p packaged is\n * null.\n *\n * @param flags option flags. See @ref CBPRINTF_PACKAGE_FLAGS.\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ... arguments corresponding to the conversion specifications found\n * within @p format.\n *\n * @retval nonegative the number of bytes successfully stored at @p packaged.\n * This will not exceed @p len.\n * @retval -EINVAL if @p format is not acceptable\n * @retval -EFAULT if @p packaged alignment is not acceptable\n * @retval -ENOSPC if @p packaged was not null and the space required to store\n * exceed @p len.\n */\n__printf_like(4, 5)\nint cbprintf_package(void *packaged,\n\t\t     size_t len,\n\t\t     uint32_t flags,\n\t\t     const char *format,\n\t\t     ...);\n\n/** @brief Capture state required to output formatted data later.\n *\n * Like cbprintf() but instead of processing the arguments and emitting the\n * formatted results immediately all arguments are captured so this can be\n * done in a different context, e.g. when the output function can block.\n *\n * In addition to the values extracted from arguments this will ensure that\n * copies are made of the necessary portions of any string parameters that are\n * not confirmed to be stored in read-only memory (hence assumed to be safe to\n * refer to directly later).\n *\n * @param packaged pointer to where the packaged data can be stored.  Pass a\n * null pointer to store nothing but still calculate the total space required.\n * The data stored here is relocatable, that is it can be moved to another\n * contiguous block of memory. The pointer must be aligned to a multiple of\n * the largest element in the argument list.\n *\n * @param len this must be set to the number of bytes available at @p packaged.\n * Ignored if @p packaged is NULL.\n *\n * @param flags option flags. See @ref CBPRINTF_PACKAGE_FLAGS.\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap captured stack arguments corresponding to the conversion\n * specifications found within @p format.\n *\n * @retval nonegative the number of bytes successfully stored at @p packaged.\n * This will not exceed @p len.\n * @retval -EINVAL if @p format is not acceptable\n * @retval -ENOSPC if @p packaged was not null and the space required to store\n * exceed @p len.\n */\nint cbvprintf_package(void *packaged,\n\t\t      size_t len,\n\t\t      uint32_t flags,\n\t\t      const char *format,\n\t\t      va_list ap);\n\n/** @brief Convert a package.\n *\n * Converting may include appending strings used in the package to the package body.\n * If input package was created with @ref CBPRINTF_PACKAGE_ADD_RO_STR_POS or\n * @ref CBPRINTF_PACKAGE_ADD_RW_STR_POS, it contains information where strings\n * are located within the package. This information can be used to copy strings\n * during the conversion.\n *\n * @p cb is called with portions of the output package. At the end of the conversion\n * @p cb is called with null buffer.\n *\n * @param in_packaged Input package.\n *\n * @param in_len Input package length. If 0 package length will be retrieved\n * from the @p in_packaged\n *\n * @param cb callback called with portions of the converted package. If null only\n * length of the output package is calculated.\n *\n * @param ctx Context provided to the @p cb.\n *\n * @param flags Flags. See @ref CBPRINTF_PACKAGE_CONVERT_FLAGS.\n *\n * @param[in, out] strl if @p packaged is null, it is a pointer to the array where\n * @p strl_len first string lengths will is stored. If @p packaged is not null,\n * it contains lengths of first @p strl_len strings. It can be used to optimize\n * copying so that string length is calculated only once (at length calculation\n * phase when @p packaged is null.)\n *\n * @param strl_len Number of elements in @p strl array.\n *\n * @retval Positive output package size.\n * @retval -ENOSPC if @p packaged was not null and the space required to store\n * exceed @p len.\n */\nint cbprintf_package_convert(void *in_packaged,\n\t\t\t     size_t in_len,\n\t\t\t     cbprintf_convert_cb cb,\n\t\t\t     void *ctx,\n\t\t\t     uint32_t flags,\n\t\t\t     uint16_t *strl,\n\t\t\t     size_t strl_len);\n\n/* @internal Context used for package copying. */\nstruct z_cbprintf_buf_desc {\n\tvoid *buf;\n\tsize_t size;\n\tsize_t off;\n};\n\n/* @internal Function callback used for package copying. */\nstatic inline int z_cbprintf_cpy(const void *buf, size_t len, void *ctx)\n{\n\tstruct z_cbprintf_buf_desc *desc = (struct z_cbprintf_buf_desc *)ctx;\n\n\tif ((desc-&gt;size - desc-&gt;off) &lt; len) {\n\t\treturn -ENOSPC;\n\t}\n\n\tmemcpy(&amp;((uint8_t *)desc-&gt;buf)[desc-&gt;off], buf, len);\n\tdesc-&gt;off += len;\n\n\treturn len;\n}\n\n/** @brief Copy package with optional appending of strings.\n *\n * @ref cbprintf_package_convert is used to convert and store converted package\n * in the new location.\n *\n * @param in_packaged Input package.\n *\n * @param in_len Input package length. If 0 package length will be retrieved\n * from the @p in_packaged\n *\n * @param[out] packaged Output package. If null only length of the output package\n * is calculated.\n *\n * @param len Available space in the location pointed by @p packaged. Not used when\n * @p packaged is null.\n *\n * @param flags Flags. See @ref CBPRINTF_PACKAGE_CONVERT_FLAGS.\n *\n * @param[in, out] strl if @p packaged is null, it is a pointer to the array where\n * @p strl_len first string lengths will is stored. If @p packaged is not null,\n * it contains lengths of first @p strl_len strings. It can be used to optimize\n * copying so that string length is calculated only once (at length calculation\n * phase when @p packaged is null.)\n *\n * @param strl_len Number of elements in @p strl array.\n *\n * @retval Positive Output package size.\n * @retval -ENOSPC if @p packaged was not null and the space required to store\n * exceed @p len.\n */\nstatic inline int cbprintf_package_copy(void *in_packaged,\n\t\t\t\t\tsize_t in_len,\n\t\t\t\t\tvoid *packaged,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tuint32_t flags,\n\t\t\t\t\tuint16_t *strl,\n\t\t\t\t\tsize_t strl_len)\n{\n\tstruct z_cbprintf_buf_desc buf_desc = {\n\t\t.buf = packaged,\n\t\t.size = len,\n\t\t.off = 0,\n\t};\n\n\treturn cbprintf_package_convert(in_packaged, in_len,\n\t\t\t\t\tpackaged ? z_cbprintf_cpy : NULL, &amp;buf_desc,\n\t\t\t\t\tflags, strl, strl_len);\n}\n\n/** @brief Convert package to fully self-contained (fsc) package.\n *\n * Package may not be self contain since strings by default are stored by address.\n * Package may be partially self-contained when transient (not read only) strings\n * are appended to the package. Such package can be decoded only when there is an\n * access to read-only strings.\n *\n * Fully self-contained has (fsc) contains all strings used in the package. A package\n * can be converted to fsc package if it was create with @ref CBPRINTF_PACKAGE_ADD_RO_STR_POS\n * flag. Such package will contain necessary data to find read only strings in\n * the package and copy them into the package body.\n *\n * @param in_packaged pointer to original package created with\n * @ref CBPRINTF_PACKAGE_ADD_RO_STR_POS.\n *\n * @param in_len @p in_packaged length.\n *\n * @param packaged pointer to location where fully self-contained version of the\n * input package will be written. Pass a null pointer to calculate space required.\n *\n * @param len must be set to the number of bytes available at @p packaged. Not\n * used if @p packaged is null.\n *\n * @retval nonegative the number of bytes successfully stored at @p packaged.\n * This will not exceed @p len. If @p packaged is null, calculated length.\n * @retval -ENOSPC if @p packaged was not null and the space required to store\n * exceed @p len.\n * @retval -EINVAL if @p in_packaged is null.\n */\nstatic inline int cbprintf_fsc_package(void *in_packaged,\n\t\t\t\t       size_t in_len,\n\t\t\t\t       void *packaged,\n\t\t\t\t       size_t len)\n{\n\treturn cbprintf_package_copy(in_packaged, in_len, packaged, len,\n\t\t\t\t     CBPRINTF_PACKAGE_CONVERT_RO_STR |\n\t\t\t\t     CBPRINTF_PACKAGE_CONVERT_RW_STR, NULL, 0);\n}\n\n/** @brief Generate the output for a previously captured format\n * operation using an external formatter.\n *\n * @param out the function used to emit each generated character.\n *\n * @param formatter external formatter function.\n *\n * @param ctx a pointer to an object that provides context for the\n * external formatter.\n *\n * @param packaged the data required to generate the formatted output, as\n * captured by cbprintf_package() or cbvprintf_package(). The alignment\n * requirement on this data is the same as when it was initially created.\n *\n * @note Memory indicated by @p packaged will be modified in a non-destructive\n * way, meaning that it could still be reused with this function again.\n *\n * @return printf like return values: the number of characters printed,\n * or a negative error value returned from external formatter.\n */\nint cbpprintf_external(cbprintf_cb out,\n\t\t       cbvprintf_external_formatter_func formatter,\n\t\t       void *ctx,\n\t\t       void *packaged);\n\n/** @brief *printf-like output through a callback.\n *\n * This is essentially printf() except the output is generated\n * character-by-character using the provided @p out function.  This allows\n * formatting text of unbounded length without incurring the cost of a\n * temporary buffer.\n *\n * All formatting specifiers of C99 are recognized, and most are supported if\n * the functionality is enabled.\n *\n * @note The functionality of this function is significantly reduced\n * when @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx context provided when invoking out\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ... arguments corresponding to the conversion specifications found\n * within @p format.\n *\n * @return the number of characters printed, or a negative error value\n * returned from invoking @p out.\n */\n__printf_like(3, 4)\nint cbprintf(cbprintf_cb out, void *ctx, const char *format, ...);\n\n/** @brief varargs-aware *printf-like output through a callback.\n *\n * This is essentially vsprintf() except the output is generated\n * character-by-character using the provided @p out function.  This allows\n * formatting text of unbounded length without incurring the cost of a\n * temporary buffer.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx context provided when invoking out\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @param flags flags on how to process the inputs.\n *              @see Z_CBVPRINTF_PROCESS_FLAGS.\n *\n * @return the number of characters generated, or a negative error value\n * returned from invoking @p out.\n */\nint z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *format,\n\t\t     va_list ap, uint32_t flags);\n\n/** @brief varargs-aware *printf-like output through a callback.\n *\n * This is essentially vsprintf() except the output is generated\n * character-by-character using the provided @p out function.  This allows\n * formatting text of unbounded length without incurring the cost of a\n * temporary buffer.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx context provided when invoking out\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @return the number of characters generated, or a negative error value\n * returned from invoking @p out.\n */\n#ifdef CONFIG_PICOLIBC\nint cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);\n#else\nstatic inline\nint cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)\n{\n\treturn z_cbvprintf_impl(out, ctx, format, ap, 0);\n}\n#endif\n\n/** @brief varargs-aware *printf-like output through a callback with tagged arguments.\n *\n * This is essentially vsprintf() except the output is generated\n * character-by-character using the provided @p out function.  This allows\n * formatting text of unbounded length without incurring the cost of a\n * temporary buffer.\n *\n * Note that the argument list @p ap are tagged.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx context provided when invoking out\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @return the number of characters generated, or a negative error value\n * returned from invoking @p out.\n */\nstatic inline\nint cbvprintf_tagged_args(cbprintf_cb out, void *ctx,\n\t\t\t  const char *format, va_list ap)\n{\n\treturn z_cbvprintf_impl(out, ctx, format, ap,\n\t\t\t\tZ_CBVPRINTF_PROCESS_FLAG_TAGGED_ARGS);\n}\n\n/** @brief Generate the output for a previously captured format\n * operation.\n *\n * @param out the function used to emit each generated character.\n *\n * @param ctx context provided when invoking out\n *\n * @param packaged the data required to generate the formatted output, as\n * captured by cbprintf_package() or cbvprintf_package(). The alignment\n * requirement on this data is the same as when it was initially created.\n *\n * @note Memory indicated by @p packaged will be modified in a non-destructive\n * way, meaning that it could still be reused with this function again.\n *\n * @return the number of characters printed, or a negative error value\n * returned from invoking @p out.\n */\nstatic inline\nint cbpprintf(cbprintf_cb out, void *ctx, void *packaged)\n{\n#if defined(CONFIG_CBPRINTF_PACKAGE_SUPPORT_TAGGED_ARGUMENTS)\n\tunion cbprintf_package_hdr *hdr =\n\t\t(union cbprintf_package_hdr *)packaged;\n\n\tif ((hdr-&gt;desc.pkg_flags &amp; CBPRINTF_PACKAGE_ARGS_ARE_TAGGED)\n\t    == CBPRINTF_PACKAGE_ARGS_ARE_TAGGED) {\n\t\treturn cbpprintf_external(out, cbvprintf_tagged_args,\n\t\t\t\t\t  ctx, packaged);\n\t}\n#endif\n\n\treturn cbpprintf_external(out, cbvprintf, ctx, packaged);\n}\n\n#ifdef CONFIG_CBPRINTF_LIBC_SUBSTS\n\n#ifdef CONFIG_PICOLIBC\n\n#define fprintfcb(stream, ...) fprintf(stream, __VA_ARGS__)\n#define vfprintfcb(stream, format, ap) vfprintf(stream, format, ap)\n#define printfcb(format, ...) printf(format, __VA_ARGS__)\n#define vprintfcb(format, ap) vprintf(format, ap)\n#define snprintfcb(str, size, ...) snprintf(str, size, __VA_ARGS__)\n#define vsnprintfcb(str, size, format, ap) vsnprintf(str, size, format, ap)\n\n#else\n\n/** @brief fprintf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced\n * when @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param stream the stream to which the output should be written.\n *\n * @param format a standard ISO C format string with characters and\n * conversion specifications.\n *\n * @param ... arguments corresponding to the conversion specifications found\n * within @p format.\n *\n * return The number of characters printed.\n */\n__printf_like(2, 3)\nint fprintfcb(FILE * stream, const char *format, ...);\n\n/** @brief vfprintf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param stream the stream to which the output should be written.\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @return The number of characters printed.\n */\nint vfprintfcb(FILE *stream, const char *format, va_list ap);\n\n/** @brief printf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced\n * when @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param format a standard ISO C format string with characters and\n * conversion specifications.\n *\n * @param ... arguments corresponding to the conversion specifications found\n * within @p format.\n *\n * @return The number of characters printed.\n */\n__printf_like(1, 2)\nint printfcb(const char *format, ...);\n\n/** @brief vprintf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @return The number of characters printed.\n */\nint vprintfcb(const char *format, va_list ap);\n\n/** @brief snprintf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced\n * when @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param str where the formatted content should be written\n *\n * @param size maximum number of chaacters for the formatted output,\n * including the terminating null byte.\n *\n * @param format a standard ISO C format string with characters and\n * conversion specifications.\n *\n * @param ... arguments corresponding to the conversion specifications found\n * within @p format.\n *\n * @return The number of characters that would have been written to @p\n * str, excluding the terminating null byte.  This is greater than the\n * number actually written if @p size is too small.\n */\n__printf_like(3, 4)\nint snprintfcb(char *str, size_t size, const char *format, ...);\n\n/** @brief vsnprintf using Zephyrs cbprintf infrastructure.\n *\n * @note This function is available only when\n * @kconfig{CONFIG_CBPRINTF_LIBC_SUBSTS} is selected.\n *\n * @note The functionality of this function is significantly reduced when\n * @kconfig{CONFIG_CBPRINTF_NANO} is selected.\n *\n * @param str where the formatted content should be written\n *\n * @param size maximum number of chaacters for the formatted output, including\n * the terminating null byte.\n *\n * @param format a standard ISO C format string with characters and conversion\n * specifications.\n *\n * @param ap a reference to the values to be converted.\n *\n * @return The number of characters that would have been written to @p\n * str, excluding the terminating null byte.  This is greater than the\n * number actually written if @p size is too small.\n */\nint vsnprintfcb(char *str, size_t size, const char *format, va_list ap);\n\n#endif /* CONFIG_PICOLIBC */\n#endif /* CONFIG_CBPRINTF_LIBC_SUBSTS */\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZEPHYR_INCLUDE_SYS_CBPRINTF_H_ */\n"}, "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h": {"id": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h", "filePath": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h", "content": "/*\n * Copyright (c) 2010-2011 Dmitry Vyukov\n * Copyright (c) 2023 Intel Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef ZEPHYR_SYS_MPSC_LOCKFREE_H_\n#define ZEPHYR_SYS_MPSC_LOCKFREE_H_\n\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;zephyr/sys/atomic.h&gt;\n#include &lt;zephyr/kernel.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n/**\n * @brief Multiple Producer Single Consumer (MPSC) Lockfree Queue API\n * @defgroup mpsc_lockfree MPSC Lockfree Queue API\n * @ingroup datastructure_apis\n * @{\n */\n\n/**\n * @file mpsc_lockfree.h\n *\n * @brief A wait-free intrusive multi producer single consumer (MPSC) queue using\n * a singly linked list. Ordering is First-In-First-Out.\n *\n * Based on the well known and widely used wait-free MPSC queue described by\n * Dmitry Vyukov with some slight changes to account for needs of an\n * RTOS on a variety of archs. Both consumer and producer are wait free. No CAS\n * loop or lock is needed.\n *\n * An MPSC queue is safe to produce or consume in an ISR with O(1) push/pop.\n *\n * @warning MPSC is *not* safe to consume in multiple execution contexts.\n */\n\n/*\n * On single core systems atomics are unnecessary\n * and cause a lot of unnecessary cache invalidation\n *\n * Using volatile to at least ensure memory is read/written\n * by the compiler generated op codes is enough.\n *\n * On SMP atomics *must* be used to ensure the pointers\n * are updated in the correct order.\n */\n#if defined(CONFIG_SMP)\n\ntypedef atomic_ptr_t mpsc_ptr_t;\n\n#define mpsc_ptr_get(ptr)          atomic_ptr_get(&amp;(ptr))\n#define mpsc_ptr_set(ptr, val)     atomic_ptr_set(&amp;(ptr), val)\n#define mpsc_ptr_set_get(ptr, val) atomic_ptr_set(&amp;(ptr), val)\n\n#else /* defined(CONFIG_SMP) */\n\ntypedef struct mpsc_node *mpsc_ptr_t;\n\n#define mpsc_ptr_get(ptr)      ptr\n#define mpsc_ptr_set(ptr, val) ptr = val\n#define mpsc_ptr_set_get(ptr, val)                                                                 \\\n\t({                                                                                         \\\n\t\tmpsc_ptr_t tmp = ptr;                                                              \\\n\t\tptr = val;                                                                         \\\n\t\ttmp;                                                                               \\\n\t})\n\n#endif /* defined(CONFIG_SMP) */\n\n/**\n * @brief Queue member\n */\nstruct mpsc_node {\n\tmpsc_ptr_t next;\n};\n\n/**\n * @brief MPSC Queue\n */\nstruct mpsc {\n\tmpsc_ptr_t head;\n\tstruct mpsc_node *tail;\n\tstruct mpsc_node stub;\n};\n\n/**\n * @brief Static initializer for a mpsc queue\n *\n * Since the queue is\n *\n * @param symbol name of the queue\n */\n#define MPSC_INIT(symbol)                                                                          \\\n\t{                                                                                          \\\n\t\t.head = (struct mpsc_node *)&amp;symbol.stub,                                          \\\n\t\t.tail = (struct mpsc_node *)&amp;symbol.stub,                                          \\\n\t\t.stub = {                                                                          \\\n\t\t\t.next = NULL,                                                              \\\n\t\t},                                                                                 \\\n\t}\n\n/**\n * @brief Initialize queue\n *\n * @param q Queue to initialize or reset\n */\nstatic inline void mpsc_init(struct mpsc *q)\n{\n\tmpsc_ptr_set(q-&gt;head, &amp;q-&gt;stub);\n\tq-&gt;tail = &amp;q-&gt;stub;\n\tmpsc_ptr_set(q-&gt;stub.next, NULL);\n}\n\n/**\n * @brief Push a node\n *\n * @param q Queue to push the node to\n * @param n Node to push into the queue\n */\nstatic ALWAYS_INLINE void mpsc_push(struct mpsc *q, struct mpsc_node *n)\n{\n\tstruct mpsc_node *prev;\n\tint key;\n\n\tmpsc_ptr_set(n-&gt;next, NULL);\n\n\tkey = arch_irq_lock();\n\tprev = (struct mpsc_node *)mpsc_ptr_set_get(q-&gt;head, n);\n\tmpsc_ptr_set(prev-&gt;next, n);\n\tarch_irq_unlock(key);\n}\n\n/**\n * @brief Pop a node off of the list\n *\n * @retval NULL When no node is available\n * @retval node When node is available\n */\nstatic inline struct mpsc_node *mpsc_pop(struct mpsc *q)\n{\n\tstruct mpsc_node *head;\n\tstruct mpsc_node *tail = q-&gt;tail;\n\tstruct mpsc_node *next = (struct mpsc_node *)mpsc_ptr_get(tail-&gt;next);\n\n\t/* Skip over the stub/sentinel */\n\tif (tail == &amp;q-&gt;stub) {\n\t\tif (next == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tq-&gt;tail = next;\n\t\ttail = next;\n\t\tnext = (struct mpsc_node *)mpsc_ptr_get(next-&gt;next);\n\t}\n\n\t/* If next is non-NULL then a valid node is found, return it */\n\tif (next != NULL) {\n\t\tq-&gt;tail = next;\n\t\treturn tail;\n\t}\n\n\thead = (struct mpsc_node *)mpsc_ptr_get(q-&gt;head);\n\n\t/* If next is NULL, and the tail != HEAD then the queue has pending\n\t * updates that can&#x27;t yet be accessed.\n\t */\n\tif (tail != head) {\n\t\treturn NULL;\n\t}\n\n\tmpsc_push(q, &amp;q-&gt;stub);\n\n\tnext = (struct mpsc_node *)mpsc_ptr_get(tail-&gt;next);\n\n\tif (next != NULL) {\n\t\tq-&gt;tail = next;\n\t\treturn tail;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ZEPHYR_SYS_MPSC_LOCKFREE_H_ */\n"}}, "reports": [{"fileId": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "reportHash": "ad7c9ef9100f1c325cc4523f2b7e2584", "path": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "checker": {"name": "bugprone-branch-clone", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/branch-clone.html"}, "analyzerName": "clang-tidy", "line": 31, "column": 3, "message": "conditional operator with identical true and false expressions", "events": [{"message": "expanded from macro 'LOG_ERR'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log.h", "line": 48, "column": 25}, {"message": "expanded from macro 'Z_LOG'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "line": 318, "column": 44}, {"message": "expanded from macro 'Z_LOG2'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "line": 307, "column": 3}, {"message": "expanded from macro 'Z_LOG_MSG_CREATE'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "line": 582, "column": 2}, {"message": "expanded from macro 'Z_LOG_MSG_CREATE2'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "line": 572, "column": 15}, {"message": "conditional operator with identical true and false expressions", "fileId": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "line": 31, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "reportHash": "e102c93146f00db561037d1be2b50197", "path": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "checker": {"name": "bugprone-branch-clone", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/branch-clone.html"}, "analyzerName": "clang-tidy", "line": 37, "column": 3, "message": "conditional operator with identical true and false expressions", "events": [{"message": "expanded from macro 'LOG_ERR'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log.h", "line": 48, "column": 25}, {"message": "expanded from macro 'Z_LOG'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "line": 318, "column": 44}, {"message": "expanded from macro 'Z_LOG2'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_core.h", "line": 307, "column": 3}, {"message": "expanded from macro 'Z_LOG_MSG_CREATE'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "line": 582, "column": 2}, {"message": "expanded from macro 'Z_LOG_MSG_CREATE2'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/logging/log_msg.h", "line": 572, "column": 15}, {"message": "conditional operator with identical true and false expressions", "fileId": "/home/runner/work/pandora/pandora/pandora/subsys/net/lib/esphome/components/sensor/temperature.c", "line": 37, "column": 3}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "LOW", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h", "reportHash": "6c0ba48e4025bd60157a8fb7f096f3e9", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 57, "column": 23, "message": "narrowing conversion from 'uint32_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'uint32_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/ffs.h", "line": 57, "column": 23}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h", "reportHash": "30452084dae24744a865faa636742bb5", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 42, "column": 9, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/arch/common/sys_bitops.h", "line": 42, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h", "reportHash": "6cdd28d5e33c2fe4fda896a997ba787e", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 563, "column": 9, "message": "narrowing conversion from 'int' to signed type 'device_handle_t' (aka 'short') is implementation-defined", "events": [{"message": "narrowing conversion from 'int' to signed type 'device_handle_t' (aka 'short') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/device.h", "line": 563, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "ea01ac059674948ab7d341e0725bc0c4", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1193, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1193, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "040be408d118e7a3936538d953f8158a", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1195, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1195, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "46f58822bb1dd50fd8e8d5ea074cdce9", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1207, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1207, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "1535c36bc6f0665cef3e679ca49d2bd1", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1208, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1208, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "0f6e4a91feb3ac75c860c83b68072016", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1224, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1224, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "2c6bf3f539a7417b7e4218935e34f775", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1226, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1226, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "f1d4595080652aefd7124d17b7a06eed", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1242, "column": 9, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1242, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "775db8b5f003ed5dc6b5feffcce4aa51", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1253, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1253, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "06f87d26314ab3e4ffecc0c5d598e525", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1254, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1254, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "9993d85f6cc51147f83989a3cff8377a", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1269, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1269, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "0dc5f03864b4622f1b6b087959857c25", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1271, "column": 10, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1271, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "3aeaeae1024a703654d02f093814a97e", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1283, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1283, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "d37c434f2c216aa22267b9f9ab286fbc", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1284, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1284, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "7b1a9d0f14a25c69ef9d923d311d2632", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1302, "column": 9, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1302, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "c91004a528ac04e8f9411db441861d85", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1313, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1313, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "448e3972d966cdfa33b22e7dc23ecdb6", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1314, "column": 14, "message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "events": [{"message": "narrowing conversion from 'long long' to signed type 'int32_t' (aka 'int') is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1314, "column": 14}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "reportHash": "30a6ac94fa19deafd3d4d5cf981ffc55", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1373, "column": 22, "message": "narrowing conversion from 'int32_t' (aka 'int') to 'float'", "events": [{"message": "narrowing conversion from 'int32_t' (aka 'int') to 'float'", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/drivers/sensor.h", "line": 1373, "column": 22}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "7ef37dd53164f7736e5e8506279af052", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 119, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 119, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "6282b471dfb069051446246613548018", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 121, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 121, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "01999dafde3d4c4a5126bc96dcfbb4b9", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 122, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 122, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "4e5a60513d742debf8a16967a6e63986", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 125, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 125, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "7ef37dd53164f7736e5e8506279af052", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 157, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 157, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "6282b471dfb069051446246613548018", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 159, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 159, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "01999dafde3d4c4a5126bc96dcfbb4b9", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 160, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 160, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "reportHash": "4e5a60513d742debf8a16967a6e63986", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "checker": {"name": "clang-diagnostic-embedded-directive", "url": "https://clang.llvm.org/docs/DiagnosticsReference.html#wembedded-directive"}, "analyzerName": "clang-tidy", "line": 163, "column": 2, "message": "embedding a directive within macro arguments has undefined behavior", "events": [{"message": "embedding a directive within macro arguments has undefined behavior", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/kernel/internal/mm.h", "line": 163, "column": 2}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h", "reportHash": "c6555f3028f2605d8ec18796882b0572", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 1607, "column": 9, "message": "narrowing conversion from 'size_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'size_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/rtio/rtio.h", "line": 1607, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "reportHash": "c7d22523550e922c986c69f587facebc", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 191, "column": 10, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "line": 191, "column": 10}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "reportHash": "cfb4f3e3ebaf20e596cf5b9e4c08f11d", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 232, "column": 12, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/spinlock.h", "line": 232, "column": 12}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h", "reportHash": "1476c53b6684ed147702f23ad1001258", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 539, "column": 9, "message": "narrowing conversion from 'size_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'size_t' (aka 'unsigned int') to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/cbprintf.h", "line": 539, "column": 9}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}, {"fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h", "reportHash": "b260e65614f279e8ca5c24fac70d5067", "path": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h", "checker": {"name": "bugprone-narrowing-conversions", "url": "https://clang.llvm.org/extra/clang-tidy/checks/bugprone/narrowing-conversions.html"}, "analyzerName": "clang-tidy", "line": 133, "column": 8, "message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "events": [{"message": "narrowing conversion from 'unsigned int' to signed type 'int' is implementation-defined", "fileId": "/home/runner/work/pandora/pandora/zephyr/include/zephyr/sys/mpsc_lockfree.h", "line": 133, "column": 8}], "macros": [], "notes": [], "reviewStatus": "Unreviewed", "severity": "MEDIUM", "testcase": null, "timestamp": null, "chronologicalOrder": null}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
